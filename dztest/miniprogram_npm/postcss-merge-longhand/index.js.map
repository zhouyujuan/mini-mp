{"version":3,"sources":["index.js","lib/decl/index.js","lib/decl/borders.js","lib/insertCloned.js","lib/parseTrbl.js","lib/hasAllProps.js","lib/getDecls.js","lib/getRules.js","lib/getLastNode.js","lib/getValue.js","lib/mergeRules.js","lib/minifyTrbl.js","lib/minifyWsc.js","lib/parseWsc.js","lib/validateWsc.js","lib/canMerge.js","lib/isCustomProp.js","lib/remove.js","lib/trbl.js","lib/canExplode.js","lib/decl/columns.js","lib/decl/margin.js","lib/decl/boxBase.js","lib/mergeValues.js","lib/decl/padding.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA,ACHA;AJaA,AENA,ADGA,AENA,ACHA;AJaA,AENA,ADGA,AENA,ACHA;AJaA,AENA,ADGA,AIZA,AFMA,ACHA;AJaA,AENA,ADGA,AIZA,AFMA,ACHA;AJaA,AENA,ADGA,AIZA,AFMA,ACHA;AJaA,AENA,ADGA,AKfA,ADGA,AFMA,ACHA;AJaA,AENA,ADGA,AKfA,ADGA,AFMA,ACHA;AJaA,AENA,ADGA,AKfA,ADGA,AFMA,ACHA;AJaA,AENA,ADGA,AKfA,ACHA,AFMA,AFMA,ACHA;AJaA,AENA,ADGA,AKfA,ACHA,AFMA,AFMA,ACHA;AJaA,AENA,ADGA,AKfA,ACHA,AFMA,ADGA;AJaA,AENA,ADGA,AKfA,AENA,ADGA,AFMA,ADGA;AJaA,AENA,ADGA,AKfA,AENA,ADGA,AFMA,ADGA;AJaA,AENA,ADGA,AKfA,AENA,ADGA,AHSA;AFOA,ADGA,AKfA,AENA,ADGA,AENA,ALeA;AFOA,ADGA,AOrBA,ADGA,AENA,ALeA;AFOA,AMlBA,ADGA,AENA;APsBA,AMlBA,ADGA,AENA,ACHA;ARyBA,AMlBA,ADGA,AENA,ACHA;ARyBA,AMlBA,ADGA,AENA,ACHA;ARyBA,AMlBA,ADGA,AENA,ACHA,ACHA;AT4BA,AMlBA,ADGA,AENA,ACHA,ACHA;AT4BA,AKfA,AENA,ACHA,ACHA;AT4BA,AKfA,AENA,ACHA,ACHA,ACHA;AV+BA,AKfA,AGTA,ACHA,ACHA;AV+BA,AKfA,AGTA,ACHA,ACHA;AV+BA,AKfA,AGTA,ACHA,ACHA,ACHA;AXkCA,AQxBA,ACHA,ACHA,ACHA;AXkCA,AQxBA,ACHA,ACHA,ACHA;AXkCA,AQxBA,ACHA,ACHA,ACHA,ACHA;AZqCA,AQxBA,ACHA,ACHA,ACHA,ACHA;AZqCA,AQxBA,ACHA,ACHA,ACHA,ACHA;ACFA,AbuCA,AQxBA,ACHA,ACHA,ACHA,ACHA;ACFA,AbuCA,AQxBA,ACHA,ACHA,ACHA,ACHA;ACFA,AbuCA,AQxBA,ACHA,ACHA,ACHA,ACHA;ACFA,AbuCA,Ac1CA,ANkBA,ACHA,ACHA,ACHA,ACHA;ACFA,AbuCA,Ac1CA,ANkBA,ACHA,ACHA,ACHA,ACHA;ACFA,AbuCA,Ac1CA,ANkBA,ACHA,ACHA,ACHA,ACHA;ACFA,AbuCA,Ac1CA,ANkBA,ACHA,ACHA,ACHA,AIZA,AHSA;ACFA,AbuCA,Ac1CA,ANkBA,ACHA,ACHA,ACHA,AIZA,AHSA;ACFA,AbuCA,Ac1CA,ANkBA,ACHA,ACHA,ACHA,AIZA,AHSA;ACFA,AbuCA,Ac1CA,ANkBA,ACHA,ACHA,ACHA,AIZA,ACHA,AJYA;ACFA,AbuCA,Ac1CA,ANkBA,ACHA,ACHA,ACHA,AIZA,ACHA,AJYA;ACFA,AbuCA,Ac1CA,ANkBA,ACHA,ACHA,ACHA,AIZA,ACHA,AJYA;AKdA,AJYA,AbuCA,AQxBA,ACHA,ACHA,ACHA,AIZA,ACHA,AJYA;AKdA,AJYA,AbuCA,AQxBA,ACHA,ACHA,ACHA,AIZA,ACHA,AJYA;AKdA,AJYA,AbuCA,AQxBA,ACHA,ACHA,ACHA,AIZA,ACHA,AJYA;AKdA,AJYA,AbuCA,AkBtDA,AV8BA,ACHA,ACHA,ACHA,AIZA,ACHA,AJYA;AKdA,AJYA,AbuCA,AkBtDA,AV8BA,ACHA,ACHA,ACHA,ACHA;AKdA,AJYA,AbuCA,AkBtDA,AV8BA,ACHA,ACHA,ACHA,ACHA;AKdA,AJYA,AbuCA,AkBtDA,ACHA,AXiCA,ACHA,ACHA,ACHA,ACHA;AKdA,AJYA,AbuCA,AkBtDA,ACHA,AXiCA,AENA,ACHA,ACHA;AKdA,AJYA,AbuCA,AkBtDA,ACHA,AXiCA,AENA,ACHA,ACHA;AKdA,AJYA,AbuCA,AoB5DA,AFMA,ACHA,AXiCA,AENA,ACHA,ACHA;AKdA,AJYA,AbuCA,AoB5DA,AFMA,ACHA,AXiCA,AENA,ACHA,ACHA;AKdA,AJYA,AbuCA,AoB5DA,AFMA,ACHA,AXiCA,AENA,ACHA,ACHA;AKdA,AJYA,AbuCA,AoB5DA,AFMA,ACHA,AXiCA,AavCA,AXiCA,ACHA,ACHA;AKdA,AJYA,AbuCA,AoB5DA,AFMA,ACHA,AXiCA,AavCA,AXiCA,ACHA,ACHA;AKdA,AJYA,AbuCA,AoB5DA,AFMA,ACHA,AXiCA,AavCA,AXiCA,ACHA,ACHA;AKdA,AJYA,AbuCA,AoB5DA,AFMA,ACHA,AGTA,Ad0CA,AavCA,AXiCA,ACHA,ACHA;AKdA,AJYA,AbuCA,AoB5DA,AFMA,ACHA,AGTA,Ad0CA,AavCA,AXiCA,ACHA,ACHA;AKdA,AJYA,AbuCA,AoB5DA,AFMA,ACHA,AGTA,Ad0CA,AavCA,AXiCA,ACHA,ACHA;AKdA,AJYA,AbuCA,AoB5DA,AFMA,ACHA,AGTA,Ad0CA,AavCA,AV8BA,ACHA;AKdA,AJYA,AbuCA,AoB5DA,AFMA,ACHA,AGTA,Ad0CA,AavCA,AV8BA,ACHA;AKdA,AJYA,AbuCA,AoB5DA,AFMA,AIZA,Ad0CA,AavCA,AV8BA,ACHA;AKdA,AJYA,AbuCA,AoB5DA,AFMA,AIZA,Ad0CA,AavCA,AV8BA,ACHA;AKdA,AJYA,AbuCA,AoB5DA,AFMA,AIZA,Ad0CA,AavCA,AV8BA,ACHA;AKdA,AJYA,AbuCA,AoB5DA,AFMA,AIZA,Ad0CA,AavCA,AV8BA,ACHA;AKdA,AJYA,AbuCA,AoB5DA,AFMA,AIZA,Ad0CA,AavCA,AV8BA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AIZA,Ad0CA,AavCA,AV8BA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AIZA,Ad0CA,AavCA,AV8BA,ACHA;ACFA,AbuCA,AoB5DA,AFMA,AIZA,Ad0CA,AGTA,ACHA;AZqCA,AoB5DA,AFMA,AIZA,Ad0CA,AGTA,ACHA;AZqCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;AZqCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;AZqCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;AZqCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;AZqCA,AoB5DA,AFMA,AV8BA,AGTA,ACHA;AZqCA,AoB5DA,AFMA,APqBA,ACHA;AZqCA,AoB5DA,AFMA,APqBA,ACHA;AZqCA,AoB5DA,AFMA,APqBA,ACHA;AZqCA,AoB5DA,AFMA,APqBA,ACHA;AZqCA,AoB5DA,AFMA,APqBA,ACHA;AZqCA,AoB5DA,AFMA,APqBA,ACHA;AZqCA,AoB5DA,AFMA,APqBA,ACHA;AZqCA,AoB5DA,AFMA,APqBA,ACHA;AZqCA,AoB5DA,AFMA,APqBA,ACHA;AZqCA,AoB5DA,AFMA,APqBA,ACHA;AZqCA,AoB5DA,AFMA,APqBA,ACHA;AZqCA,AoB5DA,AFMA,APqBA,ACHA;AZqCA,AoB5DA,AFMA,APqBA,ACHA;AZqCA,AoB5DA,AFMA,ANkBA;AZqCA,AoB5DA,AFMA,ANkBA;AZqCA,AoB5DA,AFMA,ANkBA;AZqCA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AoB5DA,AFMA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _postcss = require('postcss');\n\nvar _postcss2 = _interopRequireDefault(_postcss);\n\nvar _decl = require('./lib/decl');\n\nvar _decl2 = _interopRequireDefault(_decl);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _postcss2.default.plugin('postcss-merge-longhand', () => {\n    return css => {\n        css.walkRules(rule => {\n            _decl2.default.forEach(p => {\n                p.explode(rule);\n                p.merge(rule);\n            });\n        });\n    };\n});\nmodule.exports = exports['default'];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _borders = require('./borders');\n\nvar _borders2 = _interopRequireDefault(_borders);\n\nvar _columns = require('./columns');\n\nvar _columns2 = _interopRequireDefault(_columns);\n\nvar _margin = require('./margin');\n\nvar _margin2 = _interopRequireDefault(_margin);\n\nvar _padding = require('./padding');\n\nvar _padding2 = _interopRequireDefault(_padding);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = [_borders2.default, _columns2.default, _margin2.default, _padding2.default];\nmodule.exports = exports['default'];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _postcss = require('postcss');\n\nvar _stylehacks = require('stylehacks');\n\nvar _insertCloned = require('../insertCloned');\n\nvar _insertCloned2 = _interopRequireDefault(_insertCloned);\n\nvar _parseTrbl = require('../parseTrbl');\n\nvar _parseTrbl2 = _interopRequireDefault(_parseTrbl);\n\nvar _hasAllProps = require('../hasAllProps');\n\nvar _hasAllProps2 = _interopRequireDefault(_hasAllProps);\n\nvar _getDecls = require('../getDecls');\n\nvar _getDecls2 = _interopRequireDefault(_getDecls);\n\nvar _getRules = require('../getRules');\n\nvar _getRules2 = _interopRequireDefault(_getRules);\n\nvar _getValue = require('../getValue');\n\nvar _getValue2 = _interopRequireDefault(_getValue);\n\nvar _mergeRules = require('../mergeRules');\n\nvar _mergeRules2 = _interopRequireDefault(_mergeRules);\n\nvar _minifyTrbl = require('../minifyTrbl');\n\nvar _minifyTrbl2 = _interopRequireDefault(_minifyTrbl);\n\nvar _minifyWsc = require('../minifyWsc');\n\nvar _minifyWsc2 = _interopRequireDefault(_minifyWsc);\n\nvar _canMerge = require('../canMerge');\n\nvar _canMerge2 = _interopRequireDefault(_canMerge);\n\nvar _remove = require('../remove');\n\nvar _remove2 = _interopRequireDefault(_remove);\n\nvar _trbl = require('../trbl');\n\nvar _trbl2 = _interopRequireDefault(_trbl);\n\nvar _isCustomProp = require('../isCustomProp');\n\nvar _isCustomProp2 = _interopRequireDefault(_isCustomProp);\n\nvar _canExplode = require('../canExplode');\n\nvar _canExplode2 = _interopRequireDefault(_canExplode);\n\nvar _getLastNode = require('../getLastNode');\n\nvar _getLastNode2 = _interopRequireDefault(_getLastNode);\n\nvar _parseWsc = require('../parseWsc');\n\nvar _parseWsc2 = _interopRequireDefault(_parseWsc);\n\nvar _validateWsc = require('../validateWsc');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst wsc = ['width', 'style', 'color'];\nconst defaults = ['medium', 'none', 'currentcolor'];\n\nfunction borderProperty(...parts) {\n    return `border-${parts.join('-')}`;\n}\n\nfunction mapBorderProperty(value) {\n    return borderProperty(value);\n}\n\nconst directions = _trbl2.default.map(mapBorderProperty);\nconst properties = wsc.map(mapBorderProperty);\nconst directionalProperties = directions.reduce((prev, curr) => prev.concat(wsc.map(prop => `${curr}-${prop}`)), []);\n\nconst precedence = [['border'], directions.concat(properties), directionalProperties];\n\nconst allProperties = precedence.reduce((a, b) => a.concat(b));\n\nfunction getLevel(prop) {\n    for (let i = 0; i < precedence.length; i++) {\n        if (!!~precedence[i].indexOf(prop.toLowerCase())) {\n            return i;\n        }\n    }\n}\n\nconst isValueCustomProp = value => value && !!~value.search(/var\\s*\\(\\s*--/i);\n\nfunction canMergeValues(values) {\n    return !values.some(isValueCustomProp) || values.every(isValueCustomProp);\n}\n\nfunction getColorValue(decl) {\n    if (decl.prop.substr(-5) === 'color') {\n        return decl.value;\n    }\n\n    return (0, _parseWsc2.default)(decl.value)[2] || defaults[2];\n}\n\nfunction diffingProps(values, nextValues) {\n    return wsc.reduce((prev, curr, i) => {\n        if (values[i] === nextValues[i]) {\n            return prev;\n        }\n\n        return [...prev, curr];\n    }, []);\n}\n\nfunction mergeRedundant({ values, nextValues, decl, nextDecl, index }) {\n    if (!(0, _canMerge2.default)([decl, nextDecl])) {\n        return;\n    }\n\n    if ((0, _stylehacks.detect)(decl) || (0, _stylehacks.detect)(nextDecl)) {\n        return;\n    }\n\n    const diff = diffingProps(values, nextValues);\n\n    if (diff.length > 1) {\n        return;\n    }\n\n    const prop = diff.pop();\n    const position = wsc.indexOf(prop);\n\n    const prop1 = `${nextDecl.prop}-${prop}`;\n    const prop2 = `border-${prop}`;\n\n    let props = (0, _parseTrbl2.default)(values[position]);\n\n    props[index] = nextValues[position];\n\n    const borderValue2 = values.filter((e, i) => i !== position).join(' ');\n    const propValue2 = (0, _minifyTrbl2.default)(props);\n\n    const origLength = ((0, _minifyWsc2.default)(decl.value) + nextDecl.prop + nextDecl.value).length;\n    const newLength1 = decl.value.length + prop1.length + (0, _minifyWsc2.default)(nextValues[position]).length;\n    const newLength2 = borderValue2.length + prop2.length + propValue2.length;\n\n    if (newLength1 < newLength2 && newLength1 < origLength) {\n        nextDecl.prop = prop1;\n        nextDecl.value = nextValues[position];\n    }\n\n    if (newLength2 < newLength1 && newLength2 < origLength) {\n        decl.value = borderValue2;\n        nextDecl.prop = prop2;\n        nextDecl.value = propValue2;\n    }\n}\n\nfunction isCloseEnough(mapped) {\n    return mapped[0] === mapped[1] && mapped[1] === mapped[2] || mapped[1] === mapped[2] && mapped[2] === mapped[3] || mapped[2] === mapped[3] && mapped[3] === mapped[0] || mapped[3] === mapped[0] && mapped[0] === mapped[1];\n}\n\nfunction getDistinctShorthands(mapped) {\n    return mapped.reduce((a, b) => {\n        a = Array.isArray(a) ? a : [a];\n\n        if (!~a.indexOf(b)) {\n            a.push(b);\n        }\n\n        return a;\n    });\n}\n\nfunction explode(rule) {\n    rule.walkDecls(/^border/i, decl => {\n        if (!(0, _canExplode2.default)(decl, false)) {\n            return;\n        }\n\n        if ((0, _stylehacks.detect)(decl)) {\n            return;\n        }\n\n        const prop = decl.prop.toLowerCase();\n\n        // border -> border-trbl\n        if (prop === 'border') {\n            if ((0, _validateWsc.isValidWsc)((0, _parseWsc2.default)(decl.value))) {\n                directions.forEach(direction => {\n                    (0, _insertCloned2.default)(decl.parent, decl, { prop: direction });\n                });\n\n                return decl.remove();\n            }\n        }\n\n        // border-trbl -> border-trbl-wsc\n        if (directions.some(direction => prop === direction)) {\n            let values = (0, _parseWsc2.default)(decl.value);\n\n            if ((0, _validateWsc.isValidWsc)(values)) {\n                wsc.forEach((d, i) => {\n                    (0, _insertCloned2.default)(decl.parent, decl, {\n                        prop: `${prop}-${d}`,\n                        value: values[i] || defaults[i]\n                    });\n                });\n\n                return decl.remove();\n            }\n        }\n\n        // border-wsc -> border-trbl-wsc\n        wsc.some(style => {\n            if (prop !== borderProperty(style)) {\n                return false;\n            }\n\n            (0, _parseTrbl2.default)(decl.value).forEach((value, i) => {\n                (0, _insertCloned2.default)(decl.parent, decl, {\n                    prop: borderProperty(_trbl2.default[i], style),\n                    value\n                });\n            });\n\n            return decl.remove();\n        });\n    });\n}\n\nfunction merge(rule) {\n    // border-trbl-wsc -> border-trbl\n    _trbl2.default.forEach(direction => {\n        const prop = borderProperty(direction);\n\n        (0, _mergeRules2.default)(rule, wsc.map(style => borderProperty(direction, style)), (rules, lastNode) => {\n            if ((0, _canMerge2.default)(rules, false) && !rules.some(_stylehacks.detect)) {\n                (0, _insertCloned2.default)(lastNode.parent, lastNode, {\n                    prop,\n                    value: rules.map(_getValue2.default).join(' ')\n                });\n\n                rules.forEach(_remove2.default);\n\n                return true;\n            }\n        });\n    });\n\n    // border-trbl-wsc -> border-wsc\n    wsc.forEach(style => {\n        const prop = borderProperty(style);\n\n        (0, _mergeRules2.default)(rule, _trbl2.default.map(direction => borderProperty(direction, style)), (rules, lastNode) => {\n            if ((0, _canMerge2.default)(rules) && !rules.some(_stylehacks.detect)) {\n                (0, _insertCloned2.default)(lastNode.parent, lastNode, {\n                    prop,\n                    value: (0, _minifyTrbl2.default)(rules.map(_getValue2.default).join(' '))\n                });\n\n                rules.forEach(_remove2.default);\n\n                return true;\n            }\n        });\n    });\n\n    // border-trbl -> border-wsc\n    (0, _mergeRules2.default)(rule, directions, (rules, lastNode) => {\n        if (rules.some(_stylehacks.detect)) {\n            return;\n        }\n\n        const values = rules.map(({ value }) => value);\n\n        if (!canMergeValues(values)) {\n            return;\n        }\n\n        const parsed = values.map(value => (0, _parseWsc2.default)(value));\n\n        if (!parsed.every(_validateWsc.isValidWsc)) {\n            return;\n        }\n\n        wsc.forEach((d, i) => {\n            const value = parsed.map(v => v[i] || defaults[i]);\n\n            if (canMergeValues(value)) {\n                (0, _insertCloned2.default)(lastNode.parent, lastNode, {\n                    prop: borderProperty(d),\n                    value: (0, _minifyTrbl2.default)(value)\n                });\n            } else {\n                (0, _insertCloned2.default)(lastNode.parent, lastNode);\n            }\n        });\n\n        rules.forEach(_remove2.default);\n\n        return true;\n    });\n\n    // border-wsc -> border\n    // border-wsc -> border + border-color\n    // border-wsc -> border + border-dir\n    (0, _mergeRules2.default)(rule, properties, (rules, lastNode) => {\n        if (rules.some(_stylehacks.detect)) {\n            return;\n        }\n\n        const values = rules.map(node => (0, _parseTrbl2.default)(node.value));\n        const mapped = [0, 1, 2, 3].map(i => [values[0][i], values[1][i], values[2][i]].join(' '));\n\n        if (!canMergeValues(mapped)) {\n            return;\n        }\n\n        const [width, style, color] = rules;\n        const reduced = getDistinctShorthands(mapped);\n\n        if (isCloseEnough(mapped) && (0, _canMerge2.default)(rules, false)) {\n            const first = mapped.indexOf(reduced[0]) !== mapped.lastIndexOf(reduced[0]);\n\n            const border = (0, _insertCloned2.default)(lastNode.parent, lastNode, {\n                prop: 'border',\n                value: first ? reduced[0] : reduced[1]\n            });\n\n            if (reduced[1]) {\n                const value = first ? reduced[1] : reduced[0];\n                const prop = borderProperty(_trbl2.default[mapped.indexOf(value)]);\n\n                rule.insertAfter(border, Object.assign(lastNode.clone(), {\n                    prop,\n                    value\n                }));\n            }\n            rules.forEach(_remove2.default);\n\n            return true;\n        } else if (reduced.length === 1) {\n            rule.insertBefore(color, Object.assign(lastNode.clone(), {\n                prop: 'border',\n                value: [width, style].map(_getValue2.default).join(' ')\n            }));\n            rules.filter(node => node.prop.toLowerCase() !== properties[2]).forEach(_remove2.default);\n\n            return true;\n        }\n    });\n\n    // border-wsc -> border + border-trbl\n    (0, _mergeRules2.default)(rule, properties, (rules, lastNode) => {\n        if (rules.some(_stylehacks.detect)) {\n            return;\n        }\n\n        const values = rules.map(node => (0, _parseTrbl2.default)(node.value));\n        const mapped = [0, 1, 2, 3].map(i => [values[0][i], values[1][i], values[2][i]].join(' '));\n        const reduced = getDistinctShorthands(mapped);\n        const none = 'medium none currentcolor';\n\n        if (reduced.length > 1 && reduced.length < 4 && reduced.includes(none)) {\n            const filtered = mapped.filter(p => p !== none);\n            const mostCommon = reduced.sort((a, b) => mapped.filter(v => v === b).length - mapped.filter(v => v === a).length)[0];\n            const borderValue = reduced.length === 2 ? filtered[0] : mostCommon;\n\n            rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {\n                prop: 'border',\n                value: borderValue\n            }));\n\n            directions.forEach((dir, i) => {\n                if (mapped[i] !== borderValue) {\n                    rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {\n                        prop: dir,\n                        value: mapped[i]\n                    }));\n                }\n            });\n\n            rules.forEach(_remove2.default);\n\n            return true;\n        }\n    });\n\n    // border-trbl -> border\n    // border-trbl -> border + border-trbl\n    (0, _mergeRules2.default)(rule, directions, (rules, lastNode) => {\n        if (rules.some(_stylehacks.detect)) {\n            return;\n        }\n\n        const values = rules.map(node => {\n            const wscValue = (0, _parseWsc2.default)(node.value);\n\n            if (!(0, _validateWsc.isValidWsc)(wscValue)) {\n                return node.value;\n            }\n\n            return wscValue.map((value, i) => value || defaults[i]).join(' ');\n        });\n\n        const reduced = getDistinctShorthands(values);\n\n        if (isCloseEnough(values)) {\n            const first = values.indexOf(reduced[0]) !== values.lastIndexOf(reduced[0]);\n\n            rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {\n                prop: 'border',\n                value: (0, _minifyWsc2.default)(first ? values[0] : values[1])\n            }));\n\n            if (reduced[1]) {\n                const value = first ? reduced[1] : reduced[0];\n                const prop = directions[values.indexOf(value)];\n                rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {\n                    prop: prop,\n                    value: (0, _minifyWsc2.default)(value)\n                }));\n            }\n\n            rules.forEach(_remove2.default);\n\n            return true;\n        }\n    });\n\n    // border-trbl-wsc + border-trbl (custom prop) -> border-trbl + border-trbl-wsc (custom prop)\n    directions.forEach(direction => {\n        wsc.forEach((style, i) => {\n            const prop = `${direction}-${style}`;\n\n            (0, _mergeRules2.default)(rule, [direction, prop], (rules, lastNode) => {\n                if (lastNode.prop !== direction) {\n                    return;\n                }\n\n                const values = (0, _parseWsc2.default)(lastNode.value);\n\n                if (!(0, _validateWsc.isValidWsc)(values)) {\n                    return;\n                }\n\n                const wscProp = rules.filter(r => r !== lastNode)[0];\n\n                if (!isValueCustomProp(values[i]) || (0, _isCustomProp2.default)(wscProp)) {\n                    return;\n                }\n\n                const wscValue = values[i];\n\n                values[i] = wscProp.value;\n\n                if ((0, _canMerge2.default)(rules, false) && !rules.some(_stylehacks.detect)) {\n                    (0, _insertCloned2.default)(lastNode.parent, lastNode, {\n                        prop,\n                        value: wscValue\n                    });\n                    lastNode.value = (0, _minifyWsc2.default)(values);\n\n                    wscProp.remove();\n\n                    return true;\n                }\n            });\n        });\n    });\n\n    // border-wsc + border (custom prop) -> border + border-wsc (custom prop)\n    wsc.forEach((style, i) => {\n        const prop = borderProperty(style);\n        (0, _mergeRules2.default)(rule, ['border', prop], (rules, lastNode) => {\n            if (lastNode.prop !== 'border') {\n                return;\n            }\n\n            const values = (0, _parseWsc2.default)(lastNode.value);\n\n            if (!(0, _validateWsc.isValidWsc)(values)) {\n                return;\n            }\n\n            const wscProp = rules.filter(r => r !== lastNode)[0];\n\n            if (!isValueCustomProp(values[i]) || (0, _isCustomProp2.default)(wscProp)) {\n                return;\n            }\n\n            const wscValue = values[i];\n\n            values[i] = wscProp.value;\n\n            if ((0, _canMerge2.default)(rules, false) && !rules.some(_stylehacks.detect)) {\n                (0, _insertCloned2.default)(lastNode.parent, lastNode, {\n                    prop,\n                    value: wscValue\n                });\n                lastNode.value = (0, _minifyWsc2.default)(values);\n                wscProp.remove();\n\n                return true;\n            }\n        });\n    });\n\n    // optimize border-trbl\n    let decls = (0, _getDecls2.default)(rule, directions);\n\n    while (decls.length) {\n        const lastNode = decls[decls.length - 1];\n\n        wsc.forEach((d, i) => {\n            const names = directions.filter(name => name !== lastNode.prop).map(name => `${name}-${d}`);\n\n            let nodes = rule.nodes.slice(0, rule.nodes.indexOf(lastNode));\n\n            const border = (0, _getLastNode2.default)(nodes, 'border');\n\n            if (border) {\n                nodes = nodes.slice(nodes.indexOf(border));\n            }\n\n            const props = nodes.filter(node => node.prop && ~names.indexOf(node.prop) && node.important === lastNode.important);\n            const rules = (0, _getRules2.default)(props, names);\n\n            if ((0, _hasAllProps2.default)(rules, ...names) && !rules.some(_stylehacks.detect)) {\n                const values = rules.map(node => node ? node.value : null);\n                const filteredValues = values.filter(Boolean);\n                const lastNodeValue = _postcss.list.space(lastNode.value)[i];\n\n                values[directions.indexOf(lastNode.prop)] = lastNodeValue;\n\n                let value = (0, _minifyTrbl2.default)(values.join(' '));\n\n                if (filteredValues[0] === filteredValues[1] && filteredValues[1] === filteredValues[2]) {\n                    value = filteredValues[0];\n                }\n\n                let refNode = props[props.length - 1];\n\n                if (value === lastNodeValue) {\n                    refNode = lastNode;\n                    let valueArray = _postcss.list.space(lastNode.value);\n                    valueArray.splice(i, 1);\n                    lastNode.value = valueArray.join(' ');\n                }\n\n                (0, _insertCloned2.default)(refNode.parent, refNode, {\n                    prop: borderProperty(d),\n                    value\n                });\n\n                decls = decls.filter(node => !~rules.indexOf(node));\n                rules.forEach(_remove2.default);\n            }\n        });\n\n        decls = decls.filter(node => node !== lastNode);\n    }\n\n    rule.walkDecls('border', decl => {\n        const nextDecl = decl.next();\n\n        if (!nextDecl || nextDecl.type !== 'decl') {\n            return;\n        }\n\n        const index = directions.indexOf(nextDecl.prop);\n\n        if (!~index) {\n            return;\n        }\n\n        const values = (0, _parseWsc2.default)(decl.value);\n        const nextValues = (0, _parseWsc2.default)(nextDecl.value);\n\n        if (!(0, _validateWsc.isValidWsc)(values) || !(0, _validateWsc.isValidWsc)(nextValues)) {\n            return;\n        }\n\n        const config = {\n            values,\n            nextValues,\n            decl,\n            nextDecl,\n            index\n        };\n\n        return mergeRedundant(config);\n    });\n\n    rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, decl => {\n        let values = (0, _parseWsc2.default)(decl.value);\n\n        if (!(0, _validateWsc.isValidWsc)(values)) {\n            return;\n        }\n\n        const position = directions.indexOf(decl.prop);\n        let dirs = [...directions];\n\n        dirs.splice(position, 1);\n        wsc.forEach((d, i) => {\n            const props = dirs.map(dir => `${dir}-${d}`);\n\n            (0, _mergeRules2.default)(rule, [decl.prop, ...props], rules => {\n                if (!rules.includes(decl)) {\n                    return;\n                }\n\n                const longhands = rules.filter(p => p !== decl);\n\n                if (longhands[0].value.toLowerCase() === longhands[1].value.toLowerCase() && longhands[1].value.toLowerCase() === longhands[2].value.toLowerCase() && longhands[0].value.toLowerCase() === values[i].toLowerCase()) {\n                    longhands.forEach(_remove2.default);\n\n                    (0, _insertCloned2.default)(decl.parent, decl, {\n                        prop: borderProperty(d),\n                        value: values[i]\n                    });\n\n                    values[i] = null;\n                }\n            });\n\n            const newValue = values.join(' ');\n\n            if (newValue) {\n                decl.value = newValue;\n            } else {\n                decl.remove();\n            }\n        });\n    });\n\n    // clean-up values\n    rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, decl => {\n        decl.value = (0, _minifyWsc2.default)(decl.value);\n    });\n\n    // border-spacing-hv -> border-spacing\n    rule.walkDecls(/^border-spacing$/i, decl => {\n        const value = _postcss.list.space(decl.value);\n\n        // merge vertical and horizontal dups\n        if (value.length > 1 && value[0] === value[1]) {\n            decl.value = value.slice(1).join(' ');\n        }\n    });\n\n    // clean-up rules\n    decls = (0, _getDecls2.default)(rule, allProperties);\n\n    while (decls.length) {\n        const lastNode = decls[decls.length - 1];\n        const lastPart = lastNode.prop.split('-').pop();\n\n        // remove properties of lower precedence\n        const lesser = decls.filter(node => !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && !(0, _isCustomProp2.default)(lastNode) && node !== lastNode && node.important === lastNode.important && getLevel(node.prop) > getLevel(lastNode.prop) && (!!~node.prop.toLowerCase().indexOf(lastNode.prop) || node.prop.toLowerCase().endsWith(lastPart)));\n\n        lesser.forEach(_remove2.default);\n        decls = decls.filter(node => !~lesser.indexOf(node));\n\n        // get duplicate properties\n        let duplicates = decls.filter(node => !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && node !== lastNode && node.important === lastNode.important && node.prop === lastNode.prop && !(!(0, _isCustomProp2.default)(node) && (0, _isCustomProp2.default)(lastNode)));\n\n        if (duplicates.length) {\n            if (/hsla\\(|rgba\\(/i.test(getColorValue(lastNode))) {\n                const preserve = duplicates.filter(node => !/hsla\\(|rgba\\(/i.test(getColorValue(node))).pop();\n\n                duplicates = duplicates.filter(node => node !== preserve);\n            }\n\n            duplicates.forEach(_remove2.default);\n        }\n\n        decls = decls.filter(node => node !== lastNode && !~duplicates.indexOf(node));\n    }\n}\n\nexports.default = {\n    explode,\n    merge\n};\nmodule.exports = exports['default'];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = insertCloned;\nfunction insertCloned(rule, decl, props) {\n    const newNode = Object.assign(decl.clone(), props);\n\n    rule.insertAfter(decl, newNode);\n\n    return newNode;\n};\nmodule.exports = exports[\"default\"];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _postcss = require('postcss');\n\nexports.default = v => {\n    const s = typeof v === 'string' ? _postcss.list.space(v) : v;\n    return [s[0], // top\n    s[1] || s[0], // right\n    s[2] || s[0], // bottom\n    s[3] || s[1] || s[0]];\n};\n\nmodule.exports = exports['default'];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = (rule, ...props) => {\n    return props.every(p => rule.some(({ prop }) => prop && ~prop.toLowerCase().indexOf(p)));\n};\n\nmodule.exports = exports[\"default\"];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = getDecls;\nfunction getDecls(rule, properties) {\n    return rule.nodes.filter(({ prop }) => prop && ~properties.indexOf(prop.toLowerCase()));\n}\nmodule.exports = exports[\"default\"];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = getRules;\n\nvar _getLastNode = require(\"./getLastNode\");\n\nvar _getLastNode2 = _interopRequireDefault(_getLastNode);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getRules(props, properties) {\n    return properties.map(property => {\n        return (0, _getLastNode2.default)(props, property);\n    }).filter(Boolean);\n}\nmodule.exports = exports[\"default\"];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = (rule, prop) => {\n    return rule.filter(n => n.prop && n.prop.toLowerCase() === prop).pop();\n};\n\nmodule.exports = exports[\"default\"];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = getValue;\nfunction getValue({ value }) {\n    return value;\n}\nmodule.exports = exports[\"default\"];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = mergeRules;\n\nvar _hasAllProps = require('./hasAllProps');\n\nvar _hasAllProps2 = _interopRequireDefault(_hasAllProps);\n\nvar _getDecls = require('./getDecls');\n\nvar _getDecls2 = _interopRequireDefault(_getDecls);\n\nvar _getRules = require('./getRules');\n\nvar _getRules2 = _interopRequireDefault(_getRules);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isConflictingProp(propA, propB) {\n    if (!propB.prop || propB.important !== propA.important) {\n        return;\n    }\n\n    const parts = propA.prop.split('-');\n\n    return parts.some(() => {\n        parts.pop();\n\n        return parts.join('-') === propB.prop;\n    });\n}\n\nfunction hasConflicts(match, nodes) {\n    const firstNode = Math.min.apply(null, match.map(n => nodes.indexOf(n)));\n    const lastNode = Math.max.apply(null, match.map(n => nodes.indexOf(n)));\n    const between = nodes.slice(firstNode + 1, lastNode);\n\n    return match.some(a => between.some(b => isConflictingProp(a, b)));\n}\n\nfunction mergeRules(rule, properties, callback) {\n    let decls = (0, _getDecls2.default)(rule, properties);\n\n    while (decls.length) {\n        const last = decls[decls.length - 1];\n        const props = decls.filter(node => node.important === last.important);\n        const rules = (0, _getRules2.default)(props, properties);\n\n        if ((0, _hasAllProps2.default)(rules, ...properties) && !hasConflicts(rules, rule.nodes)) {\n            if (callback(rules, last, props)) {\n                decls = decls.filter(node => !~rules.indexOf(node));\n            }\n        }\n\n        decls = decls.filter(node => node !== last);\n    }\n}\nmodule.exports = exports['default'];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _parseTrbl = require('./parseTrbl');\n\nvar _parseTrbl2 = _interopRequireDefault(_parseTrbl);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = v => {\n    const value = (0, _parseTrbl2.default)(v);\n\n    if (value[3] === value[1]) {\n        value.pop();\n\n        if (value[2] === value[0]) {\n            value.pop();\n\n            if (value[0] === value[1]) {\n                value.pop();\n            }\n        }\n    }\n\n    return value.join(' ');\n};\n\nmodule.exports = exports['default'];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _parseWsc = require('./parseWsc');\n\nvar _parseWsc2 = _interopRequireDefault(_parseWsc);\n\nvar _minifyTrbl = require('./minifyTrbl');\n\nvar _minifyTrbl2 = _interopRequireDefault(_minifyTrbl);\n\nvar _validateWsc = require('./validateWsc');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst defaults = ['medium', 'none', 'currentcolor'];\n\nexports.default = v => {\n    const values = (0, _parseWsc2.default)(v);\n\n    if (!(0, _validateWsc.isValidWsc)(values)) {\n        return (0, _minifyTrbl2.default)(v);\n    }\n\n    const value = [...values, ''].reduceRight((prev, cur, i, arr) => {\n        if (cur === undefined || cur.toLowerCase() === defaults[i] && (!i || (arr[i - 1] || '').toLowerCase() !== cur.toLowerCase())) {\n            return prev;\n        }\n\n        return cur + ' ' + prev;\n    }).trim();\n\n    return (0, _minifyTrbl2.default)(value || 'none');\n};\n\nmodule.exports = exports['default'];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = parseWsc;\n\nvar _postcss = require('postcss');\n\nvar _validateWsc = require('./validateWsc');\n\nconst none = /^\\s*(none|medium)(\\s+none(\\s+(none|currentcolor))?)?\\s*$/i;\n\nconst varRE = /(^.*var)(.*\\(.*--.*\\))(.*)/i;\nconst varPreserveCase = p => `${p[1].toLowerCase()}${p[2]}${p[3].toLowerCase()}`;\nconst toLower = v => {\n    const match = varRE.exec(v);\n    return match ? varPreserveCase(match) : v.toLowerCase();\n};\n\nfunction parseWsc(value) {\n    if (none.test(value)) {\n        return ['medium', 'none', 'currentcolor'];\n    }\n\n    let width, style, color;\n\n    const values = _postcss.list.space(value);\n\n    if (values.length > 1 && (0, _validateWsc.isStyle)(values[1]) && values[0].toLowerCase() === 'none') {\n        values.unshift();\n        width = '0';\n    }\n\n    const unknown = [];\n\n    values.forEach(v => {\n        if ((0, _validateWsc.isStyle)(v)) {\n            style = toLower(v);\n        } else if ((0, _validateWsc.isWidth)(v)) {\n            width = toLower(v);\n        } else if ((0, _validateWsc.isColor)(v)) {\n            color = toLower(v);\n        } else {\n            unknown.push(v);\n        }\n    });\n\n    if (unknown.length) {\n        if (!width && style && color) {\n            width = unknown.pop();\n        }\n\n        if (width && !style && color) {\n            style = unknown.pop();\n        }\n\n        if (width && style && !color) {\n            color = unknown.pop();\n        }\n    }\n\n    return [width, style, color];\n}\nmodule.exports = exports['default'];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.isStyle = isStyle;\nexports.isWidth = isWidth;\nexports.isColor = isColor;\nexports.isValidWsc = isValidWsc;\n\nvar _cssColorNames = require(\"css-color-names\");\n\nvar _cssColorNames2 = _interopRequireDefault(_cssColorNames);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst widths = [\"thin\", \"medium\", \"thick\"];\nconst styles = [\"none\", \"hidden\", \"dotted\", \"dashed\", \"solid\", \"double\", \"groove\", \"ridge\", \"inset\", \"outset\"];\nconst colors = Object.keys(_cssColorNames2.default);\n\nfunction isStyle(value) {\n    return value && !!~styles.indexOf(value.toLowerCase());\n}\n\nfunction isWidth(value) {\n    return value && !!~widths.indexOf(value.toLowerCase()) || /^(\\d+(\\.\\d+)?|\\.\\d+)(\\w+)?$/.test(value);\n}\n\nfunction isColor(value) {\n    if (!value) {\n        return false;\n    }\n\n    value = value.toLowerCase();\n\n    if (/rgba?\\(/.test(value)) {\n        return true;\n    }\n\n    if (/hsla?\\(/.test(value)) {\n        return true;\n    }\n\n    if (/#([0-9a-z]{6}|[0-9a-z]{3})/.test(value)) {\n        return true;\n    }\n\n    if (value === \"transparent\") {\n        return true;\n    }\n\n    if (value === \"currentcolor\") {\n        return true;\n    }\n\n    return !!~colors.indexOf(value);\n}\n\nfunction isValidWsc(wscs) {\n    const validWidth = isWidth(wscs[0]);\n    const validStyle = isStyle(wscs[1]);\n    const validColor = isColor(wscs[2]);\n\n    return validWidth && validStyle || validWidth && validColor || validStyle && validColor;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _isCustomProp = require('./isCustomProp');\n\nvar _isCustomProp2 = _interopRequireDefault(_isCustomProp);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst important = node => node.important;\nconst unimportant = node => !node.important;\n\nconst hasInherit = node => node.value.toLowerCase() === 'inherit';\nconst hasInitial = node => node.value.toLowerCase() === 'initial';\nconst hasUnset = node => node.value.toLowerCase() === 'unset';\n\nexports.default = (props, includeCustomProps = true) => {\n    if (props.some(hasInherit) && !props.every(hasInherit)) {\n        return false;\n    }\n\n    if (props.some(hasInitial) && !props.every(hasInitial)) {\n        return false;\n    }\n\n    if (props.some(hasUnset) && !props.every(hasUnset)) {\n        return false;\n    }\n\n    if (includeCustomProps && props.some(_isCustomProp2.default) && !props.every(_isCustomProp2.default)) {\n        return false;\n    }\n\n    return props.every(unimportant) || props.every(important);\n};\n\nmodule.exports = exports['default'];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = node => ~node.value.search(/var\\s*\\(\\s*--/i);\n\nmodule.exports = exports[\"default\"];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = remove;\nfunction remove(node) {\n    return node.remove();\n}\nmodule.exports = exports[\"default\"];","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = ['top', 'right', 'bottom', 'left'];\nmodule.exports = exports['default'];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _isCustomProp = require(\"./isCustomProp\");\n\nvar _isCustomProp2 = _interopRequireDefault(_isCustomProp);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst hasInherit = node => node.value.toLowerCase().includes(\"inherit\");\nconst hasInitial = node => node.value.toLowerCase().includes(\"initial\");\nconst hasUnset = node => node.value.toLowerCase().includes(\"unset\");\n\nexports.default = (prop, includeCustomProps = true) => {\n    if (includeCustomProps && (0, _isCustomProp2.default)(prop)) {\n        return false;\n    }\n\n    return !hasInherit(prop) && !hasInitial(prop) && !hasUnset(prop);\n};\n\nmodule.exports = exports[\"default\"];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _postcss = require('postcss');\n\nvar _postcssValueParser = require('postcss-value-parser');\n\nvar _stylehacks = require('stylehacks');\n\nvar _canMerge = require('../canMerge');\n\nvar _canMerge2 = _interopRequireDefault(_canMerge);\n\nvar _getDecls = require('../getDecls');\n\nvar _getDecls2 = _interopRequireDefault(_getDecls);\n\nvar _getValue = require('../getValue');\n\nvar _getValue2 = _interopRequireDefault(_getValue);\n\nvar _mergeRules = require('../mergeRules');\n\nvar _mergeRules2 = _interopRequireDefault(_mergeRules);\n\nvar _insertCloned = require('../insertCloned');\n\nvar _insertCloned2 = _interopRequireDefault(_insertCloned);\n\nvar _remove = require('../remove');\n\nvar _remove2 = _interopRequireDefault(_remove);\n\nvar _isCustomProp = require('../isCustomProp');\n\nvar _isCustomProp2 = _interopRequireDefault(_isCustomProp);\n\nvar _canExplode = require('../canExplode');\n\nvar _canExplode2 = _interopRequireDefault(_canExplode);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst properties = ['column-width', 'column-count'];\nconst auto = 'auto';\nconst inherit = 'inherit';\n\n/**\n * Normalize a columns shorthand definition. Both of the longhand\n * properties' initial values are 'auto', and as per the spec,\n * omitted values are set to their initial values. Thus, we can\n * remove any 'auto' definition when there are two values.\n *\n * Specification link: https://www.w3.org/TR/css3-multicol/\n */\n\nfunction normalize(values) {\n    if (values[0].toLowerCase() === auto) {\n        return values[1];\n    }\n\n    if (values[1].toLowerCase() === auto) {\n        return values[0];\n    }\n\n    if (values[0].toLowerCase() === inherit && values[1].toLowerCase() === inherit) {\n        return inherit;\n    }\n\n    return values.join(' ');\n}\n\nfunction explode(rule) {\n    rule.walkDecls(/^columns$/i, decl => {\n        if (!(0, _canExplode2.default)(decl)) {\n            return;\n        }\n\n        if ((0, _stylehacks.detect)(decl)) {\n            return;\n        }\n\n        let values = _postcss.list.space(decl.value);\n\n        if (values.length === 1) {\n            values.push(auto);\n        }\n\n        values.forEach((value, i) => {\n            let prop = properties[1];\n\n            if (value.toLowerCase() === auto) {\n                prop = properties[i];\n            } else if ((0, _postcssValueParser.unit)(value).unit) {\n                prop = properties[0];\n            }\n\n            (0, _insertCloned2.default)(decl.parent, decl, {\n                prop,\n                value\n            });\n        });\n\n        decl.remove();\n    });\n}\n\nfunction cleanup(rule) {\n    let decls = (0, _getDecls2.default)(rule, ['columns'].concat(properties));\n\n    while (decls.length) {\n        const lastNode = decls[decls.length - 1];\n\n        // remove properties of lower precedence\n        const lesser = decls.filter(node => !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && node !== lastNode && node.important === lastNode.important && lastNode.prop === 'columns' && node.prop !== lastNode.prop);\n\n        lesser.forEach(_remove2.default);\n        decls = decls.filter(node => !~lesser.indexOf(node));\n\n        // get duplicate properties\n        let duplicates = decls.filter(node => !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && node !== lastNode && node.important === lastNode.important && node.prop === lastNode.prop && !(!(0, _isCustomProp2.default)(node) && (0, _isCustomProp2.default)(lastNode)));\n\n        duplicates.forEach(_remove2.default);\n        decls = decls.filter(node => node !== lastNode && !~duplicates.indexOf(node));\n    }\n}\n\nfunction merge(rule) {\n    (0, _mergeRules2.default)(rule, properties, (rules, lastNode) => {\n        if ((0, _canMerge2.default)(rules) && !rules.some(_stylehacks.detect)) {\n            (0, _insertCloned2.default)(lastNode.parent, lastNode, {\n                prop: 'columns',\n                value: normalize(rules.map(_getValue2.default))\n            });\n\n            rules.forEach(_remove2.default);\n\n            return true;\n        }\n    });\n\n    cleanup(rule);\n}\n\nexports.default = {\n    explode,\n    merge\n};\nmodule.exports = exports['default'];","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _boxBase = require('./boxBase');\n\nvar _boxBase2 = _interopRequireDefault(_boxBase);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = (0, _boxBase2.default)('margin');\nmodule.exports = exports['default'];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _stylehacks = require('stylehacks');\n\nvar _canMerge = require('../canMerge');\n\nvar _canMerge2 = _interopRequireDefault(_canMerge);\n\nvar _getDecls = require('../getDecls');\n\nvar _getDecls2 = _interopRequireDefault(_getDecls);\n\nvar _minifyTrbl = require('../minifyTrbl');\n\nvar _minifyTrbl2 = _interopRequireDefault(_minifyTrbl);\n\nvar _parseTrbl = require('../parseTrbl');\n\nvar _parseTrbl2 = _interopRequireDefault(_parseTrbl);\n\nvar _insertCloned = require('../insertCloned');\n\nvar _insertCloned2 = _interopRequireDefault(_insertCloned);\n\nvar _mergeRules = require('../mergeRules');\n\nvar _mergeRules2 = _interopRequireDefault(_mergeRules);\n\nvar _mergeValues = require('../mergeValues');\n\nvar _mergeValues2 = _interopRequireDefault(_mergeValues);\n\nvar _remove = require('../remove');\n\nvar _remove2 = _interopRequireDefault(_remove);\n\nvar _trbl = require('../trbl');\n\nvar _trbl2 = _interopRequireDefault(_trbl);\n\nvar _isCustomProp = require('../isCustomProp');\n\nvar _isCustomProp2 = _interopRequireDefault(_isCustomProp);\n\nvar _canExplode = require('../canExplode');\n\nvar _canExplode2 = _interopRequireDefault(_canExplode);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = prop => {\n    const properties = _trbl2.default.map(direction => `${prop}-${direction}`);\n\n    const cleanup = rule => {\n        let decls = (0, _getDecls2.default)(rule, [prop].concat(properties));\n\n        while (decls.length) {\n            const lastNode = decls[decls.length - 1];\n\n            // remove properties of lower precedence\n            const lesser = decls.filter(node => !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && node !== lastNode && node.important === lastNode.important && lastNode.prop === prop && node.prop !== lastNode.prop);\n\n            lesser.forEach(_remove2.default);\n            decls = decls.filter(node => !~lesser.indexOf(node));\n\n            // get duplicate properties\n            let duplicates = decls.filter(node => !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && node !== lastNode && node.important === lastNode.important && node.prop === lastNode.prop && !(!(0, _isCustomProp2.default)(node) && (0, _isCustomProp2.default)(lastNode)));\n\n            duplicates.forEach(_remove2.default);\n            decls = decls.filter(node => node !== lastNode && !~duplicates.indexOf(node));\n        }\n    };\n\n    const processor = {\n        explode: rule => {\n            rule.walkDecls(new RegExp(\"^\" + prop + \"$\", \"i\"), decl => {\n                if (!(0, _canExplode2.default)(decl)) {\n                    return;\n                }\n\n                if ((0, _stylehacks.detect)(decl)) {\n                    return;\n                }\n\n                const values = (0, _parseTrbl2.default)(decl.value);\n\n                _trbl2.default.forEach((direction, index) => {\n                    (0, _insertCloned2.default)(decl.parent, decl, {\n                        prop: properties[index],\n                        value: values[index]\n                    });\n                });\n\n                decl.remove();\n            });\n        },\n        merge: rule => {\n            (0, _mergeRules2.default)(rule, properties, (rules, lastNode) => {\n                if ((0, _canMerge2.default)(rules) && !rules.some(_stylehacks.detect)) {\n                    (0, _insertCloned2.default)(lastNode.parent, lastNode, {\n                        prop,\n                        value: (0, _minifyTrbl2.default)((0, _mergeValues2.default)(...rules))\n                    });\n                    rules.forEach(_remove2.default);\n\n                    return true;\n                }\n            });\n\n            cleanup(rule);\n        }\n    };\n\n    return processor;\n};\n\nmodule.exports = exports['default'];","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getValue = require('./getValue');\n\nvar _getValue2 = _interopRequireDefault(_getValue);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = (...rules) => rules.map(_getValue2.default).join(' ');\n\nmodule.exports = exports['default'];","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _boxBase = require('./boxBase');\n\nvar _boxBase2 = _interopRequireDefault(_boxBase);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = (0, _boxBase2.default)('padding');\nmodule.exports = exports['default'];"]}