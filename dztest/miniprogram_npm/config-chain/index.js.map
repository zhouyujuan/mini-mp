{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var ProtoList = require('proto-list')\n  , path = require('path')\n  , fs = require('fs')\n  , ini = require('ini')\n  , EE = require('events').EventEmitter\n  , url = require('url')\n  , http = require('http')\n\nvar exports = module.exports = function () {\n  var args = [].slice.call(arguments)\n    , conf = new ConfigChain()\n\n  while(args.length) {\n    var a = args.shift()\n    if(a) conf.push\n          ( 'string' === typeof a\n            ? json(a)\n            : a )\n  }\n\n  return conf\n}\n\n//recursively find a file...\n\nvar find = exports.find = function () {\n  var rel = path.join.apply(null, [].slice.call(arguments))\n\n  function find(start, rel) {\n    var file = path.join(start, rel)\n    try {\n      fs.statSync(file)\n      return file\n    } catch (err) {\n      if(path.dirname(start) !== start) // root\n        return find(path.dirname(start), rel)\n    }\n  }\n  return find(__dirname, rel)\n}\n\nvar parse = exports.parse = function (content, file, type) {\n  content = '' + content\n  // if we don't know what it is, try json and fall back to ini\n  // if we know what it is, then it must be that.\n  if (!type) {\n    try { return JSON.parse(content) }\n    catch (er) { return ini.parse(content) }\n  } else if (type === 'json') {\n    if (this.emit) {\n      try { return JSON.parse(content) }\n      catch (er) { this.emit('error', er) }\n    } else {\n      return JSON.parse(content)\n    }\n  } else {\n    return ini.parse(content)\n  }\n}\n\nvar json = exports.json = function () {\n  var args = [].slice.call(arguments).filter(function (arg) { return arg != null })\n  var file = path.join.apply(null, args)\n  var content\n  try {\n    content = fs.readFileSync(file,'utf-8')\n  } catch (err) {\n    return\n  }\n  return parse(content, file, 'json')\n}\n\nvar env = exports.env = function (prefix, env) {\n  env = env || process.env\n  var obj = {}\n  var l = prefix.length\n  for(var k in env) {\n    if(k.indexOf(prefix) === 0)\n      obj[k.substring(l)] = env[k]\n  }\n\n  return obj\n}\n\nexports.ConfigChain = ConfigChain\nfunction ConfigChain () {\n  EE.apply(this)\n  ProtoList.apply(this, arguments)\n  this._awaiting = 0\n  this._saving = 0\n  this.sources = {}\n}\n\n// multi-inheritance-ish\nvar extras = {\n  constructor: { value: ConfigChain }\n}\nObject.keys(EE.prototype).forEach(function (k) {\n  extras[k] = Object.getOwnPropertyDescriptor(EE.prototype, k)\n})\nConfigChain.prototype = Object.create(ProtoList.prototype, extras)\n\nConfigChain.prototype.del = function (key, where) {\n  // if not specified where, then delete from the whole chain, scorched\n  // earth style\n  if (where) {\n    var target = this.sources[where]\n    target = target && target.data\n    if (!target) {\n      return this.emit('error', new Error('not found '+where))\n    }\n    delete target[key]\n  } else {\n    for (var i = 0, l = this.list.length; i < l; i ++) {\n      delete this.list[i][key]\n    }\n  }\n  return this\n}\n\nConfigChain.prototype.set = function (key, value, where) {\n  var target\n\n  if (where) {\n    target = this.sources[where]\n    target = target && target.data\n    if (!target) {\n      return this.emit('error', new Error('not found '+where))\n    }\n  } else {\n    target = this.list[0]\n    if (!target) {\n      return this.emit('error', new Error('cannot set, no confs!'))\n    }\n  }\n  target[key] = value\n  return this\n}\n\nConfigChain.prototype.get = function (key, where) {\n  if (where) {\n    where = this.sources[where]\n    if (where) where = where.data\n    if (where && Object.hasOwnProperty.call(where, key)) return where[key]\n    return undefined\n  }\n  return this.list[0][key]\n}\n\nConfigChain.prototype.save = function (where, type, cb) {\n  if (typeof type === 'function') cb = type, type = null\n  var target = this.sources[where]\n  if (!target || !(target.path || target.source) || !target.data) {\n    // TODO: maybe save() to a url target could be a PUT or something?\n    // would be easy to swap out with a reddis type thing, too\n    return this.emit('error', new Error('bad save target: '+where))\n  }\n\n  if (target.source) {\n    var pref = target.prefix || ''\n    Object.keys(target.data).forEach(function (k) {\n      target.source[pref + k] = target.data[k]\n    })\n    return this\n  }\n\n  var type = type || target.type\n  var data = target.data\n  if (target.type === 'json') {\n    data = JSON.stringify(data)\n  } else {\n    data = ini.stringify(data)\n  }\n\n  this._saving ++\n  fs.writeFile(target.path, data, 'utf8', function (er) {\n    this._saving --\n    if (er) {\n      if (cb) return cb(er)\n      else return this.emit('error', er)\n    }\n    if (this._saving === 0) {\n      if (cb) cb()\n      this.emit('save')\n    }\n  }.bind(this))\n  return this\n}\n\nConfigChain.prototype.addFile = function (file, type, name) {\n  name = name || file\n  var marker = {__source__:name}\n  this.sources[name] = { path: file, type: type }\n  this.push(marker)\n  this._await()\n  fs.readFile(file, 'utf8', function (er, data) {\n    if (er) this.emit('error', er)\n    this.addString(data, file, type, marker)\n  }.bind(this))\n  return this\n}\n\nConfigChain.prototype.addEnv = function (prefix, env, name) {\n  name = name || 'env'\n  var data = exports.env(prefix, env)\n  this.sources[name] = { data: data, source: env, prefix: prefix }\n  return this.add(data, name)\n}\n\nConfigChain.prototype.addUrl = function (req, type, name) {\n  this._await()\n  var href = url.format(req)\n  name = name || href\n  var marker = {__source__:name}\n  this.sources[name] = { href: href, type: type }\n  this.push(marker)\n  http.request(req, function (res) {\n    var c = []\n    var ct = res.headers['content-type']\n    if (!type) {\n      type = ct.indexOf('json') !== -1 ? 'json'\n           : ct.indexOf('ini') !== -1 ? 'ini'\n           : href.match(/\\.json$/) ? 'json'\n           : href.match(/\\.ini$/) ? 'ini'\n           : null\n      marker.type = type\n    }\n\n    res.on('data', c.push.bind(c))\n    .on('end', function () {\n      this.addString(Buffer.concat(c), href, type, marker)\n    }.bind(this))\n    .on('error', this.emit.bind(this, 'error'))\n\n  }.bind(this))\n  .on('error', this.emit.bind(this, 'error'))\n  .end()\n\n  return this\n}\n\nConfigChain.prototype.addString = function (data, file, type, marker) {\n  data = this.parse(data, file, type)\n  this.add(data, marker)\n  return this\n}\n\nConfigChain.prototype.add = function (data, marker) {\n  if (marker && typeof marker === 'object') {\n    var i = this.list.indexOf(marker)\n    if (i === -1) {\n      return this.emit('error', new Error('bad marker'))\n    }\n    this.splice(i, 1, data)\n    marker = marker.__source__\n    this.sources[marker] = this.sources[marker] || {}\n    this.sources[marker].data = data\n    // we were waiting for this.  maybe emit 'load'\n    this._resolve()\n  } else {\n    if (typeof marker === 'string') {\n      this.sources[marker] = this.sources[marker] || {}\n      this.sources[marker].data = data\n    }\n    // trigger the load event if nothing was already going to do so.\n    this._await()\n    this.push(data)\n    process.nextTick(this._resolve.bind(this))\n  }\n  return this\n}\n\nConfigChain.prototype.parse = exports.parse\n\nConfigChain.prototype._await = function () {\n  this._awaiting++\n}\n\nConfigChain.prototype._resolve = function () {\n  this._awaiting--\n  if (this._awaiting === 0) this.emit('load', this)\n}\n"]}