{"version":3,"sources":["index.js","constants.js","retrievers.js","validators.js","converters.js","flow.js","definitions/init.js","definitions/index.js","definitions/core.js","definitions/es2015.js","definitions/flow.js","definitions/jsx.js","definitions/misc.js","definitions/experimental.js","react.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA;AFOA,AGTA,AJYA,AENA,ACHA;AFOA,AGTA,AJYA,AENA,ACHA;AFOA,AGTA,AJYA,AENA,ACHA;AFOA,AGTA,ACHA,ALeA,AENA,ACHA;AFOA,AGTA,ACHA,ALeA,AENA,ACHA;AFOA,AGTA,ACHA,ALeA,AENA,ACHA;AFOA,AGTA,AENA,ADGA,ALeA,AENA,ACHA;AFOA,AGTA,AENA,ADGA,ALeA,AENA,ACHA;AFOA,AGTA,AENA,ADGA,ALeA,AENA,ACHA;AFOA,AGTA,AGTA,ADGA,ADGA,ALeA,AENA,ACHA;AFOA,AGTA,AGTA,ADGA,ADGA,ALeA,AENA,ACHA;AFOA,AGTA,AGTA,ADGA,ADGA,ALeA,AENA,ACHA;AFOA,AGTA,AIZA,ADGA,ADGA,ADGA,ALeA,AENA,ACHA;AFOA,AGTA,AIZA,ADGA,ADGA,ADGA,ALeA,AENA,ACHA;AFOA,AGTA,AIZA,ADGA,ADGA,ADGA,ALeA,AENA,ACHA;AFOA,AGTA,AIZA,ACHA,AFMA,ADGA,ADGA,ALeA,AENA,ACHA;AFOA,AGTA,AIZA,ACHA,AFMA,ADGA,ADGA,ALeA,AENA,ACHA;AFOA,AGTA,AIZA,ACHA,AFMA,ADGA,ADGA,ALeA,AENA,ACHA;AFOA,AGTA,AIZA,ACHA,ACHA,AHSA,ADGA,ADGA,ALeA,AENA,ACHA;AFOA,AGTA,AIZA,ACHA,ACHA,AHSA,ADGA,ADGA,ALeA,AENA,ACHA;AFOA,AGTA,AIZA,ACHA,ACHA,AHSA,ADGA,ADGA,ALeA,AENA,ACHA;AFOA,AGTA,AIZA,ACHA,ACHA,AHSA,AIZA,ANkBA,ALeA,AENA,ACHA;AFOA,AGTA,AIZA,ACHA,ACHA,AHSA,AIZA,ANkBA,ALeA,AENA,ACHA;AFOA,AGTA,AIZA,ACHA,ACHA,AHSA,AIZA,ANkBA,ALeA,AENA,ACHA;AFOA,AGTA,AIZA,ACHA,ACHA,AHSA,AIZA,ACHA,APqBA,ALeA,AENA,ACHA;AFOA,AGTA,AIZA,ACHA,ACHA,AHSA,AIZA,ACHA,APqBA,ALeA,AENA,ACHA;AFOA,AGTA,AIZA,ACHA,ACHA,AHSA,AIZA,ACHA,APqBA,ALeA,AENA,ACHA;AFOA,AGTA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,ALeA,AENA,ACHA;AFOA,AGTA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,ALeA,AENA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,ALeA,AENA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,Ac1CA,AZoCA,ACHA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,ANkBA,ALeA,AGTA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,AIZA,AHSA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,AIZA,AXiCA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AHSA,APqBA,AGTA;ACFA,AIZA,ACHA,ACHA,AV8BA,AGTA;ACFA,AIZA,ACHA,ACHA,AV8BA,AGTA;ACFA,AIZA,ACHA,ACHA,AV8BA,AGTA;ACFA,AIZA,ACHA,ACHA,AV8BA,AGTA;ACFA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,ACHA,AV8BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AIXA,AIZA,ACHA,AT2BA;AQvBA,ACHA,AT2BA;AQvBA,ACHA,AT2BA;AQvBA,ACHA,AT2BA;AQvBA,ACHA,AT2BA;AQvBA,ACHA,AT2BA;AQvBA,ACHA,AT2BA;AQvBA,ACHA,AT2BA;AQvBA,ACHA,AT2BA;AQvBA,ACHA,AT2BA;AQvBA,ACHA,AT2BA;AQvBA,ACHA,AT2BA;AQvBA,ACHA,AT2BA;AQvBA,ACHA,AT2BA;AQvBA,ACHA,AT2BA;AQvBA,ACHA,AT2BA;AQvBA,ACHA,AT2BA;AQvBA,ACHA,AT2BA;AQvBA,ACHA,AT2BA;AQvBA,ACHA,AT2BA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nexports.__esModule = true;\nexports.createTypeAnnotationBasedOnTypeof = exports.removeTypeDuplicates = exports.createUnionTypeAnnotation = exports.valueToNode = exports.toBlock = exports.toExpression = exports.toStatement = exports.toBindingIdentifierName = exports.toIdentifier = exports.toKeyAlias = exports.toSequenceExpression = exports.toComputedKey = exports.isNodesEquivalent = exports.isImmutable = exports.isScope = exports.isSpecifierDefault = exports.isVar = exports.isBlockScoped = exports.isLet = exports.isValidIdentifier = exports.isReferenced = exports.isBinding = exports.getOuterBindingIdentifiers = exports.getBindingIdentifiers = exports.TYPES = exports.react = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = exports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = undefined;\n\nvar _getOwnPropertySymbols = require(\"babel-runtime/core-js/object/get-own-property-symbols\");\n\nvar _getOwnPropertySymbols2 = _interopRequireDefault(_getOwnPropertySymbols);\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _keys = require(\"babel-runtime/core-js/object/keys\");\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _stringify = require(\"babel-runtime/core-js/json/stringify\");\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _constants = require(\"./constants\");\n\nObject.defineProperty(exports, \"STATEMENT_OR_BLOCK_KEYS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.STATEMENT_OR_BLOCK_KEYS;\n  }\n});\nObject.defineProperty(exports, \"FLATTENABLE_KEYS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.FLATTENABLE_KEYS;\n  }\n});\nObject.defineProperty(exports, \"FOR_INIT_KEYS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.FOR_INIT_KEYS;\n  }\n});\nObject.defineProperty(exports, \"COMMENT_KEYS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.COMMENT_KEYS;\n  }\n});\nObject.defineProperty(exports, \"LOGICAL_OPERATORS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.LOGICAL_OPERATORS;\n  }\n});\nObject.defineProperty(exports, \"UPDATE_OPERATORS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.UPDATE_OPERATORS;\n  }\n});\nObject.defineProperty(exports, \"BOOLEAN_NUMBER_BINARY_OPERATORS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.BOOLEAN_NUMBER_BINARY_OPERATORS;\n  }\n});\nObject.defineProperty(exports, \"EQUALITY_BINARY_OPERATORS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.EQUALITY_BINARY_OPERATORS;\n  }\n});\nObject.defineProperty(exports, \"COMPARISON_BINARY_OPERATORS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.COMPARISON_BINARY_OPERATORS;\n  }\n});\nObject.defineProperty(exports, \"BOOLEAN_BINARY_OPERATORS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.BOOLEAN_BINARY_OPERATORS;\n  }\n});\nObject.defineProperty(exports, \"NUMBER_BINARY_OPERATORS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.NUMBER_BINARY_OPERATORS;\n  }\n});\nObject.defineProperty(exports, \"BINARY_OPERATORS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.BINARY_OPERATORS;\n  }\n});\nObject.defineProperty(exports, \"BOOLEAN_UNARY_OPERATORS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.BOOLEAN_UNARY_OPERATORS;\n  }\n});\nObject.defineProperty(exports, \"NUMBER_UNARY_OPERATORS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.NUMBER_UNARY_OPERATORS;\n  }\n});\nObject.defineProperty(exports, \"STRING_UNARY_OPERATORS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.STRING_UNARY_OPERATORS;\n  }\n});\nObject.defineProperty(exports, \"UNARY_OPERATORS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.UNARY_OPERATORS;\n  }\n});\nObject.defineProperty(exports, \"INHERIT_KEYS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.INHERIT_KEYS;\n  }\n});\nObject.defineProperty(exports, \"BLOCK_SCOPED_SYMBOL\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.BLOCK_SCOPED_SYMBOL;\n  }\n});\nObject.defineProperty(exports, \"NOT_LOCAL_BINDING\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.NOT_LOCAL_BINDING;\n  }\n});\nexports.is = is;\nexports.isType = isType;\nexports.validate = validate;\nexports.shallowEqual = shallowEqual;\nexports.appendToMemberExpression = appendToMemberExpression;\nexports.prependToMemberExpression = prependToMemberExpression;\nexports.ensureBlock = ensureBlock;\nexports.clone = clone;\nexports.cloneWithoutLoc = cloneWithoutLoc;\nexports.cloneDeep = cloneDeep;\nexports.buildMatchMemberExpression = buildMatchMemberExpression;\nexports.removeComments = removeComments;\nexports.inheritsComments = inheritsComments;\nexports.inheritTrailingComments = inheritTrailingComments;\nexports.inheritLeadingComments = inheritLeadingComments;\nexports.inheritInnerComments = inheritInnerComments;\nexports.inherits = inherits;\nexports.assertNode = assertNode;\nexports.isNode = isNode;\nexports.traverseFast = traverseFast;\nexports.removeProperties = removeProperties;\nexports.removePropertiesDeep = removePropertiesDeep;\n\nvar _retrievers = require(\"./retrievers\");\n\nObject.defineProperty(exports, \"getBindingIdentifiers\", {\n  enumerable: true,\n  get: function get() {\n    return _retrievers.getBindingIdentifiers;\n  }\n});\nObject.defineProperty(exports, \"getOuterBindingIdentifiers\", {\n  enumerable: true,\n  get: function get() {\n    return _retrievers.getOuterBindingIdentifiers;\n  }\n});\n\nvar _validators = require(\"./validators\");\n\nObject.defineProperty(exports, \"isBinding\", {\n  enumerable: true,\n  get: function get() {\n    return _validators.isBinding;\n  }\n});\nObject.defineProperty(exports, \"isReferenced\", {\n  enumerable: true,\n  get: function get() {\n    return _validators.isReferenced;\n  }\n});\nObject.defineProperty(exports, \"isValidIdentifier\", {\n  enumerable: true,\n  get: function get() {\n    return _validators.isValidIdentifier;\n  }\n});\nObject.defineProperty(exports, \"isLet\", {\n  enumerable: true,\n  get: function get() {\n    return _validators.isLet;\n  }\n});\nObject.defineProperty(exports, \"isBlockScoped\", {\n  enumerable: true,\n  get: function get() {\n    return _validators.isBlockScoped;\n  }\n});\nObject.defineProperty(exports, \"isVar\", {\n  enumerable: true,\n  get: function get() {\n    return _validators.isVar;\n  }\n});\nObject.defineProperty(exports, \"isSpecifierDefault\", {\n  enumerable: true,\n  get: function get() {\n    return _validators.isSpecifierDefault;\n  }\n});\nObject.defineProperty(exports, \"isScope\", {\n  enumerable: true,\n  get: function get() {\n    return _validators.isScope;\n  }\n});\nObject.defineProperty(exports, \"isImmutable\", {\n  enumerable: true,\n  get: function get() {\n    return _validators.isImmutable;\n  }\n});\nObject.defineProperty(exports, \"isNodesEquivalent\", {\n  enumerable: true,\n  get: function get() {\n    return _validators.isNodesEquivalent;\n  }\n});\n\nvar _converters = require(\"./converters\");\n\nObject.defineProperty(exports, \"toComputedKey\", {\n  enumerable: true,\n  get: function get() {\n    return _converters.toComputedKey;\n  }\n});\nObject.defineProperty(exports, \"toSequenceExpression\", {\n  enumerable: true,\n  get: function get() {\n    return _converters.toSequenceExpression;\n  }\n});\nObject.defineProperty(exports, \"toKeyAlias\", {\n  enumerable: true,\n  get: function get() {\n    return _converters.toKeyAlias;\n  }\n});\nObject.defineProperty(exports, \"toIdentifier\", {\n  enumerable: true,\n  get: function get() {\n    return _converters.toIdentifier;\n  }\n});\nObject.defineProperty(exports, \"toBindingIdentifierName\", {\n  enumerable: true,\n  get: function get() {\n    return _converters.toBindingIdentifierName;\n  }\n});\nObject.defineProperty(exports, \"toStatement\", {\n  enumerable: true,\n  get: function get() {\n    return _converters.toStatement;\n  }\n});\nObject.defineProperty(exports, \"toExpression\", {\n  enumerable: true,\n  get: function get() {\n    return _converters.toExpression;\n  }\n});\nObject.defineProperty(exports, \"toBlock\", {\n  enumerable: true,\n  get: function get() {\n    return _converters.toBlock;\n  }\n});\nObject.defineProperty(exports, \"valueToNode\", {\n  enumerable: true,\n  get: function get() {\n    return _converters.valueToNode;\n  }\n});\n\nvar _flow = require(\"./flow\");\n\nObject.defineProperty(exports, \"createUnionTypeAnnotation\", {\n  enumerable: true,\n  get: function get() {\n    return _flow.createUnionTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"removeTypeDuplicates\", {\n  enumerable: true,\n  get: function get() {\n    return _flow.removeTypeDuplicates;\n  }\n});\nObject.defineProperty(exports, \"createTypeAnnotationBasedOnTypeof\", {\n  enumerable: true,\n  get: function get() {\n    return _flow.createTypeAnnotationBasedOnTypeof;\n  }\n});\n\nvar _toFastProperties = require(\"to-fast-properties\");\n\nvar _toFastProperties2 = _interopRequireDefault(_toFastProperties);\n\nvar _clone = require(\"lodash/clone\");\n\nvar _clone2 = _interopRequireDefault(_clone);\n\nvar _uniq = require(\"lodash/uniq\");\n\nvar _uniq2 = _interopRequireDefault(_uniq);\n\nrequire(\"./definitions/init\");\n\nvar _definitions = require(\"./definitions\");\n\nvar _react2 = require(\"./react\");\n\nvar _react = _interopRequireWildcard(_react2);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar t = exports;\n\nfunction registerType(type) {\n  var is = t[\"is\" + type];\n  if (!is) {\n    is = t[\"is\" + type] = function (node, opts) {\n      return t.is(type, node, opts);\n    };\n  }\n\n  t[\"assert\" + type] = function (node, opts) {\n    opts = opts || {};\n    if (!is(node, opts)) {\n      throw new Error(\"Expected type \" + (0, _stringify2.default)(type) + \" with option \" + (0, _stringify2.default)(opts));\n    }\n  };\n}\n\nexports.VISITOR_KEYS = _definitions.VISITOR_KEYS;\nexports.ALIAS_KEYS = _definitions.ALIAS_KEYS;\nexports.NODE_FIELDS = _definitions.NODE_FIELDS;\nexports.BUILDER_KEYS = _definitions.BUILDER_KEYS;\nexports.DEPRECATED_KEYS = _definitions.DEPRECATED_KEYS;\nexports.react = _react;\n\n\nfor (var type in t.VISITOR_KEYS) {\n  registerType(type);\n}\n\nt.FLIPPED_ALIAS_KEYS = {};\n\n(0, _keys2.default)(t.ALIAS_KEYS).forEach(function (type) {\n  t.ALIAS_KEYS[type].forEach(function (alias) {\n    var types = t.FLIPPED_ALIAS_KEYS[alias] = t.FLIPPED_ALIAS_KEYS[alias] || [];\n    types.push(type);\n  });\n});\n\n(0, _keys2.default)(t.FLIPPED_ALIAS_KEYS).forEach(function (type) {\n  t[type.toUpperCase() + \"_TYPES\"] = t.FLIPPED_ALIAS_KEYS[type];\n  registerType(type);\n});\n\nvar TYPES = exports.TYPES = (0, _keys2.default)(t.VISITOR_KEYS).concat((0, _keys2.default)(t.FLIPPED_ALIAS_KEYS)).concat((0, _keys2.default)(t.DEPRECATED_KEYS));\n\nfunction is(type, node, opts) {\n  if (!node) return false;\n\n  var matches = isType(node.type, type);\n  if (!matches) return false;\n\n  if (typeof opts === \"undefined\") {\n    return true;\n  } else {\n    return t.shallowEqual(node, opts);\n  }\n}\n\nfunction isType(nodeType, targetType) {\n  if (nodeType === targetType) return true;\n\n  if (t.ALIAS_KEYS[targetType]) return false;\n\n  var aliases = t.FLIPPED_ALIAS_KEYS[targetType];\n  if (aliases) {\n    if (aliases[0] === nodeType) return true;\n\n    for (var _iterator = aliases, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var alias = _ref;\n\n      if (nodeType === alias) return true;\n    }\n  }\n\n  return false;\n}\n\n(0, _keys2.default)(t.BUILDER_KEYS).forEach(function (type) {\n  var keys = t.BUILDER_KEYS[type];\n\n  function builder() {\n    if (arguments.length > keys.length) {\n      throw new Error(\"t.\" + type + \": Too many arguments passed. Received \" + arguments.length + \" but can receive \" + (\"no more than \" + keys.length));\n    }\n\n    var node = {};\n    node.type = type;\n\n    var i = 0;\n\n    for (var _iterator2 = keys, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var _key = _ref2;\n\n      var field = t.NODE_FIELDS[type][_key];\n\n      var arg = arguments[i++];\n      if (arg === undefined) arg = (0, _clone2.default)(field.default);\n\n      node[_key] = arg;\n    }\n\n    for (var key in node) {\n      validate(node, key, node[key]);\n    }\n\n    return node;\n  }\n\n  t[type] = builder;\n  t[type[0].toLowerCase() + type.slice(1)] = builder;\n});\n\nvar _loop = function _loop(_type) {\n  var newType = t.DEPRECATED_KEYS[_type];\n\n  function proxy(fn) {\n    return function () {\n      console.trace(\"The node type \" + _type + \" has been renamed to \" + newType);\n      return fn.apply(this, arguments);\n    };\n  }\n\n  t[_type] = t[_type[0].toLowerCase() + _type.slice(1)] = proxy(t[newType]);\n  t[\"is\" + _type] = proxy(t[\"is\" + newType]);\n  t[\"assert\" + _type] = proxy(t[\"assert\" + newType]);\n};\n\nfor (var _type in t.DEPRECATED_KEYS) {\n  _loop(_type);\n}\n\nfunction validate(node, key, val) {\n  if (!node) return;\n\n  var fields = t.NODE_FIELDS[node.type];\n  if (!fields) return;\n\n  var field = fields[key];\n  if (!field || !field.validate) return;\n  if (field.optional && val == null) return;\n\n  field.validate(node, key, val);\n}\n\nfunction shallowEqual(actual, expected) {\n  var keys = (0, _keys2.default)(expected);\n\n  for (var _iterator3 = keys, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {\n    var _ref3;\n\n    if (_isArray3) {\n      if (_i3 >= _iterator3.length) break;\n      _ref3 = _iterator3[_i3++];\n    } else {\n      _i3 = _iterator3.next();\n      if (_i3.done) break;\n      _ref3 = _i3.value;\n    }\n\n    var key = _ref3;\n\n    if (actual[key] !== expected[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction appendToMemberExpression(member, append, computed) {\n  member.object = t.memberExpression(member.object, member.property, member.computed);\n  member.property = append;\n  member.computed = !!computed;\n  return member;\n}\n\nfunction prependToMemberExpression(member, prepend) {\n  member.object = t.memberExpression(prepend, member.object);\n  return member;\n}\n\nfunction ensureBlock(node) {\n  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"body\";\n\n  return node[key] = t.toBlock(node[key], node);\n}\n\nfunction clone(node) {\n  if (!node) return node;\n  var newNode = {};\n  for (var key in node) {\n    if (key[0] === \"_\") continue;\n    newNode[key] = node[key];\n  }\n  return newNode;\n}\n\nfunction cloneWithoutLoc(node) {\n  var newNode = clone(node);\n  delete newNode.loc;\n  return newNode;\n}\n\nfunction cloneDeep(node) {\n  if (!node) return node;\n  var newNode = {};\n\n  for (var key in node) {\n    if (key[0] === \"_\") continue;\n\n    var val = node[key];\n\n    if (val) {\n      if (val.type) {\n        val = t.cloneDeep(val);\n      } else if (Array.isArray(val)) {\n        val = val.map(t.cloneDeep);\n      }\n    }\n\n    newNode[key] = val;\n  }\n\n  return newNode;\n}\n\nfunction buildMatchMemberExpression(match, allowPartial) {\n  var parts = match.split(\".\");\n\n  return function (member) {\n    if (!t.isMemberExpression(member)) return false;\n\n    var search = [member];\n    var i = 0;\n\n    while (search.length) {\n      var node = search.shift();\n\n      if (allowPartial && i === parts.length) {\n        return true;\n      }\n\n      if (t.isIdentifier(node)) {\n        if (parts[i] !== node.name) return false;\n      } else if (t.isStringLiteral(node)) {\n        if (parts[i] !== node.value) return false;\n      } else if (t.isMemberExpression(node)) {\n        if (node.computed && !t.isStringLiteral(node.property)) {\n          return false;\n        } else {\n          search.push(node.object);\n          search.push(node.property);\n          continue;\n        }\n      } else {\n        return false;\n      }\n\n      if (++i > parts.length) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n}\n\nfunction removeComments(node) {\n  for (var _iterator4 = t.COMMENT_KEYS, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {\n    var _ref4;\n\n    if (_isArray4) {\n      if (_i4 >= _iterator4.length) break;\n      _ref4 = _iterator4[_i4++];\n    } else {\n      _i4 = _iterator4.next();\n      if (_i4.done) break;\n      _ref4 = _i4.value;\n    }\n\n    var key = _ref4;\n\n    delete node[key];\n  }\n  return node;\n}\n\nfunction inheritsComments(child, parent) {\n  inheritTrailingComments(child, parent);\n  inheritLeadingComments(child, parent);\n  inheritInnerComments(child, parent);\n  return child;\n}\n\nfunction inheritTrailingComments(child, parent) {\n  _inheritComments(\"trailingComments\", child, parent);\n}\n\nfunction inheritLeadingComments(child, parent) {\n  _inheritComments(\"leadingComments\", child, parent);\n}\n\nfunction inheritInnerComments(child, parent) {\n  _inheritComments(\"innerComments\", child, parent);\n}\n\nfunction _inheritComments(key, child, parent) {\n  if (child && parent) {\n    child[key] = (0, _uniq2.default)([].concat(child[key], parent[key]).filter(Boolean));\n  }\n}\n\nfunction inherits(child, parent) {\n  if (!child || !parent) return child;\n\n  for (var _iterator5 = t.INHERIT_KEYS.optional, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5);;) {\n    var _ref5;\n\n    if (_isArray5) {\n      if (_i5 >= _iterator5.length) break;\n      _ref5 = _iterator5[_i5++];\n    } else {\n      _i5 = _iterator5.next();\n      if (_i5.done) break;\n      _ref5 = _i5.value;\n    }\n\n    var _key2 = _ref5;\n\n    if (child[_key2] == null) {\n      child[_key2] = parent[_key2];\n    }\n  }\n\n  for (var key in parent) {\n    if (key[0] === \"_\") child[key] = parent[key];\n  }\n\n  for (var _iterator6 = t.INHERIT_KEYS.force, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : (0, _getIterator3.default)(_iterator6);;) {\n    var _ref6;\n\n    if (_isArray6) {\n      if (_i6 >= _iterator6.length) break;\n      _ref6 = _iterator6[_i6++];\n    } else {\n      _i6 = _iterator6.next();\n      if (_i6.done) break;\n      _ref6 = _i6.value;\n    }\n\n    var _key3 = _ref6;\n\n    child[_key3] = parent[_key3];\n  }\n\n  t.inheritsComments(child, parent);\n\n  return child;\n}\n\nfunction assertNode(node) {\n  if (!isNode(node)) {\n    throw new TypeError(\"Not a valid node \" + (node && node.type));\n  }\n}\n\nfunction isNode(node) {\n  return !!(node && _definitions.VISITOR_KEYS[node.type]);\n}\n\n(0, _toFastProperties2.default)(t);\n(0, _toFastProperties2.default)(t.VISITOR_KEYS);\n\nfunction traverseFast(node, enter, opts) {\n  if (!node) return;\n\n  var keys = t.VISITOR_KEYS[node.type];\n  if (!keys) return;\n\n  opts = opts || {};\n  enter(node, opts);\n\n  for (var _iterator7 = keys, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : (0, _getIterator3.default)(_iterator7);;) {\n    var _ref7;\n\n    if (_isArray7) {\n      if (_i7 >= _iterator7.length) break;\n      _ref7 = _iterator7[_i7++];\n    } else {\n      _i7 = _iterator7.next();\n      if (_i7.done) break;\n      _ref7 = _i7.value;\n    }\n\n    var key = _ref7;\n\n    var subNode = node[key];\n\n    if (Array.isArray(subNode)) {\n      for (var _iterator8 = subNode, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : (0, _getIterator3.default)(_iterator8);;) {\n        var _ref8;\n\n        if (_isArray8) {\n          if (_i8 >= _iterator8.length) break;\n          _ref8 = _iterator8[_i8++];\n        } else {\n          _i8 = _iterator8.next();\n          if (_i8.done) break;\n          _ref8 = _i8.value;\n        }\n\n        var _node = _ref8;\n\n        traverseFast(_node, enter, opts);\n      }\n    } else {\n      traverseFast(subNode, enter, opts);\n    }\n  }\n}\n\nvar CLEAR_KEYS = [\"tokens\", \"start\", \"end\", \"loc\", \"raw\", \"rawValue\"];\n\nvar CLEAR_KEYS_PLUS_COMMENTS = t.COMMENT_KEYS.concat([\"comments\"]).concat(CLEAR_KEYS);\n\nfunction removeProperties(node, opts) {\n  opts = opts || {};\n  var map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;\n  for (var _iterator9 = map, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : (0, _getIterator3.default)(_iterator9);;) {\n    var _ref9;\n\n    if (_isArray9) {\n      if (_i9 >= _iterator9.length) break;\n      _ref9 = _iterator9[_i9++];\n    } else {\n      _i9 = _iterator9.next();\n      if (_i9.done) break;\n      _ref9 = _i9.value;\n    }\n\n    var _key4 = _ref9;\n\n    if (node[_key4] != null) node[_key4] = undefined;\n  }\n\n  for (var key in node) {\n    if (key[0] === \"_\" && node[key] != null) node[key] = undefined;\n  }\n\n  var syms = (0, _getOwnPropertySymbols2.default)(node);\n  for (var _iterator10 = syms, _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : (0, _getIterator3.default)(_iterator10);;) {\n    var _ref10;\n\n    if (_isArray10) {\n      if (_i10 >= _iterator10.length) break;\n      _ref10 = _iterator10[_i10++];\n    } else {\n      _i10 = _iterator10.next();\n      if (_i10.done) break;\n      _ref10 = _i10.value;\n    }\n\n    var sym = _ref10;\n\n    node[sym] = null;\n  }\n}\n\nfunction removePropertiesDeep(tree, opts) {\n  traverseFast(tree, removeProperties, opts);\n  return tree;\n}","\n\nexports.__esModule = true;\nexports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = undefined;\n\nvar _for = require(\"babel-runtime/core-js/symbol/for\");\n\nvar _for2 = _interopRequireDefault(_for);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar STATEMENT_OR_BLOCK_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = [\"consequent\", \"body\", \"alternate\"];\nvar FLATTENABLE_KEYS = exports.FLATTENABLE_KEYS = [\"body\", \"expressions\"];\nvar FOR_INIT_KEYS = exports.FOR_INIT_KEYS = [\"left\", \"init\"];\nvar COMMENT_KEYS = exports.COMMENT_KEYS = [\"leadingComments\", \"trailingComments\", \"innerComments\"];\n\nvar LOGICAL_OPERATORS = exports.LOGICAL_OPERATORS = [\"||\", \"&&\"];\nvar UPDATE_OPERATORS = exports.UPDATE_OPERATORS = [\"++\", \"--\"];\n\nvar BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = [\">\", \"<\", \">=\", \"<=\"];\nvar EQUALITY_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = [\"==\", \"===\", \"!=\", \"!==\"];\nvar COMPARISON_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = [].concat(EQUALITY_BINARY_OPERATORS, [\"in\", \"instanceof\"]);\nvar BOOLEAN_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = [].concat(COMPARISON_BINARY_OPERATORS, BOOLEAN_NUMBER_BINARY_OPERATORS);\nvar NUMBER_BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = [\"-\", \"/\", \"%\", \"*\", \"**\", \"&\", \"|\", \">>\", \">>>\", \"<<\", \"^\"];\nvar BINARY_OPERATORS = exports.BINARY_OPERATORS = [\"+\"].concat(NUMBER_BINARY_OPERATORS, BOOLEAN_BINARY_OPERATORS);\n\nvar BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = [\"delete\", \"!\"];\nvar NUMBER_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = [\"+\", \"-\", \"++\", \"--\", \"~\"];\nvar STRING_UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = [\"typeof\"];\nvar UNARY_OPERATORS = exports.UNARY_OPERATORS = [\"void\"].concat(BOOLEAN_UNARY_OPERATORS, NUMBER_UNARY_OPERATORS, STRING_UNARY_OPERATORS);\n\nvar INHERIT_KEYS = exports.INHERIT_KEYS = {\n  optional: [\"typeAnnotation\", \"typeParameters\", \"returnType\"],\n  force: [\"start\", \"loc\", \"end\"]\n};\n\nvar BLOCK_SCOPED_SYMBOL = exports.BLOCK_SCOPED_SYMBOL = (0, _for2.default)(\"var used to be block scoped\");\nvar NOT_LOCAL_BINDING = exports.NOT_LOCAL_BINDING = (0, _for2.default)(\"should not be considered a local binding\");","\n\nexports.__esModule = true;\n\nvar _create = require(\"babel-runtime/core-js/object/create\");\n\nvar _create2 = _interopRequireDefault(_create);\n\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\n\nvar _index = require(\"./index\");\n\nvar t = _interopRequireWildcard(_index);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getBindingIdentifiers(node, duplicates, outerOnly) {\n  var search = [].concat(node);\n  var ids = (0, _create2.default)(null);\n\n  while (search.length) {\n    var id = search.shift();\n    if (!id) continue;\n\n    var keys = t.getBindingIdentifiers.keys[id.type];\n\n    if (t.isIdentifier(id)) {\n      if (duplicates) {\n        var _ids = ids[id.name] = ids[id.name] || [];\n        _ids.push(id);\n      } else {\n        ids[id.name] = id;\n      }\n      continue;\n    }\n\n    if (t.isExportDeclaration(id)) {\n      if (t.isDeclaration(id.declaration)) {\n        search.push(id.declaration);\n      }\n      continue;\n    }\n\n    if (outerOnly) {\n      if (t.isFunctionDeclaration(id)) {\n        search.push(id.id);\n        continue;\n      }\n\n      if (t.isFunctionExpression(id)) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        if (id[key]) {\n          search = search.concat(id[key]);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\ngetBindingIdentifiers.keys = {\n  DeclareClass: [\"id\"],\n  DeclareFunction: [\"id\"],\n  DeclareModule: [\"id\"],\n  DeclareVariable: [\"id\"],\n  InterfaceDeclaration: [\"id\"],\n  TypeAlias: [\"id\"],\n  OpaqueType: [\"id\"],\n\n  CatchClause: [\"param\"],\n  LabeledStatement: [\"label\"],\n  UnaryExpression: [\"argument\"],\n  AssignmentExpression: [\"left\"],\n\n  ImportSpecifier: [\"local\"],\n  ImportNamespaceSpecifier: [\"local\"],\n  ImportDefaultSpecifier: [\"local\"],\n  ImportDeclaration: [\"specifiers\"],\n\n  ExportSpecifier: [\"exported\"],\n  ExportNamespaceSpecifier: [\"exported\"],\n  ExportDefaultSpecifier: [\"exported\"],\n\n  FunctionDeclaration: [\"id\", \"params\"],\n  FunctionExpression: [\"id\", \"params\"],\n\n  ClassDeclaration: [\"id\"],\n  ClassExpression: [\"id\"],\n\n  RestElement: [\"argument\"],\n  UpdateExpression: [\"argument\"],\n\n  RestProperty: [\"argument\"],\n  ObjectProperty: [\"value\"],\n\n  AssignmentPattern: [\"left\"],\n  ArrayPattern: [\"elements\"],\n  ObjectPattern: [\"properties\"],\n\n  VariableDeclaration: [\"declarations\"],\n  VariableDeclarator: [\"id\"]\n};\n\nfunction getOuterBindingIdentifiers(node, duplicates) {\n  return getBindingIdentifiers(node, duplicates, true);\n}","\n\nexports.__esModule = true;\n\nvar _keys = require(\"babel-runtime/core-js/object/keys\");\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nexports.isBinding = isBinding;\nexports.isReferenced = isReferenced;\nexports.isValidIdentifier = isValidIdentifier;\nexports.isLet = isLet;\nexports.isBlockScoped = isBlockScoped;\nexports.isVar = isVar;\nexports.isSpecifierDefault = isSpecifierDefault;\nexports.isScope = isScope;\nexports.isImmutable = isImmutable;\nexports.isNodesEquivalent = isNodesEquivalent;\n\nvar _retrievers = require(\"./retrievers\");\n\nvar _esutils = require(\"esutils\");\n\nvar _esutils2 = _interopRequireDefault(_esutils);\n\nvar _index = require(\"./index\");\n\nvar t = _interopRequireWildcard(_index);\n\nvar _constants = require(\"./constants\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isBinding(node, parent) {\n  var keys = _retrievers.getBindingIdentifiers.keys[parent.type];\n  if (keys) {\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var val = parent[key];\n      if (Array.isArray(val)) {\n        if (val.indexOf(node) >= 0) return true;\n      } else {\n        if (val === node) return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction isReferenced(node, parent) {\n  switch (parent.type) {\n    case \"BindExpression\":\n      return parent.object === node || parent.callee === node;\n\n    case \"MemberExpression\":\n    case \"JSXMemberExpression\":\n      if (parent.property === node && parent.computed) {\n        return true;\n      } else if (parent.object === node) {\n        return true;\n      } else {\n        return false;\n      }\n\n    case \"MetaProperty\":\n      return false;\n\n    case \"ObjectProperty\":\n      if (parent.key === node) {\n        return parent.computed;\n      }\n\n    case \"VariableDeclarator\":\n      return parent.id !== node;\n\n    case \"ArrowFunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n      for (var _iterator = parent.params, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var param = _ref;\n\n        if (param === node) return false;\n      }\n\n      return parent.id !== node;\n\n    case \"ExportSpecifier\":\n      if (parent.source) {\n        return false;\n      } else {\n        return parent.local === node;\n      }\n\n    case \"ExportNamespaceSpecifier\":\n    case \"ExportDefaultSpecifier\":\n      return false;\n\n    case \"JSXAttribute\":\n      return parent.name !== node;\n\n    case \"ClassProperty\":\n      if (parent.key === node) {\n        return parent.computed;\n      } else {\n        return parent.value === node;\n      }\n\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"ImportSpecifier\":\n      return false;\n\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n      return parent.id !== node;\n\n    case \"ClassMethod\":\n    case \"ObjectMethod\":\n      return parent.key === node && parent.computed;\n\n    case \"LabeledStatement\":\n      return false;\n\n    case \"CatchClause\":\n      return parent.param !== node;\n\n    case \"RestElement\":\n      return false;\n\n    case \"AssignmentExpression\":\n      return parent.right === node;\n\n    case \"AssignmentPattern\":\n      return parent.right === node;\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      return false;\n  }\n\n  return true;\n}\n\nfunction isValidIdentifier(name) {\n  if (typeof name !== \"string\" || _esutils2.default.keyword.isReservedWordES6(name, true)) {\n    return false;\n  } else if (name === \"await\") {\n    return false;\n  } else {\n    return _esutils2.default.keyword.isIdentifierNameES6(name);\n  }\n}\n\nfunction isLet(node) {\n  return t.isVariableDeclaration(node) && (node.kind !== \"var\" || node[_constants.BLOCK_SCOPED_SYMBOL]);\n}\n\nfunction isBlockScoped(node) {\n  return t.isFunctionDeclaration(node) || t.isClassDeclaration(node) || t.isLet(node);\n}\n\nfunction isVar(node) {\n  return t.isVariableDeclaration(node, { kind: \"var\" }) && !node[_constants.BLOCK_SCOPED_SYMBOL];\n}\n\nfunction isSpecifierDefault(specifier) {\n  return t.isImportDefaultSpecifier(specifier) || t.isIdentifier(specifier.imported || specifier.exported, { name: \"default\" });\n}\n\nfunction isScope(node, parent) {\n  if (t.isBlockStatement(node) && t.isFunction(parent, { body: node })) {\n    return false;\n  }\n\n  return t.isScopable(node);\n}\n\nfunction isImmutable(node) {\n  if (t.isType(node.type, \"Immutable\")) return true;\n\n  if (t.isIdentifier(node)) {\n    if (node.name === \"undefined\") {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nfunction isNodesEquivalent(a, b) {\n  if ((typeof a === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(a)) !== \"object\" || (typeof a === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(a)) !== \"object\" || a == null || b == null) {\n    return a === b;\n  }\n\n  if (a.type !== b.type) {\n    return false;\n  }\n\n  var fields = (0, _keys2.default)(t.NODE_FIELDS[a.type] || a.type);\n\n  for (var _iterator2 = fields, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {\n    var _ref2;\n\n    if (_isArray2) {\n      if (_i2 >= _iterator2.length) break;\n      _ref2 = _iterator2[_i2++];\n    } else {\n      _i2 = _iterator2.next();\n      if (_i2.done) break;\n      _ref2 = _i2.value;\n    }\n\n    var field = _ref2;\n\n    if ((0, _typeof3.default)(a[field]) !== (0, _typeof3.default)(b[field])) {\n      return false;\n    }\n\n    if (Array.isArray(a[field])) {\n      if (!Array.isArray(b[field])) {\n        return false;\n      }\n      if (a[field].length !== b[field].length) {\n        return false;\n      }\n\n      for (var i = 0; i < a[field].length; i++) {\n        if (!isNodesEquivalent(a[field][i], b[field][i])) {\n          return false;\n        }\n      }\n      continue;\n    }\n\n    if (!isNodesEquivalent(a[field], b[field])) {\n      return false;\n    }\n  }\n\n  return true;\n}","\n\nexports.__esModule = true;\n\nvar _maxSafeInteger = require(\"babel-runtime/core-js/number/max-safe-integer\");\n\nvar _maxSafeInteger2 = _interopRequireDefault(_maxSafeInteger);\n\nvar _stringify = require(\"babel-runtime/core-js/json/stringify\");\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nexports.toComputedKey = toComputedKey;\nexports.toSequenceExpression = toSequenceExpression;\nexports.toKeyAlias = toKeyAlias;\nexports.toIdentifier = toIdentifier;\nexports.toBindingIdentifierName = toBindingIdentifierName;\nexports.toStatement = toStatement;\nexports.toExpression = toExpression;\nexports.toBlock = toBlock;\nexports.valueToNode = valueToNode;\n\nvar _isPlainObject = require(\"lodash/isPlainObject\");\n\nvar _isPlainObject2 = _interopRequireDefault(_isPlainObject);\n\nvar _isRegExp = require(\"lodash/isRegExp\");\n\nvar _isRegExp2 = _interopRequireDefault(_isRegExp);\n\nvar _index = require(\"./index\");\n\nvar t = _interopRequireWildcard(_index);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction toComputedKey(node) {\n  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node.key || node.property;\n\n  if (!node.computed) {\n    if (t.isIdentifier(key)) key = t.stringLiteral(key.name);\n  }\n  return key;\n}\n\nfunction gatherSequenceExpressions(nodes, scope, declars) {\n  var exprs = [];\n  var ensureLastUndefined = true;\n\n  for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var node = _ref;\n\n    ensureLastUndefined = false;\n\n    if (t.isExpression(node)) {\n      exprs.push(node);\n    } else if (t.isExpressionStatement(node)) {\n      exprs.push(node.expression);\n    } else if (t.isVariableDeclaration(node)) {\n      if (node.kind !== \"var\") return;\n\n      for (var _iterator2 = node.declarations, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {\n        var _ref2;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n\n        var declar = _ref2;\n\n        var bindings = t.getBindingIdentifiers(declar);\n        for (var key in bindings) {\n          declars.push({\n            kind: node.kind,\n            id: bindings[key]\n          });\n        }\n\n        if (declar.init) {\n          exprs.push(t.assignmentExpression(\"=\", declar.id, declar.init));\n        }\n      }\n\n      ensureLastUndefined = true;\n    } else if (t.isIfStatement(node)) {\n      var consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();\n      var alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();\n      if (!consequent || !alternate) return;\n\n      exprs.push(t.conditionalExpression(node.test, consequent, alternate));\n    } else if (t.isBlockStatement(node)) {\n      var body = gatherSequenceExpressions(node.body, scope, declars);\n      if (!body) return;\n\n      exprs.push(body);\n    } else if (t.isEmptyStatement(node)) {\n      ensureLastUndefined = true;\n    } else {\n      return;\n    }\n  }\n\n  if (ensureLastUndefined) {\n    exprs.push(scope.buildUndefinedNode());\n  }\n\n  if (exprs.length === 1) {\n    return exprs[0];\n  } else {\n    return t.sequenceExpression(exprs);\n  }\n}\n\nfunction toSequenceExpression(nodes, scope) {\n  if (!nodes || !nodes.length) return;\n\n  var declars = [];\n  var result = gatherSequenceExpressions(nodes, scope, declars);\n  if (!result) return;\n\n  for (var _iterator3 = declars, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {\n    var _ref3;\n\n    if (_isArray3) {\n      if (_i3 >= _iterator3.length) break;\n      _ref3 = _iterator3[_i3++];\n    } else {\n      _i3 = _iterator3.next();\n      if (_i3.done) break;\n      _ref3 = _i3.value;\n    }\n\n    var declar = _ref3;\n\n    scope.push(declar);\n  }\n\n  return result;\n}\n\nfunction toKeyAlias(node) {\n  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node.key;\n\n  var alias = void 0;\n\n  if (node.kind === \"method\") {\n    return toKeyAlias.increment() + \"\";\n  } else if (t.isIdentifier(key)) {\n    alias = key.name;\n  } else if (t.isStringLiteral(key)) {\n    alias = (0, _stringify2.default)(key.value);\n  } else {\n    alias = (0, _stringify2.default)(t.removePropertiesDeep(t.cloneDeep(key)));\n  }\n\n  if (node.computed) {\n    alias = \"[\" + alias + \"]\";\n  }\n\n  if (node.static) {\n    alias = \"static:\" + alias;\n  }\n\n  return alias;\n}\n\ntoKeyAlias.uid = 0;\n\ntoKeyAlias.increment = function () {\n  if (toKeyAlias.uid >= _maxSafeInteger2.default) {\n    return toKeyAlias.uid = 0;\n  } else {\n    return toKeyAlias.uid++;\n  }\n};\n\nfunction toIdentifier(name) {\n  name = name + \"\";\n\n  name = name.replace(/[^a-zA-Z0-9$_]/g, \"-\");\n\n  name = name.replace(/^[-0-9]+/, \"\");\n\n  name = name.replace(/[-\\s]+(.)?/g, function (match, c) {\n    return c ? c.toUpperCase() : \"\";\n  });\n\n  if (!t.isValidIdentifier(name)) {\n    name = \"_\" + name;\n  }\n\n  return name || \"_\";\n}\n\nfunction toBindingIdentifierName(name) {\n  name = toIdentifier(name);\n  if (name === \"eval\" || name === \"arguments\") name = \"_\" + name;\n  return name;\n}\n\nfunction toStatement(node, ignore) {\n  if (t.isStatement(node)) {\n    return node;\n  }\n\n  var mustHaveId = false;\n  var newType = void 0;\n\n  if (t.isClass(node)) {\n    mustHaveId = true;\n    newType = \"ClassDeclaration\";\n  } else if (t.isFunction(node)) {\n    mustHaveId = true;\n    newType = \"FunctionDeclaration\";\n  } else if (t.isAssignmentExpression(node)) {\n    return t.expressionStatement(node);\n  }\n\n  if (mustHaveId && !node.id) {\n    newType = false;\n  }\n\n  if (!newType) {\n    if (ignore) {\n      return false;\n    } else {\n      throw new Error(\"cannot turn \" + node.type + \" to a statement\");\n    }\n  }\n\n  node.type = newType;\n\n  return node;\n}\n\nfunction toExpression(node) {\n  if (t.isExpressionStatement(node)) {\n    node = node.expression;\n  }\n\n  if (t.isExpression(node)) {\n    return node;\n  }\n\n  if (t.isClass(node)) {\n    node.type = \"ClassExpression\";\n  } else if (t.isFunction(node)) {\n    node.type = \"FunctionExpression\";\n  }\n\n  if (!t.isExpression(node)) {\n    throw new Error(\"cannot turn \" + node.type + \" to an expression\");\n  }\n\n  return node;\n}\n\nfunction toBlock(node, parent) {\n  if (t.isBlockStatement(node)) {\n    return node;\n  }\n\n  if (t.isEmptyStatement(node)) {\n    node = [];\n  }\n\n  if (!Array.isArray(node)) {\n    if (!t.isStatement(node)) {\n      if (t.isFunction(parent)) {\n        node = t.returnStatement(node);\n      } else {\n        node = t.expressionStatement(node);\n      }\n    }\n\n    node = [node];\n  }\n\n  return t.blockStatement(node);\n}\n\nfunction valueToNode(value) {\n  if (value === undefined) {\n    return t.identifier(\"undefined\");\n  }\n\n  if (value === true || value === false) {\n    return t.booleanLiteral(value);\n  }\n\n  if (value === null) {\n    return t.nullLiteral();\n  }\n\n  if (typeof value === \"string\") {\n    return t.stringLiteral(value);\n  }\n\n  if (typeof value === \"number\") {\n    return t.numericLiteral(value);\n  }\n\n  if ((0, _isRegExp2.default)(value)) {\n    var pattern = value.source;\n    var flags = value.toString().match(/\\/([a-z]+|)$/)[1];\n    return t.regExpLiteral(pattern, flags);\n  }\n\n  if (Array.isArray(value)) {\n    return t.arrayExpression(value.map(t.valueToNode));\n  }\n\n  if ((0, _isPlainObject2.default)(value)) {\n    var props = [];\n    for (var key in value) {\n      var nodeKey = void 0;\n      if (t.isValidIdentifier(key)) {\n        nodeKey = t.identifier(key);\n      } else {\n        nodeKey = t.stringLiteral(key);\n      }\n      props.push(t.objectProperty(nodeKey, t.valueToNode(value[key])));\n    }\n    return t.objectExpression(props);\n  }\n\n  throw new Error(\"don't know how to turn this value into a node\");\n}","\n\nexports.__esModule = true;\nexports.createUnionTypeAnnotation = createUnionTypeAnnotation;\nexports.removeTypeDuplicates = removeTypeDuplicates;\nexports.createTypeAnnotationBasedOnTypeof = createTypeAnnotationBasedOnTypeof;\n\nvar _index = require(\"./index\");\n\nvar t = _interopRequireWildcard(_index);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction createUnionTypeAnnotation(types) {\n  var flattened = removeTypeDuplicates(types);\n\n  if (flattened.length === 1) {\n    return flattened[0];\n  } else {\n    return t.unionTypeAnnotation(flattened);\n  }\n}\n\nfunction removeTypeDuplicates(nodes) {\n  var generics = {};\n  var bases = {};\n\n  var typeGroups = [];\n\n  var types = [];\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    if (!node) continue;\n\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n\n    if (t.isAnyTypeAnnotation(node)) {\n      return [node];\n    }\n\n    if (t.isFlowBaseAnnotation(node)) {\n      bases[node.type] = node;\n      continue;\n    }\n\n    if (t.isUnionTypeAnnotation(node)) {\n      if (typeGroups.indexOf(node.types) < 0) {\n        nodes = nodes.concat(node.types);\n        typeGroups.push(node.types);\n      }\n      continue;\n    }\n\n    if (t.isGenericTypeAnnotation(node)) {\n      var name = node.id.name;\n\n      if (generics[name]) {\n        var existing = generics[name];\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics[name] = node;\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  for (var type in bases) {\n    types.push(bases[type]);\n  }\n\n  for (var _name in generics) {\n    types.push(generics[_name]);\n  }\n\n  return types;\n}\n\nfunction createTypeAnnotationBasedOnTypeof(type) {\n  if (type === \"string\") {\n    return t.stringTypeAnnotation();\n  } else if (type === \"number\") {\n    return t.numberTypeAnnotation();\n  } else if (type === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (type === \"boolean\") {\n    return t.booleanTypeAnnotation();\n  } else if (type === \"function\") {\n    return t.genericTypeAnnotation(t.identifier(\"Function\"));\n  } else if (type === \"object\") {\n    return t.genericTypeAnnotation(t.identifier(\"Object\"));\n  } else if (type === \"symbol\") {\n    return t.genericTypeAnnotation(t.identifier(\"Symbol\"));\n  } else {\n    throw new Error(\"Invalid typeof value\");\n  }\n}","\n\nrequire(\"./index\");\n\nrequire(\"./core\");\n\nrequire(\"./es2015\");\n\nrequire(\"./flow\");\n\nrequire(\"./jsx\");\n\nrequire(\"./misc\");\n\nrequire(\"./experimental\");","\n\nexports.__esModule = true;\nexports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = undefined;\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _stringify = require(\"babel-runtime/core-js/json/stringify\");\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nexports.assertEach = assertEach;\nexports.assertOneOf = assertOneOf;\nexports.assertNodeType = assertNodeType;\nexports.assertNodeOrValueType = assertNodeOrValueType;\nexports.assertValueType = assertValueType;\nexports.chain = chain;\nexports.default = defineType;\n\nvar _index = require(\"../index\");\n\nvar t = _interopRequireWildcard(_index);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar VISITOR_KEYS = exports.VISITOR_KEYS = {};\nvar ALIAS_KEYS = exports.ALIAS_KEYS = {};\nvar NODE_FIELDS = exports.NODE_FIELDS = {};\nvar BUILDER_KEYS = exports.BUILDER_KEYS = {};\nvar DEPRECATED_KEYS = exports.DEPRECATED_KEYS = {};\n\nfunction getType(val) {\n  if (Array.isArray(val)) {\n    return \"array\";\n  } else if (val === null) {\n    return \"null\";\n  } else if (val === undefined) {\n    return \"undefined\";\n  } else {\n    return typeof val === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(val);\n  }\n}\n\nfunction assertEach(callback) {\n  function validator(node, key, val) {\n    if (!Array.isArray(val)) return;\n\n    for (var i = 0; i < val.length; i++) {\n      callback(node, key + \"[\" + i + \"]\", val[i]);\n    }\n  }\n  validator.each = callback;\n  return validator;\n}\n\nfunction assertOneOf() {\n  for (var _len = arguments.length, vals = Array(_len), _key = 0; _key < _len; _key++) {\n    vals[_key] = arguments[_key];\n  }\n\n  function validate(node, key, val) {\n    if (vals.indexOf(val) < 0) {\n      throw new TypeError(\"Property \" + key + \" expected value to be one of \" + (0, _stringify2.default)(vals) + \" but got \" + (0, _stringify2.default)(val));\n    }\n  }\n\n  validate.oneOf = vals;\n\n  return validate;\n}\n\nfunction assertNodeType() {\n  for (var _len2 = arguments.length, types = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    types[_key2] = arguments[_key2];\n  }\n\n  function validate(node, key, val) {\n    var valid = false;\n\n    for (var _iterator = types, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var type = _ref;\n\n      if (t.is(type, val)) {\n        valid = true;\n        break;\n      }\n    }\n\n    if (!valid) {\n      throw new TypeError(\"Property \" + key + \" of \" + node.type + \" expected node to be of a type \" + (0, _stringify2.default)(types) + \" \" + (\"but instead got \" + (0, _stringify2.default)(val && val.type)));\n    }\n  }\n\n  validate.oneOfNodeTypes = types;\n\n  return validate;\n}\n\nfunction assertNodeOrValueType() {\n  for (var _len3 = arguments.length, types = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    types[_key3] = arguments[_key3];\n  }\n\n  function validate(node, key, val) {\n    var valid = false;\n\n    for (var _iterator2 = types, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var type = _ref2;\n\n      if (getType(val) === type || t.is(type, val)) {\n        valid = true;\n        break;\n      }\n    }\n\n    if (!valid) {\n      throw new TypeError(\"Property \" + key + \" of \" + node.type + \" expected node to be of a type \" + (0, _stringify2.default)(types) + \" \" + (\"but instead got \" + (0, _stringify2.default)(val && val.type)));\n    }\n  }\n\n  validate.oneOfNodeOrValueTypes = types;\n\n  return validate;\n}\n\nfunction assertValueType(type) {\n  function validate(node, key, val) {\n    var valid = getType(val) === type;\n\n    if (!valid) {\n      throw new TypeError(\"Property \" + key + \" expected type of \" + type + \" but got \" + getType(val));\n    }\n  }\n\n  validate.type = type;\n\n  return validate;\n}\n\nfunction chain() {\n  for (var _len4 = arguments.length, fns = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    fns[_key4] = arguments[_key4];\n  }\n\n  function validate() {\n    for (var _iterator3 = fns, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {\n      var _ref3;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n\n      var fn = _ref3;\n\n      fn.apply(undefined, arguments);\n    }\n  }\n  validate.chainOf = fns;\n  return validate;\n}\n\nfunction defineType(type) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var inherits = opts.inherits && store[opts.inherits] || {};\n\n  opts.fields = opts.fields || inherits.fields || {};\n  opts.visitor = opts.visitor || inherits.visitor || [];\n  opts.aliases = opts.aliases || inherits.aliases || [];\n  opts.builder = opts.builder || inherits.builder || opts.visitor || [];\n\n  if (opts.deprecatedAlias) {\n    DEPRECATED_KEYS[opts.deprecatedAlias] = type;\n  }\n\n  for (var _iterator4 = opts.visitor.concat(opts.builder), _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {\n    var _ref4;\n\n    if (_isArray4) {\n      if (_i4 >= _iterator4.length) break;\n      _ref4 = _iterator4[_i4++];\n    } else {\n      _i4 = _iterator4.next();\n      if (_i4.done) break;\n      _ref4 = _i4.value;\n    }\n\n    var _key5 = _ref4;\n\n    opts.fields[_key5] = opts.fields[_key5] || {};\n  }\n\n  for (var key in opts.fields) {\n    var field = opts.fields[key];\n\n    if (opts.builder.indexOf(key) === -1) {\n      field.optional = true;\n    }\n    if (field.default === undefined) {\n      field.default = null;\n    } else if (!field.validate) {\n      field.validate = assertValueType(getType(field.default));\n    }\n  }\n\n  VISITOR_KEYS[type] = opts.visitor;\n  BUILDER_KEYS[type] = opts.builder;\n  NODE_FIELDS[type] = opts.fields;\n  ALIAS_KEYS[type] = opts.aliases;\n\n  store[type] = opts;\n}\n\nvar store = {};","\n\nvar _index = require(\"../index\");\n\nvar t = _interopRequireWildcard(_index);\n\nvar _constants = require(\"../constants\");\n\nvar _index2 = require(\"./index\");\n\nvar _index3 = _interopRequireDefault(_index2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n(0, _index3.default)(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeOrValueType)(\"null\", \"Expression\", \"SpreadElement\"))),\n      default: []\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\n\n(0, _index3.default)(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: (0, _index2.assertValueType)(\"string\")\n    },\n    left: {\n      validate: (0, _index2.assertNodeType)(\"LVal\")\n    },\n    right: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    }\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"]\n});\n\n(0, _index3.default)(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: _index2.assertOneOf.apply(undefined, _constants.BINARY_OPERATORS)\n    },\n    left: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    }\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"]\n});\n\n(0, _index3.default)(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _index2.assertNodeType)(\"DirectiveLiteral\")\n    }\n  }\n});\n\n(0, _index3.default)(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _index2.assertValueType)(\"string\")\n    }\n  }\n});\n\n(0, _index3.default)(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"]\n});\n\n(0, _index3.default)(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _index2.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n\n(0, _index3.default)(\"CallExpression\", {\n  visitor: [\"callee\", \"arguments\"],\n  fields: {\n    callee: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    arguments: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"Expression\", \"SpreadElement\")))\n    }\n  },\n  aliases: [\"Expression\"]\n});\n\n(0, _index3.default)(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: (0, _index2.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _index2.assertNodeType)(\"BlockStatement\")\n    }\n  },\n  aliases: [\"Scopable\"]\n});\n\n(0, _index3.default)(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    alternate: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\", \"Conditional\"]\n});\n\n(0, _index3.default)(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _index2.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n\n(0, _index3.default)(\"DebuggerStatement\", {\n  aliases: [\"Statement\"]\n});\n\n(0, _index3.default)(\"DoWhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  fields: {\n    test: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _index2.assertNodeType)(\"Statement\")\n    }\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"]\n});\n\n(0, _index3.default)(\"EmptyStatement\", {\n  aliases: [\"Statement\"]\n});\n\n(0, _index3.default)(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"]\n});\n\n(0, _index3.default)(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: (0, _index2.assertNodeType)(\"Program\")\n    }\n  }\n});\n\n(0, _index3.default)(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: (0, _index2.assertNodeType)(\"VariableDeclaration\", \"LVal\")\n    },\n    right: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _index2.assertNodeType)(\"Statement\")\n    }\n  }\n});\n\n(0, _index3.default)(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: (0, _index2.assertNodeType)(\"VariableDeclaration\", \"Expression\"),\n      optional: true\n    },\n    test: {\n      validate: (0, _index2.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    update: {\n      validate: (0, _index2.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _index2.assertNodeType)(\"Statement\")\n    }\n  }\n});\n\n(0, _index3.default)(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"],\n  fields: {\n    id: {\n      validate: (0, _index2.assertNodeType)(\"Identifier\")\n    },\n    params: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"LVal\")))\n    },\n    body: {\n      validate: (0, _index2.assertNodeType)(\"BlockStatement\")\n    },\n    generator: {\n      default: false,\n      validate: (0, _index2.assertValueType)(\"boolean\")\n    },\n    async: {\n      default: false,\n      validate: (0, _index2.assertValueType)(\"boolean\")\n    }\n  },\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Statement\", \"Pureish\", \"Declaration\"]\n});\n\n(0, _index3.default)(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: {\n    id: {\n      validate: (0, _index2.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    params: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"LVal\")))\n    },\n    body: {\n      validate: (0, _index2.assertNodeType)(\"BlockStatement\")\n    },\n    generator: {\n      default: false,\n      validate: (0, _index2.assertValueType)(\"boolean\")\n    },\n    async: {\n      default: false,\n      validate: (0, _index2.assertValueType)(\"boolean\")\n    }\n  }\n});\n\n(0, _index3.default)(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: {\n    name: {\n      validate: function validate(node, key, val) {\n        if (!t.isValidIdentifier(val)) {}\n      }\n    },\n    decorators: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"Decorator\")))\n    }\n  }\n});\n\n(0, _index3.default)(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _index2.assertNodeType)(\"Statement\")\n    },\n    alternate: {\n      optional: true,\n      validate: (0, _index2.assertNodeType)(\"Statement\")\n    }\n  }\n});\n\n(0, _index3.default)(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: (0, _index2.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _index2.assertNodeType)(\"Statement\")\n    }\n  }\n});\n\n(0, _index3.default)(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _index2.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n\n(0, _index3.default)(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: (0, _index2.assertValueType)(\"number\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n\n(0, _index3.default)(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n\n(0, _index3.default)(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _index2.assertValueType)(\"boolean\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n\n(0, _index3.default)(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: (0, _index2.assertValueType)(\"string\")\n    },\n    flags: {\n      validate: (0, _index2.assertValueType)(\"string\"),\n      default: \"\"\n    }\n  }\n});\n\n(0, _index3.default)(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: _index2.assertOneOf.apply(undefined, _constants.LOGICAL_OPERATORS)\n    },\n    left: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    }\n  }\n});\n\n(0, _index3.default)(\"MemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: {\n    object: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function validate(node, key, val) {\n        var expectedType = node.computed ? \"Expression\" : \"Identifier\";\n        (0, _index2.assertNodeType)(expectedType)(node, key, val);\n      }\n    },\n    computed: {\n      default: false\n    }\n  }\n});\n\n(0, _index3.default)(\"NewExpression\", {\n  visitor: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    arguments: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"Expression\", \"SpreadElement\")))\n    }\n  }\n});\n\n(0, _index3.default)(\"Program\", {\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\"],\n  fields: {\n    directives: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"FunctionParent\"]\n});\n\n(0, _index3.default)(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"ObjectMethod\", \"ObjectProperty\", \"SpreadProperty\")))\n    }\n  }\n});\n\n(0, _index3.default)(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\"],\n  fields: {\n    kind: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"string\"), (0, _index2.assertOneOf)(\"method\", \"get\", \"set\")),\n      default: \"method\"\n    },\n    computed: {\n      validate: (0, _index2.assertValueType)(\"boolean\"),\n      default: false\n    },\n    key: {\n      validate: function validate(node, key, val) {\n        var expectedTypes = node.computed ? [\"Expression\"] : [\"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        _index2.assertNodeType.apply(undefined, expectedTypes)(node, key, val);\n      }\n    },\n    decorators: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"Decorator\")))\n    },\n    body: {\n      validate: (0, _index2.assertNodeType)(\"BlockStatement\")\n    },\n    generator: {\n      default: false,\n      validate: (0, _index2.assertValueType)(\"boolean\")\n    },\n    async: {\n      default: false,\n      validate: (0, _index2.assertValueType)(\"boolean\")\n    }\n  },\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"UserWhitespacable\", \"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"ObjectMember\"]\n});\n\n(0, _index3.default)(\"ObjectProperty\", {\n  builder: [\"key\", \"value\", \"computed\", \"shorthand\", \"decorators\"],\n  fields: {\n    computed: {\n      validate: (0, _index2.assertValueType)(\"boolean\"),\n      default: false\n    },\n    key: {\n      validate: function validate(node, key, val) {\n        var expectedTypes = node.computed ? [\"Expression\"] : [\"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        _index2.assertNodeType.apply(undefined, expectedTypes)(node, key, val);\n      }\n    },\n    value: {\n      validate: (0, _index2.assertNodeType)(\"Expression\", \"Pattern\", \"RestElement\")\n    },\n    shorthand: {\n      validate: (0, _index2.assertValueType)(\"boolean\"),\n      default: false\n    },\n    decorators: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  },\n  visitor: [\"key\", \"value\", \"decorators\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"]\n});\n\n(0, _index3.default)(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  aliases: [\"LVal\"],\n  fields: {\n    argument: {\n      validate: (0, _index2.assertNodeType)(\"LVal\")\n    },\n    decorators: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"Decorator\")))\n    }\n  }\n});\n\n(0, _index3.default)(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _index2.assertNodeType)(\"Expression\"),\n      optional: true\n    }\n  }\n});\n\n(0, _index3.default)(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"Expression\")))\n    }\n  },\n  aliases: [\"Expression\"]\n});\n\n(0, _index3.default)(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: (0, _index2.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    consequent: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"Statement\")))\n    }\n  }\n});\n\n(0, _index3.default)(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    cases: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"SwitchCase\")))\n    }\n  }\n});\n\n(0, _index3.default)(\"ThisExpression\", {\n  aliases: [\"Expression\"]\n});\n\n(0, _index3.default)(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    }\n  }\n});\n\n(0, _index3.default)(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    body: {\n      validate: (0, _index2.assertNodeType)(\"BlockStatement\")\n    },\n    handler: {\n      optional: true,\n      handler: (0, _index2.assertNodeType)(\"BlockStatement\")\n    },\n    finalizer: {\n      optional: true,\n      validate: (0, _index2.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\n\n(0, _index3.default)(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true\n    },\n    argument: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: _index2.assertOneOf.apply(undefined, _constants.UNARY_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"]\n});\n\n(0, _index3.default)(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false\n    },\n    argument: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: _index2.assertOneOf.apply(undefined, _constants.UPDATE_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"]\n});\n\n(0, _index3.default)(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    kind: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"string\"), (0, _index2.assertOneOf)(\"var\", \"let\", \"const\"))\n    },\n    declarations: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"VariableDeclarator\")))\n    }\n  }\n});\n\n(0, _index3.default)(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: (0, _index2.assertNodeType)(\"LVal\")\n    },\n    init: {\n      optional: true,\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    }\n  }\n});\n\n(0, _index3.default)(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _index2.assertNodeType)(\"BlockStatement\", \"Statement\")\n    }\n  }\n});\n\n(0, _index3.default)(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      object: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _index2.assertNodeType)(\"BlockStatement\", \"Statement\")\n    }\n  }\n});","\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n(0, _index2.default)(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Pattern\", \"LVal\"],\n  fields: {\n    left: {\n      validate: (0, _index.assertNodeType)(\"Identifier\")\n    },\n    right: {\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"Decorator\")))\n    }\n  }\n});\n\n(0, _index2.default)(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  aliases: [\"Pattern\", \"LVal\"],\n  fields: {\n    elements: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\")))\n    },\n    decorators: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"Decorator\")))\n    }\n  }\n});\n\n(0, _index2.default)(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"params\", \"body\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: {\n    params: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"LVal\")))\n    },\n    body: {\n      validate: (0, _index.assertNodeType)(\"BlockStatement\", \"Expression\")\n    },\n    async: {\n      validate: (0, _index.assertValueType)(\"boolean\"),\n      default: false\n    }\n  }\n});\n\n(0, _index2.default)(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"ClassMethod\", \"ClassProperty\")))\n    }\n  }\n});\n\n(0, _index2.default)(\"ClassDeclaration\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\"id\", \"body\", \"superClass\", \"mixins\", \"typeParameters\", \"superTypeParameters\", \"implements\", \"decorators\"],\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\", \"Pureish\"],\n  fields: {\n    id: {\n      validate: (0, _index.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _index.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"Decorator\")))\n    }\n  }\n});\n\n(0, _index2.default)(\"ClassExpression\", {\n  inherits: \"ClassDeclaration\",\n  aliases: [\"Scopable\", \"Class\", \"Expression\", \"Pureish\"],\n  fields: {\n    id: {\n      optional: true,\n      validate: (0, _index.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _index.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"Decorator\")))\n    }\n  }\n});\n\n(0, _index2.default)(\"ExportAllDeclaration\", {\n  visitor: [\"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    source: {\n      validate: (0, _index.assertNodeType)(\"StringLiteral\")\n    }\n  }\n});\n\n(0, _index2.default)(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      validate: (0, _index.assertNodeType)(\"FunctionDeclaration\", \"ClassDeclaration\", \"Expression\")\n    }\n  }\n});\n\n(0, _index2.default)(\"ExportNamedDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      validate: (0, _index.assertNodeType)(\"Declaration\"),\n      optional: true\n    },\n    specifiers: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"ExportSpecifier\")))\n    },\n    source: {\n      validate: (0, _index.assertNodeType)(\"StringLiteral\"),\n      optional: true\n    }\n  }\n});\n\n(0, _index2.default)(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _index.assertNodeType)(\"Identifier\")\n    },\n    exported: {\n      validate: (0, _index.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n\n(0, _index2.default)(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: (0, _index.assertNodeType)(\"VariableDeclaration\", \"LVal\")\n    },\n    right: {\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _index.assertNodeType)(\"Statement\")\n    }\n  }\n});\n\n(0, _index2.default)(\"ImportDeclaration\", {\n  visitor: [\"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\"],\n  fields: {\n    specifiers: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"ImportSpecifier\", \"ImportDefaultSpecifier\", \"ImportNamespaceSpecifier\")))\n    },\n    source: {\n      validate: (0, _index.assertNodeType)(\"StringLiteral\")\n    }\n  }\n});\n\n(0, _index2.default)(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _index.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n\n(0, _index2.default)(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _index.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n\n(0, _index2.default)(\"ImportSpecifier\", {\n  visitor: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _index.assertNodeType)(\"Identifier\")\n    },\n    imported: {\n      validate: (0, _index.assertNodeType)(\"Identifier\")\n    },\n    importKind: {\n      validate: (0, _index.assertOneOf)(null, \"type\", \"typeof\")\n    }\n  }\n});\n\n(0, _index2.default)(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate: (0, _index.assertValueType)(\"string\")\n    },\n    property: {\n      validate: (0, _index.assertValueType)(\"string\")\n    }\n  }\n});\n\n(0, _index2.default)(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"static\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  fields: {\n    kind: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"string\"), (0, _index.assertOneOf)(\"get\", \"set\", \"method\", \"constructor\")),\n      default: \"method\"\n    },\n    computed: {\n      default: false,\n      validate: (0, _index.assertValueType)(\"boolean\")\n    },\n    static: {\n      default: false,\n      validate: (0, _index.assertValueType)(\"boolean\")\n    },\n    key: {\n      validate: function validate(node, key, val) {\n        var expectedTypes = node.computed ? [\"Expression\"] : [\"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        _index.assertNodeType.apply(undefined, expectedTypes)(node, key, val);\n      }\n    },\n    params: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"LVal\")))\n    },\n    body: {\n      validate: (0, _index.assertNodeType)(\"BlockStatement\")\n    },\n    generator: {\n      default: false,\n      validate: (0, _index.assertValueType)(\"boolean\")\n    },\n    async: {\n      default: false,\n      validate: (0, _index.assertValueType)(\"boolean\")\n    }\n  }\n});\n\n(0, _index2.default)(\"ObjectPattern\", {\n  visitor: [\"properties\", \"typeAnnotation\"],\n  aliases: [\"Pattern\", \"LVal\"],\n  fields: {\n    properties: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"RestProperty\", \"Property\")))\n    },\n    decorators: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"Decorator\")))\n    }\n  }\n});\n\n(0, _index2.default)(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  fields: {\n    argument: {\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    }\n  }\n});\n\n(0, _index2.default)(\"Super\", {\n  aliases: [\"Expression\"]\n});\n\n(0, _index2.default)(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    },\n    quasi: {\n      validate: (0, _index.assertNodeType)(\"TemplateLiteral\")\n    }\n  }\n});\n\n(0, _index2.default)(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {},\n    tail: {\n      validate: (0, _index.assertValueType)(\"boolean\"),\n      default: false\n    }\n  }\n});\n\n(0, _index2.default)(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"TemplateElement\")))\n    },\n    expressions: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"Expression\")))\n    }\n  }\n});\n\n(0, _index2.default)(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate: (0, _index.assertValueType)(\"boolean\"),\n      default: false\n    },\n    argument: {\n      optional: true,\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    }\n  }\n});","\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n(0, _index2.default)(\"AnyTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"ArrayTypeAnnotation\", {\n  visitor: [\"elementType\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"BooleanTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"BooleanLiteralTypeAnnotation\", {\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"NullLiteralTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"ClassImplements\", {\n  visitor: [\"id\", \"typeParameters\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"ClassProperty\", {\n  visitor: [\"key\", \"value\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"key\", \"value\", \"typeAnnotation\", \"decorators\", \"computed\"],\n  aliases: [\"Property\"],\n  fields: {\n    computed: {\n      validate: (0, _index.assertValueType)(\"boolean\"),\n      default: false\n    }\n  }\n});\n\n(0, _index2.default)(\"DeclareClass\", {\n  visitor: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"DeclareFunction\", {\n  visitor: [\"id\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"DeclareInterface\", {\n  visitor: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"DeclareModule\", {\n  visitor: [\"id\", \"body\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"DeclareModuleExports\", {\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"DeclareTypeAlias\", {\n  visitor: [\"id\", \"typeParameters\", \"right\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"DeclareOpaqueType\", {\n  visitor: [\"id\", \"typeParameters\", \"supertype\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"DeclareVariable\", {\n  visitor: [\"id\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"DeclareExportDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"ExistentialTypeParam\", {\n  aliases: [\"Flow\"]\n});\n\n(0, _index2.default)(\"FunctionTypeAnnotation\", {\n  visitor: [\"typeParameters\", \"params\", \"rest\", \"returnType\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"FunctionTypeParam\", {\n  visitor: [\"name\", \"typeAnnotation\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"GenericTypeAnnotation\", {\n  visitor: [\"id\", \"typeParameters\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"InterfaceExtends\", {\n  visitor: [\"id\", \"typeParameters\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"InterfaceDeclaration\", {\n  visitor: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"IntersectionTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"MixedTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"]\n});\n\n(0, _index2.default)(\"EmptyTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"]\n});\n\n(0, _index2.default)(\"NullableTypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"NumericLiteralTypeAnnotation\", {\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"NumberTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"StringLiteralTypeAnnotation\", {\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"StringTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"ThisTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"TupleTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"TypeofTypeAnnotation\", {\n  visitor: [\"argument\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"TypeAlias\", {\n  visitor: [\"id\", \"typeParameters\", \"right\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"OpaqueType\", {\n  visitor: [\"id\", \"typeParameters\", \"impltype\", \"supertype\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"TypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"TypeCastExpression\", {\n  visitor: [\"expression\", \"typeAnnotation\"],\n  aliases: [\"Flow\", \"ExpressionWrapper\", \"Expression\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"TypeParameter\", {\n  visitor: [\"bound\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"TypeParameterDeclaration\", {\n  visitor: [\"params\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"TypeParameterInstantiation\", {\n  visitor: [\"params\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"ObjectTypeAnnotation\", {\n  visitor: [\"properties\", \"indexers\", \"callProperties\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"ObjectTypeCallProperty\", {\n  visitor: [\"value\"],\n  aliases: [\"Flow\", \"UserWhitespacable\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"ObjectTypeIndexer\", {\n  visitor: [\"id\", \"key\", \"value\"],\n  aliases: [\"Flow\", \"UserWhitespacable\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"ObjectTypeProperty\", {\n  visitor: [\"key\", \"value\"],\n  aliases: [\"Flow\", \"UserWhitespacable\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"ObjectTypeSpreadProperty\", {\n  visitor: [\"argument\"],\n  aliases: [\"Flow\", \"UserWhitespacable\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"QualifiedTypeIdentifier\", {\n  visitor: [\"id\", \"qualification\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"UnionTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"VoidTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"],\n  fields: {}\n});","\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n(0, _index2.default)(\"JSXAttribute\", {\n  visitor: [\"name\", \"value\"],\n  aliases: [\"JSX\", \"Immutable\"],\n  fields: {\n    name: {\n      validate: (0, _index.assertNodeType)(\"JSXIdentifier\", \"JSXNamespacedName\")\n    },\n    value: {\n      optional: true,\n      validate: (0, _index.assertNodeType)(\"JSXElement\", \"StringLiteral\", \"JSXExpressionContainer\")\n    }\n  }\n});\n\n(0, _index2.default)(\"JSXClosingElement\", {\n  visitor: [\"name\"],\n  aliases: [\"JSX\", \"Immutable\"],\n  fields: {\n    name: {\n      validate: (0, _index.assertNodeType)(\"JSXIdentifier\", \"JSXMemberExpression\")\n    }\n  }\n});\n\n(0, _index2.default)(\"JSXElement\", {\n  builder: [\"openingElement\", \"closingElement\", \"children\", \"selfClosing\"],\n  visitor: [\"openingElement\", \"children\", \"closingElement\"],\n  aliases: [\"JSX\", \"Immutable\", \"Expression\"],\n  fields: {\n    openingElement: {\n      validate: (0, _index.assertNodeType)(\"JSXOpeningElement\")\n    },\n    closingElement: {\n      optional: true,\n      validate: (0, _index.assertNodeType)(\"JSXClosingElement\")\n    },\n    children: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"JSXText\", \"JSXExpressionContainer\", \"JSXSpreadChild\", \"JSXElement\")))\n    }\n  }\n});\n\n(0, _index2.default)(\"JSXEmptyExpression\", {\n  aliases: [\"JSX\", \"Expression\"]\n});\n\n(0, _index2.default)(\"JSXExpressionContainer\", {\n  visitor: [\"expression\"],\n  aliases: [\"JSX\", \"Immutable\"],\n  fields: {\n    expression: {\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    }\n  }\n});\n\n(0, _index2.default)(\"JSXSpreadChild\", {\n  visitor: [\"expression\"],\n  aliases: [\"JSX\", \"Immutable\"],\n  fields: {\n    expression: {\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    }\n  }\n});\n\n(0, _index2.default)(\"JSXIdentifier\", {\n  builder: [\"name\"],\n  aliases: [\"JSX\", \"Expression\"],\n  fields: {\n    name: {\n      validate: (0, _index.assertValueType)(\"string\")\n    }\n  }\n});\n\n(0, _index2.default)(\"JSXMemberExpression\", {\n  visitor: [\"object\", \"property\"],\n  aliases: [\"JSX\", \"Expression\"],\n  fields: {\n    object: {\n      validate: (0, _index.assertNodeType)(\"JSXMemberExpression\", \"JSXIdentifier\")\n    },\n    property: {\n      validate: (0, _index.assertNodeType)(\"JSXIdentifier\")\n    }\n  }\n});\n\n(0, _index2.default)(\"JSXNamespacedName\", {\n  visitor: [\"namespace\", \"name\"],\n  aliases: [\"JSX\"],\n  fields: {\n    namespace: {\n      validate: (0, _index.assertNodeType)(\"JSXIdentifier\")\n    },\n    name: {\n      validate: (0, _index.assertNodeType)(\"JSXIdentifier\")\n    }\n  }\n});\n\n(0, _index2.default)(\"JSXOpeningElement\", {\n  builder: [\"name\", \"attributes\", \"selfClosing\"],\n  visitor: [\"name\", \"attributes\"],\n  aliases: [\"JSX\", \"Immutable\"],\n  fields: {\n    name: {\n      validate: (0, _index.assertNodeType)(\"JSXIdentifier\", \"JSXMemberExpression\")\n    },\n    selfClosing: {\n      default: false,\n      validate: (0, _index.assertValueType)(\"boolean\")\n    },\n    attributes: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"JSXAttribute\", \"JSXSpreadAttribute\")))\n    }\n  }\n});\n\n(0, _index2.default)(\"JSXSpreadAttribute\", {\n  visitor: [\"argument\"],\n  aliases: [\"JSX\"],\n  fields: {\n    argument: {\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    }\n  }\n});\n\n(0, _index2.default)(\"JSXText\", {\n  aliases: [\"JSX\", \"Immutable\"],\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _index.assertValueType)(\"string\")\n    }\n  }\n});","\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n(0, _index2.default)(\"Noop\", {\n  visitor: []\n});\n\n(0, _index2.default)(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    }\n  }\n});","\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n(0, _index2.default)(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    }\n  }\n});\n\n(0, _index2.default)(\"ForAwaitStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: (0, _index.assertNodeType)(\"VariableDeclaration\", \"LVal\")\n    },\n    right: {\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _index.assertNodeType)(\"Statement\")\n    }\n  }\n});\n\n(0, _index2.default)(\"BindExpression\", {\n  visitor: [\"object\", \"callee\"],\n  aliases: [\"Expression\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"Import\", {\n  aliases: [\"Expression\"]\n});\n\n(0, _index2.default)(\"Decorator\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    }\n  }\n});\n\n(0, _index2.default)(\"DoExpression\", {\n  visitor: [\"body\"],\n  aliases: [\"Expression\"],\n  fields: {\n    body: {\n      validate: (0, _index.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\n\n(0, _index2.default)(\"ExportDefaultSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: (0, _index.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n\n(0, _index2.default)(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: (0, _index.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n\n(0, _index2.default)(\"RestProperty\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  fields: {\n    argument: {\n      validate: (0, _index.assertNodeType)(\"LVal\")\n    }\n  }\n});\n\n(0, _index2.default)(\"SpreadProperty\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  fields: {\n    argument: {\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    }\n  }\n});","\n\nexports.__esModule = true;\nexports.isReactComponent = undefined;\nexports.isCompatTag = isCompatTag;\nexports.buildChildren = buildChildren;\n\nvar _index = require(\"./index\");\n\nvar t = _interopRequireWildcard(_index);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar isReactComponent = exports.isReactComponent = t.buildMatchMemberExpression(\"React.Component\");\n\nfunction isCompatTag(tagName) {\n  return !!tagName && /^[a-z]|\\-/.test(tagName);\n}\n\nfunction cleanJSXElementLiteralChild(child, args) {\n  var lines = child.value.split(/\\r\\n|\\n|\\r/);\n\n  var lastNonEmptyLine = 0;\n\n  for (var i = 0; i < lines.length; i++) {\n    if (lines[i].match(/[^ \\t]/)) {\n      lastNonEmptyLine = i;\n    }\n  }\n\n  var str = \"\";\n\n  for (var _i = 0; _i < lines.length; _i++) {\n    var line = lines[_i];\n\n    var isFirstLine = _i === 0;\n    var isLastLine = _i === lines.length - 1;\n    var isLastNonEmptyLine = _i === lastNonEmptyLine;\n\n    var trimmedLine = line.replace(/\\t/g, \" \");\n\n    if (!isFirstLine) {\n      trimmedLine = trimmedLine.replace(/^[ ]+/, \"\");\n    }\n\n    if (!isLastLine) {\n      trimmedLine = trimmedLine.replace(/[ ]+$/, \"\");\n    }\n\n    if (trimmedLine) {\n      if (!isLastNonEmptyLine) {\n        trimmedLine += \" \";\n      }\n\n      str += trimmedLine;\n    }\n  }\n\n  if (str) args.push(t.stringLiteral(str));\n}\n\nfunction buildChildren(node) {\n  var elems = [];\n\n  for (var i = 0; i < node.children.length; i++) {\n    var child = node.children[i];\n\n    if (t.isJSXText(child)) {\n      cleanJSXElementLiteralChild(child, elems);\n      continue;\n    }\n\n    if (t.isJSXExpressionContainer(child)) child = child.expression;\n    if (t.isJSXEmptyExpression(child)) continue;\n\n    elems.push(child);\n  }\n\n  return elems;\n}"]}