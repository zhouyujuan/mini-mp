{"version":3,"sources":["index.js","utils.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports['default'] = function (api) {\n  var transformImport = (0, _utils.createDynamicImportTransform)(api);\n\n  return {\n    // NOTE: Once we drop support for Babel <= v6 we should\n    // update this to import from @babel/plugin-syntax-dynamic-import.\n    // https://www.npmjs.com/package/@babel/plugin-syntax-dynamic-import\n    manipulateOptions: function () {\n      function manipulateOptions(opts, parserOpts) {\n        parserOpts.plugins.push('dynamicImport');\n      }\n\n      return manipulateOptions;\n    }(),\n\n\n    visitor: {\n      Import: function () {\n        function Import(path) {\n          transformImport(this, path);\n        }\n\n        return Import;\n      }()\n    }\n  };\n};\n\nvar _utils = require('./utils');\n\nmodule.exports = exports['default'];","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.getImportSource = getImportSource;\nexports.createDynamicImportTransform = createDynamicImportTransform;\nfunction getImportSource(t, callNode) {\n  var importArguments = callNode.arguments;\n\n  var _importArguments = _slicedToArray(importArguments, 1),\n      importPath = _importArguments[0];\n\n  var isString = t.isStringLiteral(importPath) || t.isTemplateLiteral(importPath);\n  if (isString) {\n    t.removeComments(importPath);\n    return importPath;\n  }\n\n  return t.templateLiteral([t.templateElement({ raw: '', cooked: '' }), t.templateElement({ raw: '', cooked: '' }, true)], importArguments);\n}\n\nfunction createDynamicImportTransform(_ref) {\n  var template = _ref.template,\n      t = _ref.types;\n\n  var builders = {\n    'static': {\n      interop: template('Promise.resolve().then(() => INTEROP(require(SOURCE)))'),\n      noInterop: template('Promise.resolve().then(() => require(SOURCE))')\n    },\n    dynamic: {\n      interop: template('Promise.resolve(SOURCE).then(s => INTEROP(require(s)))'),\n      noInterop: template('Promise.resolve(SOURCE).then(s => require(s))')\n    }\n  };\n\n  var visited = typeof WeakSet === 'function' && new WeakSet();\n\n  var isString = function isString(node) {\n    return t.isStringLiteral(node) || t.isTemplateLiteral(node) && node.expressions.length === 0;\n  };\n\n  return function (context, path) {\n    if (visited) {\n      if (visited.has(path)) {\n        return;\n      }\n      visited.add(path);\n    }\n\n    var SOURCE = getImportSource(t, path.parent);\n\n    var builder = isString(SOURCE) ? builders['static'] : builders.dynamic;\n\n    var newImport = context.opts.noInterop ? builder.noInterop({ SOURCE: SOURCE }) : builder.interop({ SOURCE: SOURCE, INTEROP: context.addHelper('interopRequireWildcard') });\n\n    path.parentPath.replaceWith(newImport);\n  };\n}"]}