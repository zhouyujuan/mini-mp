{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nexports.__esModule = true;\n\nexports.default = function (_ref) {\n  var messages = _ref.messages,\n      template = _ref.template,\n      t = _ref.types;\n\n  var buildForOfArray = template(\"\\n    for (var KEY = 0; KEY < ARR.length; KEY++) BODY;\\n  \");\n\n  var buildForOfLoose = template(\"\\n    for (var LOOP_OBJECT = OBJECT,\\n             IS_ARRAY = Array.isArray(LOOP_OBJECT),\\n             INDEX = 0,\\n             LOOP_OBJECT = IS_ARRAY ? LOOP_OBJECT : LOOP_OBJECT[Symbol.iterator]();;) {\\n      var ID;\\n      if (IS_ARRAY) {\\n        if (INDEX >= LOOP_OBJECT.length) break;\\n        ID = LOOP_OBJECT[INDEX++];\\n      } else {\\n        INDEX = LOOP_OBJECT.next();\\n        if (INDEX.done) break;\\n        ID = INDEX.value;\\n      }\\n    }\\n  \");\n\n  var buildForOf = template(\"\\n    var ITERATOR_COMPLETION = true;\\n    var ITERATOR_HAD_ERROR_KEY = false;\\n    var ITERATOR_ERROR_KEY = undefined;\\n    try {\\n      for (var ITERATOR_KEY = OBJECT[Symbol.iterator](), STEP_KEY; !(ITERATOR_COMPLETION = (STEP_KEY = ITERATOR_KEY.next()).done); ITERATOR_COMPLETION = true) {\\n      }\\n    } catch (err) {\\n      ITERATOR_HAD_ERROR_KEY = true;\\n      ITERATOR_ERROR_KEY = err;\\n    } finally {\\n      try {\\n        if (!ITERATOR_COMPLETION && ITERATOR_KEY.return) {\\n          ITERATOR_KEY.return();\\n        }\\n      } finally {\\n        if (ITERATOR_HAD_ERROR_KEY) {\\n          throw ITERATOR_ERROR_KEY;\\n        }\\n      }\\n    }\\n  \");\n\n\n  function _ForOfStatementArray(path) {\n    var node = path.node,\n        scope = path.scope;\n\n    var nodes = [];\n    var right = node.right;\n\n    if (!t.isIdentifier(right) || !scope.hasBinding(right.name)) {\n      var uid = scope.generateUidIdentifier(\"arr\");\n      nodes.push(t.variableDeclaration(\"var\", [t.variableDeclarator(uid, right)]));\n      right = uid;\n    }\n\n    var iterationKey = scope.generateUidIdentifier(\"i\");\n\n    var loop = buildForOfArray({\n      BODY: node.body,\n      KEY: iterationKey,\n      ARR: right\n    });\n\n    t.inherits(loop, node);\n    t.ensureBlock(loop);\n\n    var iterationValue = t.memberExpression(right, iterationKey, true);\n\n    var left = node.left;\n    if (t.isVariableDeclaration(left)) {\n      left.declarations[0].init = iterationValue;\n      loop.body.body.unshift(left);\n    } else {\n      loop.body.body.unshift(t.expressionStatement(t.assignmentExpression(\"=\", left, iterationValue)));\n    }\n\n    if (path.parentPath.isLabeledStatement()) {\n      loop = t.labeledStatement(path.parentPath.node.label, loop);\n    }\n\n    nodes.push(loop);\n\n    return nodes;\n  }\n\n  return {\n    visitor: {\n      ForOfStatement: function ForOfStatement(path, state) {\n        if (path.get(\"right\").isArrayExpression()) {\n          if (path.parentPath.isLabeledStatement()) {\n            return path.parentPath.replaceWithMultiple(_ForOfStatementArray(path));\n          } else {\n            return path.replaceWithMultiple(_ForOfStatementArray(path));\n          }\n        }\n\n        var callback = spec;\n        if (state.opts.loose) callback = loose;\n\n        var node = path.node;\n\n        var build = callback(path, state);\n        var declar = build.declar;\n        var loop = build.loop;\n        var block = loop.body;\n\n        path.ensureBlock();\n\n        if (declar) {\n          block.body.push(declar);\n        }\n\n        block.body = block.body.concat(node.body.body);\n\n        t.inherits(loop, node);\n        t.inherits(loop.body, node.body);\n\n        if (build.replaceParent) {\n          path.parentPath.replaceWithMultiple(build.node);\n          path.remove();\n        } else {\n          path.replaceWithMultiple(build.node);\n        }\n      }\n    }\n  };\n\n  function loose(path, file) {\n    var node = path.node,\n        scope = path.scope,\n        parent = path.parent;\n    var left = node.left;\n\n    var declar = void 0,\n        id = void 0;\n\n    if (t.isIdentifier(left) || t.isPattern(left) || t.isMemberExpression(left)) {\n      id = left;\n    } else if (t.isVariableDeclaration(left)) {\n      id = scope.generateUidIdentifier(\"ref\");\n      declar = t.variableDeclaration(left.kind, [t.variableDeclarator(left.declarations[0].id, id)]);\n    } else {\n      throw file.buildCodeFrameError(left, messages.get(\"unknownForHead\", left.type));\n    }\n\n    var iteratorKey = scope.generateUidIdentifier(\"iterator\");\n    var isArrayKey = scope.generateUidIdentifier(\"isArray\");\n\n    var loop = buildForOfLoose({\n      LOOP_OBJECT: iteratorKey,\n      IS_ARRAY: isArrayKey,\n      OBJECT: node.right,\n      INDEX: scope.generateUidIdentifier(\"i\"),\n      ID: id\n    });\n\n    if (!declar) {\n      loop.body.body.shift();\n    }\n\n    var isLabeledParent = t.isLabeledStatement(parent);\n    var labeled = void 0;\n\n    if (isLabeledParent) {\n      labeled = t.labeledStatement(parent.label, loop);\n    }\n\n    return {\n      replaceParent: isLabeledParent,\n      declar: declar,\n      node: labeled || loop,\n      loop: loop\n    };\n  }\n\n  function spec(path, file) {\n    var node = path.node,\n        scope = path.scope,\n        parent = path.parent;\n\n    var left = node.left;\n    var declar = void 0;\n\n    var stepKey = scope.generateUidIdentifier(\"step\");\n    var stepValue = t.memberExpression(stepKey, t.identifier(\"value\"));\n\n    if (t.isIdentifier(left) || t.isPattern(left) || t.isMemberExpression(left)) {\n      declar = t.expressionStatement(t.assignmentExpression(\"=\", left, stepValue));\n    } else if (t.isVariableDeclaration(left)) {\n      declar = t.variableDeclaration(left.kind, [t.variableDeclarator(left.declarations[0].id, stepValue)]);\n    } else {\n      throw file.buildCodeFrameError(left, messages.get(\"unknownForHead\", left.type));\n    }\n\n    var iteratorKey = scope.generateUidIdentifier(\"iterator\");\n\n    var template = buildForOf({\n      ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier(\"didIteratorError\"),\n      ITERATOR_COMPLETION: scope.generateUidIdentifier(\"iteratorNormalCompletion\"),\n      ITERATOR_ERROR_KEY: scope.generateUidIdentifier(\"iteratorError\"),\n      ITERATOR_KEY: iteratorKey,\n      STEP_KEY: stepKey,\n      OBJECT: node.right,\n      BODY: null\n    });\n\n    var isLabeledParent = t.isLabeledStatement(parent);\n\n    var tryBody = template[3].block.body;\n    var loop = tryBody[0];\n\n    if (isLabeledParent) {\n      tryBody[0] = t.labeledStatement(parent.label, loop);\n    }\n\n    return {\n      replaceParent: isLabeledParent,\n      declar: declar,\n      loop: loop,\n      node: template\n    };\n  }\n};\n\nmodule.exports = exports[\"default\"];"]}