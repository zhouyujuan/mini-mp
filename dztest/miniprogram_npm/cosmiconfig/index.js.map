{"version":3,"sources":["index.js","createExplorer.js","loaders.js","readFile.js","cacheWrapper.js","getDirectory.js","getPropertyByPath.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA;ACFA,AHSA,ADGA,AENA,ACHA;ACFA,AHSA,ADGA,AENA,ACHA;ACFA,AHSA,ADGA,AENA,ACHA;ACFA,AHSA,AIZA,ALeA,AENA,ACHA;ACFA,AHSA,AIZA,ALeA,AENA,ACHA;ACFA,AHSA,AIZA,ALeA,AENA,ACHA;ACFA,AHSA,AIZA,ACHA,ANkBA,AENA,ACHA;ACFA,AHSA,AIZA,ACHA,ANkBA,AENA,ACHA;ACFA,AHSA,AIZA,ACHA,ANkBA,AENA,ACHA;ACFA,AHSA,AIZA,ACHA,ANkBA,AENA,ACHA;ACFA,AHSA,AIZA,ACHA,ANkBA,AENA,ACHA;ACFA,AHSA,AIZA,ACHA,ANkBA,AENA,ACHA;ACFA,AHSA,AIZA,ACHA,ANkBA,AENA,ACHA;ACFA,AHSA,AIZA,ACHA,ANkBA,AENA,ACHA;ACFA,AHSA,AIZA,ACHA,ANkBA,AENA,ACHA;ACFA,AHSA,AIZA,ACHA,ANkBA,AENA,ACHA;ACFA,AHSA,AIZA,ACHA,ANkBA,AENA,ACHA;ACFA,AHSA,AIZA,ACHA,ANkBA,AENA,ACHA;ACFA,AHSA,AIZA,ACHA,ANkBA,AENA,ACHA;ACFA,AHSA,AIZA,ACHA,ANkBA,AENA,ACHA;AFOA,AIZA,ACHA,ANkBA,AENA,ACHA;AFOA,AIZA,ACHA,ANkBA,AENA,ACHA;AFOA,AIZA,ACHA,ANkBA,AENA,ACHA;AFOA,AIZA,ACHA,ANkBA,AENA,ACHA;AFOA,AIZA,ACHA,ANkBA,AENA,ACHA;AFOA,AIZA,ACHA,ANkBA,AGTA;AFOA,AKfA,ANkBA,AGTA;AFOA,AKfA,ANkBA,AGTA;AFOA,AKfA,ANkBA,AGTA;AFOA,AKfA,ANkBA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["//      \n\n\nconst os = require('os');\nconst createExplorer = require('./createExplorer');\nconst loaders = require('./loaders');\n\nmodule.exports = cosmiconfig;\n\nfunction cosmiconfig(\n  moduleName        ,\n  options   \n                         \n                     \n                                 \n                                      \n                     \n                    \n                                                       \n   \n) {\n  options = options || {};\n  const defaults = {\n    packageProp: moduleName,\n    searchPlaces: [\n      'package.json',\n      `.${moduleName}rc`,\n      `.${moduleName}rc.json`,\n      `.${moduleName}rc.yaml`,\n      `.${moduleName}rc.yml`,\n      `.${moduleName}rc.js`,\n      `${moduleName}.config.js`,\n    ],\n    ignoreEmptySearchPlaces: true,\n    stopDir: os.homedir(),\n    cache: true,\n    transform: identity,\n  };\n  const normalizedOptions                  = Object.assign(\n    {},\n    defaults,\n    options,\n    {\n      loaders: normalizeLoaders(options.loaders),\n    }\n  );\n\n  return createExplorer(normalizedOptions);\n}\n\ncosmiconfig.loadJs = loaders.loadJs;\ncosmiconfig.loadJson = loaders.loadJson;\ncosmiconfig.loadYaml = loaders.loadYaml;\n\nfunction normalizeLoaders(rawLoaders         )          {\n  const defaults = {\n    '.js': { sync: loaders.loadJs, async: loaders.loadJs },\n    '.json': { sync: loaders.loadJson, async: loaders.loadJson },\n    '.yaml': { sync: loaders.loadYaml, async: loaders.loadYaml },\n    '.yml': { sync: loaders.loadYaml, async: loaders.loadYaml },\n    noExt: { sync: loaders.loadYaml, async: loaders.loadYaml },\n  };\n\n  if (!rawLoaders) {\n    return defaults;\n  }\n\n  return Object.keys(rawLoaders).reduce((result, ext) => {\n    const entry = rawLoaders && rawLoaders[ext];\n    if (typeof entry === 'function') {\n      result[ext] = { sync: entry, async: entry };\n    } else {\n      result[ext] = entry;\n    }\n    return result;\n  }, defaults);\n}\n\nfunction identity(x) {\n  return x;\n}\n","//      \n\n\nconst path = require('path');\nconst loaders = require('./loaders');\nconst readFile = require('./readFile');\nconst cacheWrapper = require('./cacheWrapper');\nconst getDirectory = require('./getDirectory');\nconst getPropertyByPath = require('./getPropertyByPath');\n\nconst MODE_SYNC = 'sync';\n\n// An object value represents a config object.\n// null represents that the loader did not find anything relevant.\n// undefined represents that the loader found something relevant\n// but it was empty.\n                                              \n\nclass Explorer {\n                                                      \n                                                 \n                                                        \n                                                   \n                          \n\n  constructor(options                 ) {\n    this.loadCache = options.cache ? new Map() : null;\n    this.loadSyncCache = options.cache ? new Map() : null;\n    this.searchCache = options.cache ? new Map() : null;\n    this.searchSyncCache = options.cache ? new Map() : null;\n    this.config = options;\n    this.validateConfig();\n  }\n\n  clearLoadCache() {\n    if (this.loadCache) {\n      this.loadCache.clear();\n    }\n    if (this.loadSyncCache) {\n      this.loadSyncCache.clear();\n    }\n  }\n\n  clearSearchCache() {\n    if (this.searchCache) {\n      this.searchCache.clear();\n    }\n    if (this.searchSyncCache) {\n      this.searchSyncCache.clear();\n    }\n  }\n\n  clearCaches() {\n    this.clearLoadCache();\n    this.clearSearchCache();\n  }\n\n  validateConfig() {\n    const config = this.config;\n\n    config.searchPlaces.forEach(place => {\n      const loaderKey = path.extname(place) || 'noExt';\n      const loader = config.loaders[loaderKey];\n      if (!loader) {\n        throw new Error(\n          `No loader specified for ${getExtensionDescription(\n            place\n          )}, so searchPlaces item \"${place}\" is invalid`\n        );\n      }\n    });\n  }\n\n  search(searchFrom         )                             {\n    searchFrom = searchFrom || process.cwd();\n    return getDirectory(searchFrom).then(dir => {\n      return this.searchFromDirectory(dir);\n    });\n  }\n\n  searchFromDirectory(dir        )                             {\n    const absoluteDir = path.resolve(process.cwd(), dir);\n    const run = () => {\n      return this.searchDirectory(absoluteDir).then(result => {\n        const nextDir = this.nextDirectoryToSearch(absoluteDir, result);\n        if (nextDir) {\n          return this.searchFromDirectory(nextDir);\n        }\n        return this.config.transform(result);\n      });\n    };\n\n    if (this.searchCache) {\n      return cacheWrapper(this.searchCache, absoluteDir, run);\n    }\n    return run();\n  }\n\n  searchSync(searchFrom         )                    {\n    searchFrom = searchFrom || process.cwd();\n    const dir = getDirectory.sync(searchFrom);\n    return this.searchFromDirectorySync(dir);\n  }\n\n  searchFromDirectorySync(dir        )                    {\n    const absoluteDir = path.resolve(process.cwd(), dir);\n    const run = () => {\n      const result = this.searchDirectorySync(absoluteDir);\n      const nextDir = this.nextDirectoryToSearch(absoluteDir, result);\n      if (nextDir) {\n        return this.searchFromDirectorySync(nextDir);\n      }\n      return this.config.transform(result);\n    };\n\n    if (this.searchSyncCache) {\n      return cacheWrapper(this.searchSyncCache, absoluteDir, run);\n    }\n    return run();\n  }\n\n  searchDirectory(dir        )                             {\n    return this.config.searchPlaces.reduce((prevResultPromise, place) => {\n      return prevResultPromise.then(prevResult => {\n        if (this.shouldSearchStopWithResult(prevResult)) {\n          return prevResult;\n        }\n        return this.loadSearchPlace(dir, place);\n      });\n    }, Promise.resolve(null));\n  }\n\n  searchDirectorySync(dir        )                    {\n    let result = null;\n    for (const place of this.config.searchPlaces) {\n      result = this.loadSearchPlaceSync(dir, place);\n      if (this.shouldSearchStopWithResult(result)) break;\n    }\n    return result;\n  }\n\n  shouldSearchStopWithResult(result                   )          {\n    if (result === null) return false;\n    if (result.isEmpty && this.config.ignoreEmptySearchPlaces) return false;\n    return true;\n  }\n\n  loadSearchPlace(dir        , place        )                             {\n    const filepath = path.join(dir, place);\n    return readFile(filepath).then(content => {\n      return this.createCosmiconfigResult(filepath, content);\n    });\n  }\n\n  loadSearchPlaceSync(dir        , place        )                    {\n    const filepath = path.join(dir, place);\n    const content = readFile.sync(filepath);\n    return this.createCosmiconfigResultSync(filepath, content);\n  }\n\n  nextDirectoryToSearch(\n    currentDir        ,\n    currentResult                   \n  )          {\n    if (this.shouldSearchStopWithResult(currentResult)) {\n      return null;\n    }\n    const nextDir = nextDirUp(currentDir);\n    if (nextDir === currentDir || currentDir === this.config.stopDir) {\n      return null;\n    }\n    return nextDir;\n  }\n\n  loadPackageProp(filepath        , content        ) {\n    const parsedContent = loaders.loadJson(filepath, content);\n    const packagePropValue = getPropertyByPath(\n      parsedContent,\n      this.config.packageProp\n    );\n    return packagePropValue || null;\n  }\n\n  getLoaderEntryForFile(filepath        )              {\n    if (path.basename(filepath) === 'package.json') {\n      const loader = this.loadPackageProp.bind(this);\n      return { sync: loader, async: loader };\n    }\n\n    const loaderKey = path.extname(filepath) || 'noExt';\n    return this.config.loaders[loaderKey] || {};\n  }\n\n  getSyncLoaderForFile(filepath        )             {\n    const entry = this.getLoaderEntryForFile(filepath);\n    if (!entry.sync) {\n      throw new Error(\n        `No sync loader specified for ${getExtensionDescription(filepath)}`\n      );\n    }\n    return entry.sync;\n  }\n\n  getAsyncLoaderForFile(filepath        )              {\n    const entry = this.getLoaderEntryForFile(filepath);\n    const loader = entry.async || entry.sync;\n    if (!loader) {\n      throw new Error(\n        `No async loader specified for ${getExtensionDescription(filepath)}`\n      );\n    }\n    return loader;\n  }\n\n  loadFileContent(\n    mode                  ,\n    filepath        ,\n    content               \n  )                                                 {\n    if (content === null) {\n      return null;\n    }\n    if (content.trim() === '') {\n      return undefined;\n    }\n    const loader =\n      mode === MODE_SYNC\n        ? this.getSyncLoaderForFile(filepath)\n        : this.getAsyncLoaderForFile(filepath);\n    return loader(filepath, content);\n  }\n\n  loadedContentToCosmiconfigResult(\n    filepath        ,\n    loadedContent                   \n  )                    {\n    if (loadedContent === null) {\n      return null;\n    }\n    if (loadedContent === undefined) {\n      return { filepath, config: undefined, isEmpty: true };\n    }\n    return { config: loadedContent, filepath };\n  }\n\n  createCosmiconfigResult(\n    filepath        ,\n    content               \n  )                             {\n    return Promise.resolve()\n      .then(() => {\n        return this.loadFileContent('async', filepath, content);\n      })\n      .then(loaderResult => {\n        return this.loadedContentToCosmiconfigResult(filepath, loaderResult);\n      });\n  }\n\n  createCosmiconfigResultSync(\n    filepath        ,\n    content               \n  )                    {\n    const loaderResult = this.loadFileContent('sync', filepath, content);\n    return this.loadedContentToCosmiconfigResult(filepath, loaderResult);\n  }\n\n  validateFilePath(filepath         ) {\n    if (!filepath) {\n      throw new Error('load and loadSync must pass a non-empty string');\n    }\n  }\n\n  load(filepath        )                             {\n    return Promise.resolve().then(() => {\n      this.validateFilePath(filepath);\n      const absoluteFilePath = path.resolve(process.cwd(), filepath);\n      return cacheWrapper(this.loadCache, absoluteFilePath, () => {\n        return readFile(absoluteFilePath, { throwNotFound: true })\n          .then(content => {\n            return this.createCosmiconfigResult(absoluteFilePath, content);\n          })\n          .then(this.config.transform);\n      });\n    });\n  }\n\n  loadSync(filepath        )                    {\n    this.validateFilePath(filepath);\n    const absoluteFilePath = path.resolve(process.cwd(), filepath);\n    return cacheWrapper(this.loadSyncCache, absoluteFilePath, () => {\n      const content = readFile.sync(absoluteFilePath, { throwNotFound: true });\n      const result = this.createCosmiconfigResultSync(\n        absoluteFilePath,\n        content\n      );\n      return this.config.transform(result);\n    });\n  }\n}\n\nmodule.exports = function createExplorer(options                 ) {\n  const explorer = new Explorer(options);\n\n  return {\n    search: explorer.search.bind(explorer),\n    searchSync: explorer.searchSync.bind(explorer),\n    load: explorer.load.bind(explorer),\n    loadSync: explorer.loadSync.bind(explorer),\n    clearLoadCache: explorer.clearLoadCache.bind(explorer),\n    clearSearchCache: explorer.clearSearchCache.bind(explorer),\n    clearCaches: explorer.clearCaches.bind(explorer),\n  };\n};\n\nfunction nextDirUp(dir        )         {\n  return path.dirname(dir);\n}\n\nfunction getExtensionDescription(filepath        )         {\n  const ext = path.extname(filepath);\n  return ext ? `extension \"${ext}\"` : 'files without extensions';\n}\n","//      \n\n\nconst parseJson = require('parse-json');\nconst yaml = require('js-yaml');\nconst importFresh = require('import-fresh');\n\nfunction loadJs(filepath        )         {\n  const result = importFresh(filepath);\n  return result;\n}\n\nfunction loadJson(filepath        , content        )         {\n  try {\n    return parseJson(content);\n  } catch (err) {\n    err.message = `JSON Error in ${filepath}:\\n${err.message}`;\n    throw err;\n  }\n}\n\nfunction loadYaml(filepath        , content        )         {\n  return yaml.safeLoad(content, { filename: filepath });\n}\n\nmodule.exports = {\n  loadJs,\n  loadJson,\n  loadYaml,\n};\n","//      \n\n\nconst fs = require('fs');\n\n                \n                          \n  \n\nfunction readFile(filepath        , options          )                         {\n  options = options || {};\n  const throwNotFound = options.throwNotFound || false;\n\n  return new Promise((resolve, reject) => {\n    fs.readFile(filepath, 'utf8', (err, content) => {\n      if (err && err.code === 'ENOENT' && !throwNotFound) {\n        return resolve(null);\n      }\n      if (err) return reject(err);\n      resolve(content);\n    });\n  });\n}\n\nreadFile.sync = function readFileSync(\n  filepath        ,\n  options          \n)                {\n  options = options || {};\n  const throwNotFound = options.throwNotFound || false;\n\n  try {\n    return fs.readFileSync(filepath, 'utf8');\n  } catch (err) {\n    if (err.code === 'ENOENT' && !throwNotFound) {\n      return null;\n    }\n    throw err;\n  }\n};\n\nmodule.exports = readFile;\n","//      \n\n\nfunction cacheWrapper   (cache                 , key        , fn         )    {\n  if (!cache) {\n    return fn();\n  }\n\n  const cached = cache.get(key);\n  if (cached !== undefined) {\n    return cached;\n  }\n\n  const result = fn();\n  cache.set(key, result);\n  return result;\n}\n\nmodule.exports = cacheWrapper;\n","//      \n\n\nconst path = require('path');\nconst isDirectory = require('is-directory');\n\nfunction getDirectory(filepath        )                  {\n  return new Promise((resolve, reject) => {\n    return isDirectory(filepath, (err, filepathIsDirectory) => {\n      if (err) {\n        return reject(err);\n      }\n      return resolve(filepathIsDirectory ? filepath : path.dirname(filepath));\n    });\n  });\n}\n\ngetDirectory.sync = function getDirectorySync(filepath        )         {\n  return isDirectory.sync(filepath) ? filepath : path.dirname(filepath);\n};\n\nmodule.exports = getDirectory;\n","//      \n\n\n// Resolves property names or property paths defined with period-delimited\n// strings or arrays of strings. Property names that are found on the source\n// object are used directly (even if they include a period).\n// Nested property names that include periods, within a path, are only\n// understood in array paths.\nfunction getPropertyByPath(source        , path                        )      {\n  if (typeof path === 'string' && source.hasOwnProperty(path)) {\n    return source[path];\n  }\n\n  const parsedPath = typeof path === 'string' ? path.split('.') : path;\n  return parsedPath.reduce((previous, key) => {\n    if (previous === undefined) {\n      return previous;\n    }\n    return previous[key];\n  }, source);\n}\n\nmodule.exports = getPropertyByPath;\n"]}