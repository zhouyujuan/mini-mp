{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nexports.__esModule = true;\n\nvar _keys = require(\"babel-runtime/core-js/object/keys\");\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nexports.push = push;\nexports.hasComputed = hasComputed;\nexports.toComputedObjectFromClass = toComputedObjectFromClass;\nexports.toClassObject = toClassObject;\nexports.toDefineObject = toDefineObject;\n\nvar _babelHelperFunctionName = require(\"babel-helper-function-name\");\n\nvar _babelHelperFunctionName2 = _interopRequireDefault(_babelHelperFunctionName);\n\nvar _has = require(\"lodash/has\");\n\nvar _has2 = _interopRequireDefault(_has);\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction toKind(node) {\n  if (t.isClassMethod(node) || t.isObjectMethod(node)) {\n    if (node.kind === \"get\" || node.kind === \"set\") {\n      return node.kind;\n    }\n  }\n\n  return \"value\";\n}\n\nfunction push(mutatorMap, node, kind, file, scope) {\n  var alias = t.toKeyAlias(node);\n\n  var map = {};\n  if ((0, _has2.default)(mutatorMap, alias)) map = mutatorMap[alias];\n  mutatorMap[alias] = map;\n\n  map._inherits = map._inherits || [];\n  map._inherits.push(node);\n\n  map._key = node.key;\n\n  if (node.computed) {\n    map._computed = true;\n  }\n\n  if (node.decorators) {\n    var decorators = map.decorators = map.decorators || t.arrayExpression([]);\n    decorators.elements = decorators.elements.concat(node.decorators.map(function (dec) {\n      return dec.expression;\n    }).reverse());\n  }\n\n  if (map.value || map.initializer) {\n    throw file.buildCodeFrameError(node, \"Key conflict with sibling node\");\n  }\n\n  var key = void 0,\n      value = void 0;\n\n  if (t.isObjectProperty(node) || t.isObjectMethod(node) || t.isClassMethod(node)) {\n    key = t.toComputedKey(node, node.key);\n  }\n\n  if (t.isObjectProperty(node) || t.isClassProperty(node)) {\n    value = node.value;\n  } else if (t.isObjectMethod(node) || t.isClassMethod(node)) {\n    value = t.functionExpression(null, node.params, node.body, node.generator, node.async);\n    value.returnType = node.returnType;\n  }\n\n  var inheritedKind = toKind(node);\n  if (!kind || inheritedKind !== \"value\") {\n    kind = inheritedKind;\n  }\n\n  if (scope && t.isStringLiteral(key) && (kind === \"value\" || kind === \"initializer\") && t.isFunctionExpression(value)) {\n    value = (0, _babelHelperFunctionName2.default)({ id: key, node: value, scope: scope });\n  }\n\n  if (value) {\n    t.inheritsComments(value, node);\n    map[kind] = value;\n  }\n\n  return map;\n}\n\nfunction hasComputed(mutatorMap) {\n  for (var key in mutatorMap) {\n    if (mutatorMap[key]._computed) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction toComputedObjectFromClass(obj) {\n  var objExpr = t.arrayExpression([]);\n\n  for (var i = 0; i < obj.properties.length; i++) {\n    var prop = obj.properties[i];\n    var val = prop.value;\n    val.properties.unshift(t.objectProperty(t.identifier(\"key\"), t.toComputedKey(prop)));\n    objExpr.elements.push(val);\n  }\n\n  return objExpr;\n}\n\nfunction toClassObject(mutatorMap) {\n  var objExpr = t.objectExpression([]);\n\n  (0, _keys2.default)(mutatorMap).forEach(function (mutatorMapKey) {\n    var map = mutatorMap[mutatorMapKey];\n    var mapNode = t.objectExpression([]);\n\n    var propNode = t.objectProperty(map._key, mapNode, map._computed);\n\n    (0, _keys2.default)(map).forEach(function (key) {\n      var node = map[key];\n      if (key[0] === \"_\") return;\n\n      var inheritNode = node;\n      if (t.isClassMethod(node) || t.isClassProperty(node)) node = node.value;\n\n      var prop = t.objectProperty(t.identifier(key), node);\n      t.inheritsComments(prop, inheritNode);\n      t.removeComments(inheritNode);\n\n      mapNode.properties.push(prop);\n    });\n\n    objExpr.properties.push(propNode);\n  });\n\n  return objExpr;\n}\n\nfunction toDefineObject(mutatorMap) {\n  (0, _keys2.default)(mutatorMap).forEach(function (key) {\n    var map = mutatorMap[key];\n    if (map.value) map.writable = t.booleanLiteral(true);\n    map.configurable = t.booleanLiteral(true);\n    map.enumerable = t.booleanLiteral(true);\n  });\n\n  return toClassObject(mutatorMap);\n}"]}