{"version":3,"sources":["index.js","lib/ensureCompatibility.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _browserslist = require('browserslist');\n\nvar _browserslist2 = _interopRequireDefault(_browserslist);\n\nvar _postcss = require('postcss');\n\nvar _postcss2 = _interopRequireDefault(_postcss);\n\nvar _vendors = require('vendors');\n\nvar _vendors2 = _interopRequireDefault(_vendors);\n\nvar _cssnanoUtilSameParent = require('cssnano-util-same-parent');\n\nvar _cssnanoUtilSameParent2 = _interopRequireDefault(_cssnanoUtilSameParent);\n\nvar _ensureCompatibility = require('./lib/ensureCompatibility');\n\nvar _ensureCompatibility2 = _interopRequireDefault(_ensureCompatibility);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst prefixes = _vendors2.default.map(v => `-${v}-`);\n\nfunction intersect(a, b, not) {\n    return a.filter(c => {\n        const index = ~b.indexOf(c);\n        return not ? !index : index;\n    });\n}\n\n// Internet Explorer use :-ms-input-placeholder.\n// Microsoft Edge use ::-ms-input-placeholder.\nconst findMsInputPlaceholder = selector => ~selector.search(/-ms-input-placeholder/i);\nconst different = (a, b) => intersect(a, b, true).concat(intersect(b, a, true));\nconst filterPrefixes = selector => intersect(prefixes, selector);\n\nfunction sameVendor(selectorsA, selectorsB) {\n    let same = selectors => selectors.map(filterPrefixes).join();\n    let findMsVendor = selectors => selectors.find(findMsInputPlaceholder);\n    return same(selectorsA) === same(selectorsB) && !(findMsVendor(selectorsA) && findMsVendor(selectorsB));\n}\n\nconst noVendor = selector => !filterPrefixes(selector).length;\n\nfunction canMerge(ruleA, ruleB, browsers, compatibilityCache) {\n    const a = ruleA.selectors;\n    const b = ruleB.selectors;\n\n    const selectors = a.concat(b);\n\n    if (!(0, _ensureCompatibility2.default)(selectors, browsers, compatibilityCache)) {\n        return false;\n    }\n\n    const parent = (0, _cssnanoUtilSameParent2.default)(ruleA, ruleB);\n    const { name } = ruleA.parent;\n    if (parent && name && ~name.indexOf('keyframes')) {\n        return false;\n    }\n    return parent && (selectors.every(noVendor) || sameVendor(a, b));\n}\n\nconst getDecls = rule => rule.nodes && rule.nodes.map(String);\nconst joinSelectors = (...rules) => rules.map(s => s.selector).join();\n\nfunction ruleLength(...rules) {\n    return rules.map(r => r.nodes.length ? String(r) : '').join('').length;\n}\n\nfunction splitProp(prop) {\n    const parts = prop.split('-');\n    let base, rest;\n    // Treat vendor prefixed properties as if they were unprefixed;\n    // moving them when combined with non-prefixed properties can\n    // cause issues. e.g. moving -webkit-background-clip when there\n    // is a background shorthand definition.\n    if (prop[0] === '-') {\n        base = parts[2];\n        rest = parts.slice(3);\n    } else {\n        base = parts[0];\n        rest = parts.slice(1);\n    }\n    return [base, rest];\n}\n\nfunction isConflictingProp(propA, propB) {\n    if (propA === propB) {\n        return true;\n    }\n    const a = splitProp(propA);\n    const b = splitProp(propB);\n    return a[0] === b[0] && a[1].length !== b[1].length;\n}\n\nfunction hasConflicts(declProp, notMoved) {\n    return notMoved.some(prop => isConflictingProp(prop, declProp));\n}\n\nfunction partialMerge(first, second) {\n    let intersection = intersect(getDecls(first), getDecls(second));\n    if (!intersection.length) {\n        return second;\n    }\n    let nextRule = second.next();\n    if (nextRule && nextRule.type === 'rule' && canMerge(second, nextRule)) {\n        let nextIntersection = intersect(getDecls(second), getDecls(nextRule));\n        if (nextIntersection.length > intersection.length) {\n            first = second;second = nextRule;intersection = nextIntersection;\n        }\n    }\n    const recievingBlock = second.clone();\n    recievingBlock.selector = joinSelectors(first, second);\n    recievingBlock.nodes = [];\n    const difference = different(getDecls(first), getDecls(second));\n    const filterConflicts = (decls, intersectn) => {\n        let willNotMove = [];\n        return decls.reduce((willMove, decl) => {\n            let intersects = ~intersectn.indexOf(decl);\n            let prop = decl.split(':')[0];\n            let base = prop.split('-')[0];\n            let canMove = difference.every(d => d.split(':')[0] !== base);\n            if (intersects && canMove && !hasConflicts(prop, willNotMove)) {\n                willMove.push(decl);\n            } else {\n                willNotMove.push(prop);\n            }\n            return willMove;\n        }, []);\n    };\n    const containsAllDeclaration = intersectionList => {\n        return intersectionList.some(declaration => {\n            return declaration.split(':')[0].toLowerCase() === 'all';\n        });\n    };\n    intersection = filterConflicts(getDecls(first).reverse(), intersection);\n    intersection = filterConflicts(getDecls(second), intersection);\n\n    // Rules with \"all\" declarations must be on top\n    if (containsAllDeclaration(intersection)) {\n        second.parent.insertBefore(first, recievingBlock);\n    } else {\n        second.parent.insertBefore(second, recievingBlock);\n    }\n\n    const firstClone = first.clone();\n    const secondClone = second.clone();\n    const moveDecl = callback => {\n        return decl => {\n            if (~intersection.indexOf(String(decl))) {\n                callback.call(this, decl);\n            }\n        };\n    };\n    firstClone.walkDecls(moveDecl(decl => {\n        decl.remove();\n        recievingBlock.append(decl);\n    }));\n    secondClone.walkDecls(moveDecl(decl => decl.remove()));\n    const merged = ruleLength(firstClone, recievingBlock, secondClone);\n    const original = ruleLength(first, second);\n    if (merged < original) {\n        first.replaceWith(firstClone);\n        second.replaceWith(secondClone);\n        [firstClone, recievingBlock, secondClone].forEach(r => {\n            if (!r.nodes.length) {\n                r.remove();\n            }\n        });\n        if (!secondClone.parent) {\n            return recievingBlock;\n        }\n        return secondClone;\n    } else {\n        recievingBlock.remove();\n        return second;\n    }\n}\n\nfunction selectorMerger(browsers, compatibilityCache) {\n    let cache = null;\n    return function (rule) {\n        // Prime the cache with the first rule, or alternately ensure that it is\n        // safe to merge both declarations before continuing\n        if (!cache || !canMerge(rule, cache, browsers, compatibilityCache)) {\n            cache = rule;\n            return;\n        }\n        // Ensure that we don't deduplicate the same rule; this is sometimes\n        // caused by a partial merge\n        if (cache === rule) {\n            cache = rule;\n            return;\n        }\n        // Merge when declarations are exactly equal\n        // e.g. h1 { color: red } h2 { color: red }\n        if (getDecls(rule).join(';') === getDecls(cache).join(';')) {\n            rule.selector = joinSelectors(cache, rule);\n            cache.remove();\n            cache = rule;\n            return;\n        }\n        // Merge when both selectors are exactly equal\n        // e.g. a { color: blue } a { font-weight: bold }\n        if (cache.selector === rule.selector) {\n            const cached = getDecls(cache);\n            rule.walk(decl => {\n                if (~cached.indexOf(String(decl))) {\n                    return decl.remove();\n                }\n                cache.append(decl);\n            });\n            rule.remove();\n            return;\n        }\n        // Partial merge: check if the rule contains a subset of the last; if\n        // so create a joined selector with the subset, if smaller.\n        cache = partialMerge(cache, rule);\n    };\n}\n\nexports.default = _postcss2.default.plugin('postcss-merge-rules', () => {\n    return (css, result) => {\n        const resultOpts = result.opts || {};\n        const browsers = (0, _browserslist2.default)(null, {\n            stats: resultOpts.stats,\n            path: __dirname,\n            env: resultOpts.env\n        });\n        const compatibilityCache = {};\n        css.walkRules(selectorMerger(browsers, compatibilityCache));\n    };\n});\nmodule.exports = exports['default'];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.pseudoElements = undefined;\nexports.default = ensureCompatibility;\n\nvar _caniuseApi = require('caniuse-api');\n\nvar _postcssSelectorParser = require('postcss-selector-parser');\n\nvar _postcssSelectorParser2 = _interopRequireDefault(_postcssSelectorParser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst simpleSelectorRe = /^#?[-._a-z0-9 ]+$/i;\n\nconst cssSel2 = 'css-sel2';\nconst cssSel3 = 'css-sel3';\nconst cssGencontent = 'css-gencontent';\nconst cssFirstLetter = 'css-first-letter';\nconst cssFirstLine = 'css-first-line';\nconst cssInOutOfRange = 'css-in-out-of-range';\n\nconst pseudoElements = exports.pseudoElements = {\n    ':active': cssSel2,\n    ':after': cssGencontent,\n    ':before': cssGencontent,\n    ':checked': cssSel3,\n    ':default': 'css-default-pseudo',\n    ':dir': 'css-dir-pseudo',\n    ':disabled': cssSel3,\n    ':empty': cssSel3,\n    ':enabled': cssSel3,\n    ':first-child': cssSel2,\n    ':first-letter': cssFirstLetter,\n    ':first-line': cssFirstLine,\n    ':first-of-type': cssSel3,\n    ':focus': cssSel2,\n    ':focus-within': 'css-focus-within',\n    ':has': 'css-has',\n    ':hover': cssSel2,\n    ':in-range': cssInOutOfRange,\n    ':indeterminate': 'css-indeterminate-pseudo',\n    ':lang': cssSel2,\n    ':last-child': cssSel3,\n    ':last-of-type': cssSel3,\n    ':matches': 'css-matches-pseudo',\n    ':not': cssSel3,\n    ':nth-child': cssSel3,\n    ':nth-last-child': cssSel3,\n    ':nth-last-of-type': cssSel3,\n    ':nth-of-type': cssSel3,\n    ':only-child': cssSel3,\n    ':only-of-type': cssSel3,\n    ':optional': 'css-optional-pseudo',\n    ':out-of-range': cssInOutOfRange,\n    ':placeholder-shown': 'css-placeholder-shown',\n    ':root': cssSel3,\n    ':target': cssSel3,\n    '::after': cssGencontent,\n    '::backdrop': 'dialog',\n    '::before': cssGencontent,\n    '::first-letter': cssFirstLetter,\n    '::first-line': cssFirstLine,\n    '::marker': 'css-marker-pseudo',\n    '::placeholder': 'css-placeholder',\n    '::selection': 'css-selection'\n};\n\nfunction isCssMixin(selector) {\n    return selector[selector.length - 1] === ':';\n}\n\nconst isSupportedCache = {};\n\n// Move to util in future\nfunction isSupportedCached(feature, browsers) {\n    const key = JSON.stringify({ feature, browsers });\n    let result = isSupportedCache[key];\n\n    if (!result) {\n        result = (0, _caniuseApi.isSupported)(feature, browsers);\n        isSupportedCache[key] = result;\n    }\n\n    return result;\n}\n\nfunction ensureCompatibility(selectors, browsers, compatibilityCache) {\n    // Should not merge mixins\n    if (selectors.some(isCssMixin)) {\n        return false;\n    }\n    return selectors.every(selector => {\n        if (simpleSelectorRe.test(selector)) {\n            return true;\n        }\n        if (compatibilityCache && selector in compatibilityCache) {\n            return compatibilityCache[selector];\n        }\n        let compatible = true;\n        (0, _postcssSelectorParser2.default)(ast => {\n            ast.walk(node => {\n                const { type, value } = node;\n                if (type === 'pseudo') {\n                    const entry = pseudoElements[value];\n                    if (entry && compatible) {\n                        compatible = isSupportedCached(entry, browsers);\n                    }\n                }\n                if (type === 'combinator') {\n                    if (~value.indexOf('~')) {\n                        compatible = isSupportedCached(cssSel3, browsers);\n                    }\n                    if (~value.indexOf('>') || ~value.indexOf('+')) {\n                        compatible = isSupportedCached(cssSel2, browsers);\n                    }\n                }\n                if (type === 'attribute' && node.attribute) {\n                    // [foo]\n                    if (!node.operator) {\n                        compatible = isSupportedCached(cssSel2, browsers);\n                    }\n\n                    if (value) {\n                        // [foo=\"bar\"], [foo~=\"bar\"], [foo|=\"bar\"]\n                        if (~['=', '~=', '|='].indexOf(node.operator)) {\n                            compatible = isSupportedCached(cssSel2, browsers);\n                        }\n                        // [foo^=\"bar\"], [foo$=\"bar\"], [foo*=\"bar\"]\n                        if (~['^=', '$=', '*='].indexOf(node.operator)) {\n                            compatible = isSupportedCached(cssSel3, browsers);\n                        }\n                    }\n\n                    // [foo=\"bar\" i]\n                    if (node.insensitive) {\n                        compatible = isSupportedCached('css-case-insensitive', browsers);\n                    }\n                }\n                if (!compatible) {\n                    // If this node was not compatible,\n                    // break out early from walking the rest\n                    return false;\n                }\n            });\n        }).processSync(selector);\n        if (compatibilityCache) {\n            compatibilityCache[selector] = compatible;\n        }\n        return compatible;\n    });\n}"]}