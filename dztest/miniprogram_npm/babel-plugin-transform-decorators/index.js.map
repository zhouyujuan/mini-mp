{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nexports.__esModule = true;\n\nvar _create = require(\"babel-runtime/core-js/object/create\");\n\nvar _create2 = _interopRequireDefault(_create);\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nexports.default = function (_ref) {\n  var t = _ref.types;\n\n  function cleanDecorators(decorators) {\n    return decorators.reverse().map(function (dec) {\n      return dec.expression;\n    });\n  }\n\n  function transformClass(path, ref, state) {\n    var nodes = [];\n\n    state;\n\n    var classDecorators = path.node.decorators;\n    if (classDecorators) {\n      path.node.decorators = null;\n      classDecorators = cleanDecorators(classDecorators);\n\n      for (var _iterator = classDecorators, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n        var _ref2;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref2 = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref2 = _i.value;\n        }\n\n        var decorator = _ref2;\n\n        nodes.push(buildClassDecorator({\n          CLASS_REF: ref,\n          DECORATOR: decorator\n        }));\n      }\n    }\n\n    var map = (0, _create2.default)(null);\n\n    for (var _iterator2 = path.get(\"body.body\"), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {\n      var _ref3;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref3 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref3 = _i2.value;\n      }\n\n      var method = _ref3;\n\n      var decorators = method.node.decorators;\n      if (!decorators) continue;\n\n      var _alias = t.toKeyAlias(method.node);\n      map[_alias] = map[_alias] || [];\n      map[_alias].push(method.node);\n\n      method.remove();\n    }\n\n    for (var alias in map) {\n      var items = map[alias];\n\n      items;\n    }\n\n    return nodes;\n  }\n\n  function hasDecorators(path) {\n    if (path.isClass()) {\n      if (path.node.decorators) return true;\n\n      for (var _iterator3 = path.node.body.body, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {\n        var _ref4;\n\n        if (_isArray3) {\n          if (_i3 >= _iterator3.length) break;\n          _ref4 = _iterator3[_i3++];\n        } else {\n          _i3 = _iterator3.next();\n          if (_i3.done) break;\n          _ref4 = _i3.value;\n        }\n\n        var method = _ref4;\n\n        if (method.decorators) {\n          return true;\n        }\n      }\n    } else if (path.isObjectExpression()) {\n      for (var _iterator4 = path.node.properties, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {\n        var _ref5;\n\n        if (_isArray4) {\n          if (_i4 >= _iterator4.length) break;\n          _ref5 = _iterator4[_i4++];\n        } else {\n          _i4 = _iterator4.next();\n          if (_i4.done) break;\n          _ref5 = _i4.value;\n        }\n\n        var prop = _ref5;\n\n        if (prop.decorators) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  function doError(path) {\n    throw path.buildCodeFrameError(\"Decorators are not officially supported yet in 6.x pending a proposal update.\\nHowever, if you need to use them you can install the legacy decorators transform with:\\n\\nnpm install babel-plugin-transform-decorators-legacy --save-dev\\n\\nand add the following line to your .babelrc file:\\n\\n{\\n  \\\"plugins\\\": [\\\"transform-decorators-legacy\\\"]\\n}\\n\\nThe repo url is: https://github.com/loganfsmyth/babel-plugin-transform-decorators-legacy.\\n    \");\n  }\n\n  return {\n    inherits: require(\"babel-plugin-syntax-decorators\"),\n\n    visitor: {\n      ClassExpression: function ClassExpression(path) {\n        if (!hasDecorators(path)) return;\n        doError(path);\n\n        (0, _babelHelperExplodeClass2.default)(path);\n\n        var ref = path.scope.generateDeclaredUidIdentifier(\"ref\");\n        var nodes = [];\n\n        nodes.push(t.assignmentExpression(\"=\", ref, path.node));\n\n        nodes = nodes.concat(transformClass(path, ref, this));\n\n        nodes.push(ref);\n\n        path.replaceWith(t.sequenceExpression(nodes));\n      },\n      ClassDeclaration: function ClassDeclaration(path) {\n        if (!hasDecorators(path)) return;\n        doError(path);\n        (0, _babelHelperExplodeClass2.default)(path);\n\n        var ref = path.node.id;\n        var nodes = [];\n\n        nodes = nodes.concat(transformClass(path, ref, this).map(function (expr) {\n          return t.expressionStatement(expr);\n        }));\n        nodes.push(t.expressionStatement(ref));\n\n        path.insertAfter(nodes);\n      },\n      ObjectExpression: function ObjectExpression(path) {\n        if (!hasDecorators(path)) return;\n        doError(path);\n      }\n    }\n  };\n};\n\nvar _babelTemplate = require(\"babel-template\");\n\nvar _babelTemplate2 = _interopRequireDefault(_babelTemplate);\n\nvar _babelHelperExplodeClass = require(\"babel-helper-explode-class\");\n\nvar _babelHelperExplodeClass2 = _interopRequireDefault(_babelHelperExplodeClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar buildClassDecorator = (0, _babelTemplate2.default)(\"\\n  CLASS_REF = DECORATOR(CLASS_REF) || CLASS_REF;\\n\");\n\nmodule.exports = exports[\"default\"];"]}