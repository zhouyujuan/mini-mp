{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst postcss = require('postcss');\nconst timsort = require('timsort').sort;\n\nmodule.exports = postcss.plugin('css-declaration-sorter', function (options) {\n  return function (css) {\n    let sortOrderPath;\n\n    options = options || {};\n\n    // Use included sorting order if order is passed and not alphabetically\n    if (options.order && options.order !== 'alphabetically') {\n      sortOrderPath = path.join(__dirname, '../orders/', options.order) + '.json';\n    } else if (options.customOrder) {\n      sortOrderPath = options.customOrder;\n    } else {\n      // Fallback to the default sorting order\n      return processCss(css, 'alphabetically');\n    }\n\n    // Load in the array containing the order from a JSON file\n    return new Promise(function (resolve, reject) {\n      fs.readFile(sortOrderPath, function (error, data) {\n        if (error) return reject(error);\n        resolve(data);\n      });\n    }).then(function (data) {\n      return processCss(css, JSON.parse(data));\n    });\n  };\n});\n\nfunction processCss (css, sortOrder) {\n  const comments = [];\n  const rulesCache = [];\n\n  css.walk(function (node) {\n    const nodes = node.nodes;\n    const type = node.type;\n\n    if (type === 'comment') {\n      // Don't do anything to root comments or the last newline comment\n      const isNewlineNode = ~node.raws.before.indexOf('\\n');\n      const lastNewlineNode = isNewlineNode && !node.next();\n      const onlyNode = !node.prev() && !node.next();\n\n      if (lastNewlineNode || onlyNode || node.parent.type === 'root') {\n        return;\n      }\n\n      if (isNewlineNode) {\n        const pairedNode = node.next() ? node.next() : node.prev().prev();\n        if (pairedNode) {\n          comments.unshift({\n            'comment': node,\n            'pairedNode': pairedNode,\n            'insertPosition': node.next() ? 'Before' : 'After',\n          });\n          node.remove();\n        }\n      } else {\n        const pairedNode = node.prev() ? node.prev() : node.next().next();\n        if (pairedNode) {\n          comments.push({\n            'comment': node,\n            'pairedNode': pairedNode,\n            'insertPosition': 'After',\n          });\n          node.remove();\n        }\n      }\n      return;\n    }\n\n    // Add rule-like nodes to a cache so that we can remove all\n    // comment nodes before we start sorting.\n    const isRule = type === 'rule' || type === 'atrule';\n    if (isRule && nodes && nodes.length > 1) {\n      rulesCache.push(nodes);\n    }\n  });\n\n  // Perform a sort once all comment nodes are removed\n  rulesCache.forEach(function (nodes) {\n    sortCssDecls(nodes, sortOrder);\n  });\n\n  // Add comments back to the nodes they are paired with\n  comments.forEach(function (node) {\n    const pairedNode = node.pairedNode;\n    node.comment.remove();\n    pairedNode.parent['insert' + node.insertPosition](pairedNode, node.comment);\n  });\n}\n\n// Sort CSS declarations alphabetically or using the set sorting order\nfunction sortCssDecls (cssDecls, sortOrder) {\n  if (sortOrder === 'alphabetically') {\n    timsort(cssDecls, function (a, b) {\n      if (a.type === 'decl' && b.type === 'decl') {\n        return comparator(a.prop, b.prop);\n      } else {\n        return compareDifferentType(a, b);\n      }\n    });\n  } else {\n    timsort(cssDecls, function (a, b) {\n      if (a.type === 'decl' && b.type === 'decl') {\n        const aIndex = sortOrder.indexOf(a.prop);\n        const bIndex = sortOrder.indexOf(b.prop);\n        return comparator(aIndex, bIndex);\n      } else {\n        return compareDifferentType(a, b);\n      }\n    });\n  }\n}\n\nfunction comparator (a, b) {\n  return a === b ? 0 : a < b ? -1 : 1;\n}\n\nfunction compareDifferentType (a, b) {\n  if (b.type === 'atrule') { return  0; }\n\n  return (a.type === 'decl') ? -1 : (b.type === 'decl') ? 1 : 0;\n}\n"]}