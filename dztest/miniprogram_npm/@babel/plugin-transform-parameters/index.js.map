{"version":3,"sources":["index.js","params.js","rest.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"convertFunctionParams\", {\n  enumerable: true,\n  get: function () {\n    return _params.default;\n  }\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _params = require(\"./params\");\n\nvar _rest = require(\"./rest\");\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  var _api$assumption;\n\n  api.assertVersion(7);\n  const ignoreFunctionLength = (_api$assumption = api.assumption(\"ignoreFunctionLength\")) != null ? _api$assumption : options.loose;\n  const noNewArrows = api.assumption(\"noNewArrows\");\n  return {\n    name: \"transform-parameters\",\n    visitor: {\n      Function(path) {\n        if (path.isArrowFunctionExpression() && path.get(\"params\").some(param => param.isRestElement() || param.isAssignmentPattern())) {\n          path.arrowFunctionToExpression({\n            noNewArrows\n          });\n        }\n\n        const convertedRest = (0, _rest.default)(path);\n        const convertedParams = (0, _params.default)(path, ignoreFunctionLength);\n\n        if (convertedRest || convertedParams) {\n          path.scope.crawl();\n        }\n      }\n\n    }\n  };\n});\n\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = convertFunctionParams;\n\nvar _core = require(\"@babel/core\");\n\nconst buildDefaultParam = (0, _core.template)(`\n  let VARIABLE_NAME =\n    arguments.length > ARGUMENT_KEY && arguments[ARGUMENT_KEY] !== undefined ?\n      arguments[ARGUMENT_KEY]\n    :\n      DEFAULT_VALUE;\n`);\nconst buildLooseDefaultParam = (0, _core.template)(`\n  if (ASSIGNMENT_IDENTIFIER === UNDEFINED) {\n    ASSIGNMENT_IDENTIFIER = DEFAULT_VALUE;\n  }\n`);\nconst buildLooseDestructuredDefaultParam = (0, _core.template)(`\n  let ASSIGNMENT_IDENTIFIER = PARAMETER_NAME === UNDEFINED ? DEFAULT_VALUE : PARAMETER_NAME ;\n`);\nconst buildSafeArgumentsAccess = (0, _core.template)(`\n  let $0 = arguments.length > $1 ? arguments[$1] : undefined;\n`);\nconst iifeVisitor = {\n  \"ReferencedIdentifier|BindingIdentifier\"(path, state) {\n    const {\n      scope,\n      node\n    } = path;\n    const {\n      name\n    } = node;\n\n    if (name === \"eval\" || scope.getBinding(name) === state.scope.parent.getBinding(name) && state.scope.hasOwnBinding(name)) {\n      state.needsOuterBinding = true;\n      path.stop();\n    }\n  },\n\n  \"TypeAnnotation|TSTypeAnnotation|TypeParameterDeclaration|TSTypeParameterDeclaration\": path => path.skip()\n};\n\nfunction convertFunctionParams(path, ignoreFunctionLength, shouldTransformParam, replaceRestElement) {\n  const params = path.get(\"params\");\n  const isSimpleParameterList = params.every(param => param.isIdentifier());\n  if (isSimpleParameterList) return false;\n  const {\n    node,\n    scope\n  } = path;\n  const state = {\n    stop: false,\n    needsOuterBinding: false,\n    scope\n  };\n  const body = [];\n  const shadowedParams = new Set();\n\n  for (const param of params) {\n    for (const name of Object.keys(param.getBindingIdentifiers())) {\n      var _scope$bindings$name;\n\n      const constantViolations = (_scope$bindings$name = scope.bindings[name]) == null ? void 0 : _scope$bindings$name.constantViolations;\n\n      if (constantViolations) {\n        for (const redeclarator of constantViolations) {\n          const node = redeclarator.node;\n\n          switch (node.type) {\n            case \"VariableDeclarator\":\n              {\n                if (node.init === null) {\n                  const declaration = redeclarator.parentPath;\n\n                  if (!declaration.parentPath.isFor() || declaration.parentPath.get(\"body\") === declaration) {\n                    redeclarator.remove();\n                    break;\n                  }\n                }\n\n                shadowedParams.add(name);\n                break;\n              }\n\n            case \"FunctionDeclaration\":\n              shadowedParams.add(name);\n              break;\n          }\n        }\n      }\n    }\n  }\n\n  if (shadowedParams.size === 0) {\n    for (const param of params) {\n      if (!param.isIdentifier()) param.traverse(iifeVisitor, state);\n      if (state.needsOuterBinding) break;\n    }\n  }\n\n  let firstOptionalIndex = null;\n\n  for (let i = 0; i < params.length; i++) {\n    const param = params[i];\n\n    if (shouldTransformParam && !shouldTransformParam(i)) {\n      continue;\n    }\n\n    const transformedRestNodes = [];\n\n    if (replaceRestElement) {\n      replaceRestElement(param.parentPath, param, transformedRestNodes);\n    }\n\n    const paramIsAssignmentPattern = param.isAssignmentPattern();\n\n    if (paramIsAssignmentPattern && (ignoreFunctionLength || node.kind === \"set\")) {\n      const left = param.get(\"left\");\n      const right = param.get(\"right\");\n      const undefinedNode = scope.buildUndefinedNode();\n\n      if (left.isIdentifier()) {\n        body.push(buildLooseDefaultParam({\n          ASSIGNMENT_IDENTIFIER: _core.types.cloneNode(left.node),\n          DEFAULT_VALUE: right.node,\n          UNDEFINED: undefinedNode\n        }));\n        param.replaceWith(left.node);\n      } else if (left.isObjectPattern() || left.isArrayPattern()) {\n        const paramName = scope.generateUidIdentifier();\n        body.push(buildLooseDestructuredDefaultParam({\n          ASSIGNMENT_IDENTIFIER: left.node,\n          DEFAULT_VALUE: right.node,\n          PARAMETER_NAME: _core.types.cloneNode(paramName),\n          UNDEFINED: undefinedNode\n        }));\n        param.replaceWith(paramName);\n      }\n    } else if (paramIsAssignmentPattern) {\n      if (firstOptionalIndex === null) firstOptionalIndex = i;\n      const left = param.get(\"left\");\n      const right = param.get(\"right\");\n      const defNode = buildDefaultParam({\n        VARIABLE_NAME: left.node,\n        DEFAULT_VALUE: right.node,\n        ARGUMENT_KEY: _core.types.numericLiteral(i)\n      });\n      body.push(defNode);\n    } else if (firstOptionalIndex !== null) {\n      const defNode = buildSafeArgumentsAccess([param.node, _core.types.numericLiteral(i)]);\n      body.push(defNode);\n    } else if (param.isObjectPattern() || param.isArrayPattern()) {\n      const uid = path.scope.generateUidIdentifier(\"ref\");\n\n      const defNode = _core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(param.node, uid)]);\n\n      body.push(defNode);\n      param.replaceWith(_core.types.cloneNode(uid));\n    }\n\n    if (transformedRestNodes) {\n      for (const transformedNode of transformedRestNodes) {\n        body.push(transformedNode);\n      }\n    }\n  }\n\n  if (firstOptionalIndex !== null) {\n    node.params = node.params.slice(0, firstOptionalIndex);\n  }\n\n  path.ensureBlock();\n\n  if (state.needsOuterBinding || shadowedParams.size > 0) {\n    body.push(buildScopeIIFE(shadowedParams, path.get(\"body\").node));\n    path.set(\"body\", _core.types.blockStatement(body));\n    const bodyPath = path.get(\"body.body\");\n    const arrowPath = bodyPath[bodyPath.length - 1].get(\"argument.callee\");\n    arrowPath.arrowFunctionToExpression();\n    arrowPath.node.generator = path.node.generator;\n    arrowPath.node.async = path.node.async;\n    path.node.generator = false;\n  } else {\n    path.get(\"body\").unshiftContainer(\"body\", body);\n  }\n\n  return true;\n}\n\nfunction buildScopeIIFE(shadowedParams, body) {\n  const args = [];\n  const params = [];\n\n  for (const name of shadowedParams) {\n    args.push(_core.types.identifier(name));\n    params.push(_core.types.identifier(name));\n  }\n\n  return _core.types.returnStatement(_core.types.callExpression(_core.types.arrowFunctionExpression(params, body), args));\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = convertFunctionRest;\n\nvar _core = require(\"@babel/core\");\n\nconst buildRest = (0, _core.template)(`\n  for (var LEN = ARGUMENTS.length,\n           ARRAY = new Array(ARRAY_LEN),\n           KEY = START;\n       KEY < LEN;\n       KEY++) {\n    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];\n  }\n`);\nconst restIndex = (0, _core.template)(`\n  (INDEX < OFFSET || ARGUMENTS.length <= INDEX) ? undefined : ARGUMENTS[INDEX]\n`);\nconst restIndexImpure = (0, _core.template)(`\n  REF = INDEX, (REF < OFFSET || ARGUMENTS.length <= REF) ? undefined : ARGUMENTS[REF]\n`);\nconst restLength = (0, _core.template)(`\n  ARGUMENTS.length <= OFFSET ? 0 : ARGUMENTS.length - OFFSET\n`);\n\nfunction referencesRest(path, state) {\n  if (path.node.name === state.name) {\n    return path.scope.bindingIdentifierEquals(state.name, state.outerBinding);\n  }\n\n  return false;\n}\n\nconst memberExpressionOptimisationVisitor = {\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.name, state.outerBinding)) {\n      path.skip();\n    }\n  },\n\n  Flow(path) {\n    if (path.isTypeCastExpression()) return;\n    path.skip();\n  },\n\n  Function(path, state) {\n    const oldNoOptimise = state.noOptimise;\n    state.noOptimise = true;\n    path.traverse(memberExpressionOptimisationVisitor, state);\n    state.noOptimise = oldNoOptimise;\n    path.skip();\n  },\n\n  ReferencedIdentifier(path, state) {\n    const {\n      node\n    } = path;\n\n    if (node.name === \"arguments\") {\n      state.deopted = true;\n    }\n\n    if (!referencesRest(path, state)) return;\n\n    if (state.noOptimise) {\n      state.deopted = true;\n    } else {\n      const {\n        parentPath\n      } = path;\n\n      if (parentPath.listKey === \"params\" && parentPath.key < state.offset) {\n        return;\n      }\n\n      if (parentPath.isMemberExpression({\n        object: node\n      })) {\n        const grandparentPath = parentPath.parentPath;\n        const argsOptEligible = !state.deopted && !(grandparentPath.isAssignmentExpression() && parentPath.node === grandparentPath.node.left || grandparentPath.isLVal() || grandparentPath.isForXStatement() || grandparentPath.isUpdateExpression() || grandparentPath.isUnaryExpression({\n          operator: \"delete\"\n        }) || (grandparentPath.isCallExpression() || grandparentPath.isNewExpression()) && parentPath.node === grandparentPath.node.callee);\n\n        if (argsOptEligible) {\n          if (parentPath.node.computed) {\n            if (parentPath.get(\"property\").isBaseType(\"number\")) {\n              state.candidates.push({\n                cause: \"indexGetter\",\n                path\n              });\n              return;\n            }\n          } else if (parentPath.node.property.name === \"length\") {\n            state.candidates.push({\n              cause: \"lengthGetter\",\n              path\n            });\n            return;\n          }\n        }\n      }\n\n      if (state.offset === 0 && parentPath.isSpreadElement()) {\n        const call = parentPath.parentPath;\n\n        if (call.isCallExpression() && call.node.arguments.length === 1) {\n          state.candidates.push({\n            cause: \"argSpread\",\n            path\n          });\n          return;\n        }\n      }\n\n      state.references.push(path);\n    }\n  },\n\n  BindingIdentifier(path, state) {\n    if (referencesRest(path, state)) {\n      state.deopted = true;\n    }\n  }\n\n};\n\nfunction getParamsCount(node) {\n  let count = node.params.length;\n\n  if (count > 0 && _core.types.isIdentifier(node.params[0], {\n    name: \"this\"\n  })) {\n    count -= 1;\n  }\n\n  return count;\n}\n\nfunction hasRest(node) {\n  const length = node.params.length;\n  return length > 0 && _core.types.isRestElement(node.params[length - 1]);\n}\n\nfunction optimiseIndexGetter(path, argsId, offset) {\n  const offsetLiteral = _core.types.numericLiteral(offset);\n\n  let index;\n\n  if (_core.types.isNumericLiteral(path.parent.property)) {\n    index = _core.types.numericLiteral(path.parent.property.value + offset);\n  } else if (offset === 0) {\n    index = path.parent.property;\n  } else {\n    index = _core.types.binaryExpression(\"+\", path.parent.property, _core.types.cloneNode(offsetLiteral));\n  }\n\n  const {\n    scope\n  } = path;\n\n  if (!scope.isPure(index)) {\n    const temp = scope.generateUidIdentifierBasedOnNode(index);\n    scope.push({\n      id: temp,\n      kind: \"var\"\n    });\n    path.parentPath.replaceWith(restIndexImpure({\n      ARGUMENTS: argsId,\n      OFFSET: offsetLiteral,\n      INDEX: index,\n      REF: _core.types.cloneNode(temp)\n    }));\n  } else {\n    const parentPath = path.parentPath;\n    parentPath.replaceWith(restIndex({\n      ARGUMENTS: argsId,\n      OFFSET: offsetLiteral,\n      INDEX: index\n    }));\n    const offsetTestPath = parentPath.get(\"test\").get(\"left\");\n    const valRes = offsetTestPath.evaluate();\n\n    if (valRes.confident) {\n      if (valRes.value === true) {\n        parentPath.replaceWith(parentPath.scope.buildUndefinedNode());\n      } else {\n        parentPath.get(\"test\").replaceWith(parentPath.get(\"test\").get(\"right\"));\n      }\n    }\n  }\n}\n\nfunction optimiseLengthGetter(path, argsId, offset) {\n  if (offset) {\n    path.parentPath.replaceWith(restLength({\n      ARGUMENTS: argsId,\n      OFFSET: _core.types.numericLiteral(offset)\n    }));\n  } else {\n    path.replaceWith(argsId);\n  }\n}\n\nfunction convertFunctionRest(path) {\n  const {\n    node,\n    scope\n  } = path;\n  if (!hasRest(node)) return false;\n  let rest = node.params.pop().argument;\n\n  const argsId = _core.types.identifier(\"arguments\");\n\n  if (_core.types.isPattern(rest)) {\n    const pattern = rest;\n    rest = scope.generateUidIdentifier(\"ref\");\n\n    const declar = _core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(pattern, rest)]);\n\n    node.body.body.unshift(declar);\n  }\n\n  const paramsCount = getParamsCount(node);\n  const state = {\n    references: [],\n    offset: paramsCount,\n    argumentsNode: argsId,\n    outerBinding: scope.getBindingIdentifier(rest.name),\n    candidates: [],\n    name: rest.name,\n    deopted: false\n  };\n  path.traverse(memberExpressionOptimisationVisitor, state);\n\n  if (!state.deopted && !state.references.length) {\n    for (const {\n      path,\n      cause\n    } of state.candidates) {\n      const clonedArgsId = _core.types.cloneNode(argsId);\n\n      switch (cause) {\n        case \"indexGetter\":\n          optimiseIndexGetter(path, clonedArgsId, state.offset);\n          break;\n\n        case \"lengthGetter\":\n          optimiseLengthGetter(path, clonedArgsId, state.offset);\n          break;\n\n        default:\n          path.replaceWith(clonedArgsId);\n      }\n    }\n\n    return true;\n  }\n\n  state.references = state.references.concat(state.candidates.map(({\n    path\n  }) => path));\n\n  const start = _core.types.numericLiteral(paramsCount);\n\n  const key = scope.generateUidIdentifier(\"key\");\n  const len = scope.generateUidIdentifier(\"len\");\n  let arrKey, arrLen;\n\n  if (paramsCount) {\n    arrKey = _core.types.binaryExpression(\"-\", _core.types.cloneNode(key), _core.types.cloneNode(start));\n    arrLen = _core.types.conditionalExpression(_core.types.binaryExpression(\">\", _core.types.cloneNode(len), _core.types.cloneNode(start)), _core.types.binaryExpression(\"-\", _core.types.cloneNode(len), _core.types.cloneNode(start)), _core.types.numericLiteral(0));\n  } else {\n    arrKey = _core.types.identifier(key.name);\n    arrLen = _core.types.identifier(len.name);\n  }\n\n  const loop = buildRest({\n    ARGUMENTS: argsId,\n    ARRAY_KEY: arrKey,\n    ARRAY_LEN: arrLen,\n    START: start,\n    ARRAY: rest,\n    KEY: key,\n    LEN: len\n  });\n\n  if (state.deopted) {\n    node.body.body.unshift(loop);\n  } else {\n    let target = path.getEarliestCommonAncestorFrom(state.references).getStatementParent();\n    target.findParent(path => {\n      if (path.isLoop()) {\n        target = path;\n      } else {\n        return path.isFunction();\n      }\n    });\n    target.insertBefore(loop);\n  }\n\n  return true;\n}"]}