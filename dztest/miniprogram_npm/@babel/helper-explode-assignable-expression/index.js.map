{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar t = require(\"@babel/types\");\n\nfunction getObjRef(node, nodes, scope) {\n  let ref;\n\n  if (t.isIdentifier(node)) {\n    if (scope.hasBinding(node.name)) {\n      return node;\n    } else {\n      ref = node;\n    }\n  } else if (t.isMemberExpression(node)) {\n    ref = node.object;\n\n    if (t.isSuper(ref) || t.isIdentifier(ref) && scope.hasBinding(ref.name)) {\n      return ref;\n    }\n  } else {\n    throw new Error(`We can't explode this node type ${node[\"type\"]}`);\n  }\n\n  const temp = scope.generateUidIdentifierBasedOnNode(ref);\n  scope.push({\n    id: temp\n  });\n  nodes.push(t.assignmentExpression(\"=\", t.cloneNode(temp), t.cloneNode(ref)));\n  return temp;\n}\n\nfunction getPropRef(node, nodes, scope) {\n  const prop = node.property;\n\n  if (t.isPrivateName(prop)) {\n    throw new Error(\"We can't generate property ref for private name, please install `@babel/plugin-proposal-class-properties`\");\n  }\n\n  const key = t.toComputedKey(node, prop);\n  if (t.isLiteral(key) && t.isPureish(key)) return key;\n  const temp = scope.generateUidIdentifierBasedOnNode(prop);\n  scope.push({\n    id: temp\n  });\n  nodes.push(t.assignmentExpression(\"=\", t.cloneNode(temp), t.cloneNode(prop)));\n  return temp;\n}\n\nfunction _default(node, nodes, file, scope, allowedSingleIdent) {\n  let obj;\n\n  if (t.isIdentifier(node) && allowedSingleIdent) {\n    obj = node;\n  } else {\n    obj = getObjRef(node, nodes, scope);\n  }\n\n  let ref, uid;\n\n  if (t.isIdentifier(node)) {\n    ref = t.cloneNode(node);\n    uid = obj;\n  } else {\n    const prop = getPropRef(node, nodes, scope);\n    const computed = node.computed || t.isLiteral(prop);\n    uid = t.memberExpression(t.cloneNode(obj), t.cloneNode(prop), computed);\n    ref = t.memberExpression(t.cloneNode(obj), t.cloneNode(prop), computed);\n  }\n\n  return {\n    uid: uid,\n    ref: ref\n  };\n}"]}