{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _helperModuleTransforms = require(\"@babel/helper-module-transforms\");\n\nvar _core = require(\"@babel/core\");\n\nvar _utils = require(\"babel-plugin-dynamic-import-node/utils\");\n\nconst buildWrapper = (0, _core.template)(`\n  define(MODULE_NAME, AMD_ARGUMENTS, function(IMPORT_NAMES) {\n  })\n`);\nconst buildAnonymousWrapper = (0, _core.template)(`\n  define([\"require\"], function(REQUIRE) {\n  })\n`);\n\nfunction injectWrapper(path, wrapper) {\n  const {\n    body,\n    directives\n  } = path.node;\n  path.node.directives = [];\n  path.node.body = [];\n  const amdWrapper = path.pushContainer(\"body\", wrapper)[0];\n  const amdFactory = amdWrapper.get(\"expression.arguments\").filter(arg => arg.isFunctionExpression())[0].get(\"body\");\n  amdFactory.pushContainer(\"directives\", directives);\n  amdFactory.pushContainer(\"body\", body);\n}\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  var _api$assumption, _api$assumption2;\n\n  api.assertVersion(7);\n  const {\n    allowTopLevelThis,\n    strict,\n    strictMode,\n    importInterop,\n    noInterop\n  } = options;\n  const constantReexports = (_api$assumption = api.assumption(\"constantReexports\")) != null ? _api$assumption : options.loose;\n  const enumerableModuleMeta = (_api$assumption2 = api.assumption(\"enumerableModuleMeta\")) != null ? _api$assumption2 : options.loose;\n  return {\n    name: \"transform-modules-amd\",\n\n    pre() {\n      this.file.set(\"@babel/plugin-transform-modules-*\", \"amd\");\n    },\n\n    visitor: {\n      CallExpression(path, state) {\n        if (!this.file.has(\"@babel/plugin-proposal-dynamic-import\")) return;\n        if (!path.get(\"callee\").isImport()) return;\n        let {\n          requireId,\n          resolveId,\n          rejectId\n        } = state;\n\n        if (!requireId) {\n          requireId = path.scope.generateUidIdentifier(\"require\");\n          state.requireId = requireId;\n        }\n\n        if (!resolveId || !rejectId) {\n          resolveId = path.scope.generateUidIdentifier(\"resolve\");\n          rejectId = path.scope.generateUidIdentifier(\"reject\");\n          state.resolveId = resolveId;\n          state.rejectId = rejectId;\n        }\n\n        let result = _core.types.identifier(\"imported\");\n\n        if (!noInterop) result = (0, _helperModuleTransforms.wrapInterop)(path, result, \"namespace\");\n        path.replaceWith(_core.template.expression.ast`\n            new Promise((${resolveId}, ${rejectId}) =>\n              ${requireId}(\n                [${(0, _utils.getImportSource)(_core.types, path.node)}],\n                imported => ${_core.types.cloneNode(resolveId)}(${result}),\n                ${_core.types.cloneNode(rejectId)}\n              )\n            )`);\n      },\n\n      Program: {\n        exit(path, {\n          requireId\n        }) {\n          if (!(0, _helperModuleTransforms.isModule)(path)) {\n            if (requireId) {\n              injectWrapper(path, buildAnonymousWrapper({\n                REQUIRE: _core.types.cloneNode(requireId)\n              }));\n            }\n\n            return;\n          }\n\n          const amdArgs = [];\n          const importNames = [];\n\n          if (requireId) {\n            amdArgs.push(_core.types.stringLiteral(\"require\"));\n            importNames.push(_core.types.cloneNode(requireId));\n          }\n\n          let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);\n          if (moduleName) moduleName = _core.types.stringLiteral(moduleName);\n          const {\n            meta,\n            headers\n          } = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path, {\n            enumerableModuleMeta,\n            constantReexports,\n            strict,\n            strictMode,\n            allowTopLevelThis,\n            importInterop,\n            noInterop\n          });\n\n          if ((0, _helperModuleTransforms.hasExports)(meta)) {\n            amdArgs.push(_core.types.stringLiteral(\"exports\"));\n            importNames.push(_core.types.identifier(meta.exportName));\n          }\n\n          for (const [source, metadata] of meta.source) {\n            amdArgs.push(_core.types.stringLiteral(source));\n            importNames.push(_core.types.identifier(metadata.name));\n\n            if (!(0, _helperModuleTransforms.isSideEffectImport)(metadata)) {\n              const interop = (0, _helperModuleTransforms.wrapInterop)(path, _core.types.identifier(metadata.name), metadata.interop);\n\n              if (interop) {\n                const header = _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.identifier(metadata.name), interop));\n\n                header.loc = metadata.loc;\n                headers.push(header);\n              }\n            }\n\n            headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, constantReexports));\n          }\n\n          (0, _helperModuleTransforms.ensureStatementsHoisted)(headers);\n          path.unshiftContainer(\"body\", headers);\n          injectWrapper(path, buildWrapper({\n            MODULE_NAME: moduleName,\n            AMD_ARGUMENTS: _core.types.arrayExpression(amdArgs),\n            IMPORT_NAMES: importNames\n          }));\n        }\n\n      }\n    }\n  };\n});\n\nexports.default = _default;"]}