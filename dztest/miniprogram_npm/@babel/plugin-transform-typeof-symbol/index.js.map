{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)(api => {\n  api.assertVersion(7);\n  return {\n    name: \"transform-typeof-symbol\",\n    visitor: {\n      Scope({\n        scope\n      }) {\n        if (!scope.getBinding(\"Symbol\")) {\n          return;\n        }\n\n        scope.rename(\"Symbol\");\n      },\n\n      UnaryExpression(path) {\n        const {\n          node,\n          parent\n        } = path;\n        if (node.operator !== \"typeof\") return;\n\n        if (path.parentPath.isBinaryExpression() && _core.types.EQUALITY_BINARY_OPERATORS.indexOf(parent.operator) >= 0) {\n          const opposite = path.getOpposite();\n\n          if (opposite.isLiteral() && opposite.node.value !== \"symbol\" && opposite.node.value !== \"object\") {\n            return;\n          }\n        }\n\n        let isUnderHelper = path.findParent(path => {\n          if (path.isFunction()) {\n            var _path$get;\n\n            return ((_path$get = path.get(\"body.directives.0\")) == null ? void 0 : _path$get.node.value.value) === \"@babel/helpers - typeof\";\n          }\n        });\n        if (isUnderHelper) return;\n        const helper = this.addHelper(\"typeof\");\n        isUnderHelper = path.findParent(path => {\n          return path.isVariableDeclarator() && path.node.id === helper || path.isFunctionDeclaration() && path.node.id && path.node.id.name === helper.name;\n        });\n\n        if (isUnderHelper) {\n          return;\n        }\n\n        const call = _core.types.callExpression(helper, [node.argument]);\n\n        const arg = path.get(\"argument\");\n\n        if (arg.isIdentifier() && !path.scope.hasBinding(arg.node.name, true)) {\n          const unary = _core.types.unaryExpression(\"typeof\", _core.types.cloneNode(node.argument));\n\n          path.replaceWith(_core.types.conditionalExpression(_core.types.binaryExpression(\"===\", unary, _core.types.stringLiteral(\"undefined\")), _core.types.stringLiteral(\"undefined\"), call));\n        } else {\n          path.replaceWith(call);\n        }\n      }\n\n    }\n  };\n});\n\nexports.default = _default;"]}