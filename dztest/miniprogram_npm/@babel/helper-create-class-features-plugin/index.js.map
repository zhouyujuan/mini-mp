{"version":3,"sources":["index.js","fields.js","typescript.js","decorators.js","misc.js","features.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AIZA,AFMA;ACFA,AFMA,ADGA,AIZA,AFMA;ACFA,AFMA,ADGA,AIZA,AFMA;ACFA,AENA,AJYA,ADGA,AIZA,AFMA;ACFA,AENA,AJYA,ADGA,AIZA,AFMA;ACFA,AENA,AJYA,ADGA,AIZA,AFMA;ACFA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createClassFeaturePlugin = createClassFeaturePlugin;\nObject.defineProperty(exports, \"injectInitialization\", {\n  enumerable: true,\n  get: function () {\n    return _misc.injectInitialization;\n  }\n});\nObject.defineProperty(exports, \"enableFeature\", {\n  enumerable: true,\n  get: function () {\n    return _features.enableFeature;\n  }\n});\nObject.defineProperty(exports, \"FEATURES\", {\n  enumerable: true,\n  get: function () {\n    return _features.FEATURES;\n  }\n});\n\nvar _core = require(\"@babel/core\");\n\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\n\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\n\nvar _fields = require(\"./fields\");\n\nvar _decorators = require(\"./decorators\");\n\nvar _misc = require(\"./misc\");\n\nvar _features = require(\"./features\");\n\nconst version = \"7.14.6\".split(\".\").reduce((v, x) => v * 1e5 + +x, 0);\nconst versionKey = \"@babel/plugin-class-features/version\";\n\nfunction createClassFeaturePlugin({\n  name,\n  feature,\n  loose,\n  manipulateOptions,\n  api = {\n    assumption: () => {}\n  }\n}) {\n  const setPublicClassFields = api.assumption(\"setPublicClassFields\");\n  const privateFieldsAsProperties = api.assumption(\"privateFieldsAsProperties\");\n  const constantSuper = api.assumption(\"constantSuper\");\n  const noDocumentAll = api.assumption(\"noDocumentAll\");\n\n  if (loose === true) {\n    const explicit = [];\n\n    if (setPublicClassFields !== undefined) {\n      explicit.push(`\"setPublicClassFields\"`);\n    }\n\n    if (privateFieldsAsProperties !== undefined) {\n      explicit.push(`\"privateFieldsAsProperties\"`);\n    }\n\n    if (explicit.length !== 0) {\n      console.warn(`[${name}]: You are using the \"loose: true\" option and you are` + ` explicitly setting a value for the ${explicit.join(\" and \")}` + ` assumption${explicit.length > 1 ? \"s\" : \"\"}. The \"loose\" option` + ` can cause incompatibilities with the other class features` + ` plugins, so it's recommended that you replace it with the` + ` following top-level option:\\n` + `\\t\"assumptions\": {\\n` + `\\t\\t\"setPublicClassFields\": true,\\n` + `\\t\\t\"privateFieldsAsProperties\": true\\n` + `\\t}`);\n    }\n  }\n\n  return {\n    name,\n    manipulateOptions,\n\n    pre() {\n      (0, _features.enableFeature)(this.file, feature, loose);\n\n      if (!this.file.get(versionKey) || this.file.get(versionKey) < version) {\n        this.file.set(versionKey, version);\n      }\n    },\n\n    visitor: {\n      Class(path, state) {\n        if (this.file.get(versionKey) !== version) return;\n        (0, _features.verifyUsedFeatures)(path, this.file);\n        const loose = (0, _features.isLoose)(this.file, feature);\n        let constructor;\n        let isDecorated = (0, _decorators.hasOwnDecorators)(path.node);\n        const props = [];\n        const elements = [];\n        const computedPaths = [];\n        const privateNames = new Set();\n        const body = path.get(\"body\");\n\n        for (const path of body.get(\"body\")) {\n          (0, _features.verifyUsedFeatures)(path, this.file);\n\n          if (path.node.computed) {\n            computedPaths.push(path);\n          }\n\n          if (path.isPrivate()) {\n            const {\n              name\n            } = path.node.key.id;\n            const getName = `get ${name}`;\n            const setName = `set ${name}`;\n\n            if (path.node.kind === \"get\") {\n              if (privateNames.has(getName) || privateNames.has(name) && !privateNames.has(setName)) {\n                throw path.buildCodeFrameError(\"Duplicate private field\");\n              }\n\n              privateNames.add(getName).add(name);\n            } else if (path.node.kind === \"set\") {\n              if (privateNames.has(setName) || privateNames.has(name) && !privateNames.has(getName)) {\n                throw path.buildCodeFrameError(\"Duplicate private field\");\n              }\n\n              privateNames.add(setName).add(name);\n            } else {\n              if (privateNames.has(name) && !privateNames.has(getName) && !privateNames.has(setName) || privateNames.has(name) && (privateNames.has(getName) || privateNames.has(setName))) {\n                throw path.buildCodeFrameError(\"Duplicate private field\");\n              }\n\n              privateNames.add(name);\n            }\n          }\n\n          if (path.isClassMethod({\n            kind: \"constructor\"\n          })) {\n            constructor = path;\n          } else {\n            elements.push(path);\n\n            if (path.isProperty() || path.isPrivate() || path.isStaticBlock != null && path.isStaticBlock()) {\n              props.push(path);\n            }\n          }\n\n          if (!isDecorated) isDecorated = (0, _decorators.hasOwnDecorators)(path.node);\n        }\n\n        if (!props.length && !isDecorated) return;\n        const innerBinding = path.node.id;\n        let ref;\n\n        if (!innerBinding || path.isClassExpression()) {\n          (0, _helperFunctionName.default)(path);\n          ref = path.scope.generateUidIdentifier(\"class\");\n        } else {\n          ref = _core.types.cloneNode(path.node.id);\n        }\n\n        const privateNamesMap = (0, _fields.buildPrivateNamesMap)(props);\n        const privateNamesNodes = (0, _fields.buildPrivateNamesNodes)(privateNamesMap, privateFieldsAsProperties != null ? privateFieldsAsProperties : loose, state);\n        (0, _fields.transformPrivateNamesUsage)(ref, path, privateNamesMap, {\n          privateFieldsAsProperties: privateFieldsAsProperties != null ? privateFieldsAsProperties : loose,\n          noDocumentAll\n        }, state);\n        let keysNodes, staticNodes, pureStaticNodes, instanceNodes, wrapClass;\n\n        if (isDecorated) {\n          staticNodes = pureStaticNodes = keysNodes = [];\n          ({\n            instanceNodes,\n            wrapClass\n          } = (0, _decorators.buildDecoratedClass)(ref, path, elements, this.file));\n        } else {\n          keysNodes = (0, _misc.extractComputedKeys)(ref, path, computedPaths, this.file);\n          ({\n            staticNodes,\n            pureStaticNodes,\n            instanceNodes,\n            wrapClass\n          } = (0, _fields.buildFieldsInitNodes)(ref, path.node.superClass, props, privateNamesMap, state, setPublicClassFields != null ? setPublicClassFields : loose, privateFieldsAsProperties != null ? privateFieldsAsProperties : loose, constantSuper != null ? constantSuper : loose, innerBinding));\n        }\n\n        if (instanceNodes.length > 0) {\n          (0, _misc.injectInitialization)(path, constructor, instanceNodes, (referenceVisitor, state) => {\n            if (isDecorated) return;\n\n            for (const prop of props) {\n              if (prop.node.static) continue;\n              prop.traverse(referenceVisitor, state);\n            }\n          });\n        }\n\n        path = wrapClass(path);\n        path.insertBefore([...privateNamesNodes, ...keysNodes]);\n\n        if (staticNodes.length > 0) {\n          path.insertAfter(staticNodes);\n        }\n\n        if (pureStaticNodes.length > 0) {\n          path.find(parent => parent.isStatement() || parent.isDeclaration()).insertAfter(pureStaticNodes);\n        }\n      },\n\n      PrivateName(path) {\n        if (this.file.get(versionKey) !== version || path.parentPath.isPrivate({\n          key: path.node\n        })) {\n          return;\n        }\n\n        throw path.buildCodeFrameError(`Unknown PrivateName \"${path}\"`);\n      },\n\n      ExportDefaultDeclaration(path) {\n        if (this.file.get(versionKey) !== version) return;\n        const decl = path.get(\"declaration\");\n\n        if (decl.isClassDeclaration() && (0, _decorators.hasDecorators)(decl.node)) {\n          if (decl.node.id) {\n            (0, _helperSplitExportDeclaration.default)(path);\n          } else {\n            decl.node.type = \"ClassExpression\";\n          }\n        }\n      }\n\n    }\n  };\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildPrivateNamesMap = buildPrivateNamesMap;\nexports.buildPrivateNamesNodes = buildPrivateNamesNodes;\nexports.transformPrivateNamesUsage = transformPrivateNamesUsage;\nexports.buildFieldsInitNodes = buildFieldsInitNodes;\n\nvar _core = require(\"@babel/core\");\n\nvar _helperReplaceSupers = require(\"@babel/helper-replace-supers\");\n\nvar _helperMemberExpressionToFunctions = require(\"@babel/helper-member-expression-to-functions\");\n\nvar _helperOptimiseCallExpression = require(\"@babel/helper-optimise-call-expression\");\n\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\n\nvar ts = require(\"./typescript\");\n\nfunction buildPrivateNamesMap(props) {\n  const privateNamesMap = new Map();\n\n  for (const prop of props) {\n    const isPrivate = prop.isPrivate();\n    const isMethod = !prop.isProperty();\n    const isInstance = !prop.node.static;\n\n    if (isPrivate) {\n      const {\n        name\n      } = prop.node.key.id;\n      const update = privateNamesMap.has(name) ? privateNamesMap.get(name) : {\n        id: prop.scope.generateUidIdentifier(name),\n        static: !isInstance,\n        method: isMethod\n      };\n\n      if (prop.node.kind === \"get\") {\n        update.getId = prop.scope.generateUidIdentifier(`get_${name}`);\n      } else if (prop.node.kind === \"set\") {\n        update.setId = prop.scope.generateUidIdentifier(`set_${name}`);\n      } else if (prop.node.kind === \"method\") {\n        update.methodId = prop.scope.generateUidIdentifier(name);\n      }\n\n      privateNamesMap.set(name, update);\n    }\n  }\n\n  return privateNamesMap;\n}\n\nfunction buildPrivateNamesNodes(privateNamesMap, privateFieldsAsProperties, state) {\n  const initNodes = [];\n\n  for (const [name, value] of privateNamesMap) {\n    const {\n      static: isStatic,\n      method: isMethod,\n      getId,\n      setId\n    } = value;\n    const isAccessor = getId || setId;\n\n    const id = _core.types.cloneNode(value.id);\n\n    let init;\n\n    if (privateFieldsAsProperties) {\n      init = _core.types.callExpression(state.addHelper(\"classPrivateFieldLooseKey\"), [_core.types.stringLiteral(name)]);\n    } else if (!isStatic) {\n      init = _core.types.newExpression(_core.types.identifier(!isMethod || isAccessor ? \"WeakMap\" : \"WeakSet\"), []);\n    }\n\n    if (init) {\n      (0, _helperAnnotateAsPure.default)(init);\n      initNodes.push(_core.template.statement.ast`var ${id} = ${init}`);\n    }\n  }\n\n  return initNodes;\n}\n\nfunction privateNameVisitorFactory(visitor) {\n  const privateNameVisitor = Object.assign({}, visitor, {\n    Class(path) {\n      const {\n        privateNamesMap\n      } = this;\n      const body = path.get(\"body.body\");\n      const visiblePrivateNames = new Map(privateNamesMap);\n      const redeclared = [];\n\n      for (const prop of body) {\n        if (!prop.isPrivate()) continue;\n        const {\n          name\n        } = prop.node.key.id;\n        visiblePrivateNames.delete(name);\n        redeclared.push(name);\n      }\n\n      if (!redeclared.length) {\n        return;\n      }\n\n      path.get(\"body\").traverse(nestedVisitor, Object.assign({}, this, {\n        redeclared\n      }));\n      path.traverse(privateNameVisitor, Object.assign({}, this, {\n        privateNamesMap: visiblePrivateNames\n      }));\n      path.skipKey(\"body\");\n    }\n\n  });\n\n  const nestedVisitor = _core.traverse.visitors.merge([Object.assign({}, visitor), _helperReplaceSupers.environmentVisitor]);\n\n  return privateNameVisitor;\n}\n\nconst privateNameVisitor = privateNameVisitorFactory({\n  PrivateName(path, {\n    noDocumentAll\n  }) {\n    const {\n      privateNamesMap,\n      redeclared\n    } = this;\n    const {\n      node,\n      parentPath\n    } = path;\n\n    if (!parentPath.isMemberExpression({\n      property: node\n    }) && !parentPath.isOptionalMemberExpression({\n      property: node\n    })) {\n      return;\n    }\n\n    const {\n      name\n    } = node.id;\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared && redeclared.includes(name)) return;\n    this.handle(parentPath, noDocumentAll);\n  }\n\n});\nconst privateInVisitor = privateNameVisitorFactory({\n  BinaryExpression(path) {\n    const {\n      operator,\n      left,\n      right\n    } = path.node;\n    if (operator !== \"in\") return;\n    if (!path.get(\"left\").isPrivateName()) return;\n    const {\n      privateFieldsAsProperties,\n      privateNamesMap,\n      redeclared\n    } = this;\n    const {\n      name\n    } = left.id;\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared && redeclared.includes(name)) return;\n\n    if (privateFieldsAsProperties) {\n      const {\n        id\n      } = privateNamesMap.get(name);\n      path.replaceWith(_core.template.expression.ast`\n        Object.prototype.hasOwnProperty.call(${right}, ${_core.types.cloneNode(id)})\n      `);\n      return;\n    }\n\n    const {\n      id,\n      static: isStatic\n    } = privateNamesMap.get(name);\n\n    if (isStatic) {\n      path.replaceWith(_core.template.expression.ast`${right} === ${this.classRef}`);\n      return;\n    }\n\n    path.replaceWith(_core.template.expression.ast`${_core.types.cloneNode(id)}.has(${right})`);\n  }\n\n});\nconst privateNameHandlerSpec = {\n  memoise(member, count) {\n    const {\n      scope\n    } = member;\n    const {\n      object\n    } = member.node;\n    const memo = scope.maybeGenerateMemoised(object);\n\n    if (!memo) {\n      return;\n    }\n\n    this.memoiser.set(object, memo, count);\n  },\n\n  receiver(member) {\n    const {\n      object\n    } = member.node;\n\n    if (this.memoiser.has(object)) {\n      return _core.types.cloneNode(this.memoiser.get(object));\n    }\n\n    return _core.types.cloneNode(object);\n  },\n\n  get(member) {\n    const {\n      classRef,\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      methodId,\n      getId,\n      setId\n    } = privateNamesMap.get(name);\n    const isAccessor = getId || setId;\n\n    if (isStatic) {\n      const helperName = isMethod && !isAccessor ? \"classStaticPrivateMethodGet\" : \"classStaticPrivateFieldSpecGet\";\n      return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id)]);\n    }\n\n    if (isMethod) {\n      if (isAccessor) {\n        if (!getId && setId) {\n          if (file.availableHelper(\"writeOnlyError\")) {\n            return _core.types.sequenceExpression([this.receiver(member), _core.types.callExpression(file.addHelper(\"writeOnlyError\"), [_core.types.stringLiteral(`#${name}`)])]);\n          }\n\n          console.warn(`@babel/helpers is outdated, update it to silence this warning.`);\n        }\n\n        return _core.types.callExpression(file.addHelper(\"classPrivateFieldGet\"), [this.receiver(member), _core.types.cloneNode(id)]);\n      }\n\n      return _core.types.callExpression(file.addHelper(\"classPrivateMethodGet\"), [this.receiver(member), _core.types.cloneNode(id), _core.types.cloneNode(methodId)]);\n    }\n\n    return _core.types.callExpression(file.addHelper(\"classPrivateFieldGet\"), [this.receiver(member), _core.types.cloneNode(id)]);\n  },\n\n  boundGet(member) {\n    this.memoise(member, 1);\n    return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier(\"bind\")), [this.receiver(member)]);\n  },\n\n  set(member, value) {\n    const {\n      classRef,\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      setId,\n      getId\n    } = privateNamesMap.get(name);\n    const isAccessor = getId || setId;\n\n    if (isStatic) {\n      const helperName = isMethod && !isAccessor ? \"classStaticPrivateMethodSet\" : \"classStaticPrivateFieldSpecSet\";\n      return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id), value]);\n    }\n\n    if (isMethod) {\n      if (setId) {\n        return _core.types.callExpression(file.addHelper(\"classPrivateFieldSet\"), [this.receiver(member), _core.types.cloneNode(id), value]);\n      }\n\n      return _core.types.sequenceExpression([this.receiver(member), value, _core.types.callExpression(file.addHelper(\"readOnlyError\"), [_core.types.stringLiteral(`#${name}`)])]);\n    }\n\n    return _core.types.callExpression(file.addHelper(\"classPrivateFieldSet\"), [this.receiver(member), _core.types.cloneNode(id), value]);\n  },\n\n  destructureSet(member) {\n    const {\n      classRef,\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id,\n      static: isStatic\n    } = privateNamesMap.get(name);\n\n    if (isStatic) {\n      try {\n        var helper = file.addHelper(\"classStaticPrivateFieldDestructureSet\");\n      } catch (_unused) {\n        throw new Error(\"Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \\n\" + \"please update @babel/helpers to the latest version.\");\n      }\n\n      return _core.types.memberExpression(_core.types.callExpression(helper, [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id)]), _core.types.identifier(\"value\"));\n    }\n\n    return _core.types.memberExpression(_core.types.callExpression(file.addHelper(\"classPrivateFieldDestructureSet\"), [this.receiver(member), _core.types.cloneNode(id)]), _core.types.identifier(\"value\"));\n  },\n\n  call(member, args) {\n    this.memoise(member, 1);\n    return (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, false);\n  },\n\n  optionalCall(member, args) {\n    this.memoise(member, 1);\n    return (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, true);\n  }\n\n};\nconst privateNameHandlerLoose = {\n  get(member) {\n    const {\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      object\n    } = member.node;\n    const {\n      name\n    } = member.node.property.id;\n    return _core.template.expression`BASE(REF, PROP)[PROP]`({\n      BASE: file.addHelper(\"classPrivateFieldLooseBase\"),\n      REF: _core.types.cloneNode(object),\n      PROP: _core.types.cloneNode(privateNamesMap.get(name).id)\n    });\n  },\n\n  boundGet(member) {\n    return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier(\"bind\")), [_core.types.cloneNode(member.node.object)]);\n  },\n\n  simpleSet(member) {\n    return this.get(member);\n  },\n\n  destructureSet(member) {\n    return this.get(member);\n  },\n\n  call(member, args) {\n    return _core.types.callExpression(this.get(member), args);\n  },\n\n  optionalCall(member, args) {\n    return _core.types.optionalCallExpression(this.get(member), args, true);\n  }\n\n};\n\nfunction transformPrivateNamesUsage(ref, path, privateNamesMap, {\n  privateFieldsAsProperties,\n  noDocumentAll\n}, state) {\n  if (!privateNamesMap.size) return;\n  const body = path.get(\"body\");\n  const handler = privateFieldsAsProperties ? privateNameHandlerLoose : privateNameHandlerSpec;\n  (0, _helperMemberExpressionToFunctions.default)(body, privateNameVisitor, Object.assign({\n    privateNamesMap,\n    classRef: ref,\n    file: state\n  }, handler, {\n    noDocumentAll\n  }));\n  body.traverse(privateInVisitor, {\n    privateNamesMap,\n    classRef: ref,\n    file: state,\n    privateFieldsAsProperties\n  });\n}\n\nfunction buildPrivateFieldInitLoose(ref, prop, privateNamesMap) {\n  const {\n    id\n  } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.template.statement.ast`\n    Object.defineProperty(${ref}, ${_core.types.cloneNode(id)}, {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ${value}\n    });\n  `;\n}\n\nfunction buildPrivateInstanceFieldInitSpec(ref, prop, privateNamesMap) {\n  const {\n    id\n  } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.template.statement.ast`${_core.types.cloneNode(id)}.set(${ref}, {\n    // configurable is always false for private elements\n    // enumerable is always false for private elements\n    writable: true,\n    value: ${value},\n  })`;\n}\n\nfunction buildPrivateStaticFieldInitSpec(prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  const isAccessor = getId || setId;\n  if (!prop.isProperty() && (initAdded || !isAccessor)) return;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      var ${_core.types.cloneNode(id)} = {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      }\n    `;\n  }\n\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.template.statement.ast`\n    var ${_core.types.cloneNode(id)} = {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ${value}\n    };\n  `;\n}\n\nfunction buildPrivateMethodInitLoose(ref, prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    methodId,\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n\n  if (methodId) {\n    return _core.template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          value: ${methodId.name}\n        });\n      `;\n  }\n\n  const isAccessor = getId || setId;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      Object.defineProperty(${ref}, ${id}, {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      });\n    `;\n  }\n}\n\nfunction buildPrivateInstanceMethodInitSpec(ref, prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n  const isAccessor = getId || setId;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      ${id}.set(${ref}, {\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      });\n    `;\n  }\n\n  return _core.template.statement.ast`${id}.add(${ref})`;\n}\n\nfunction buildPublicFieldInitLoose(ref, prop) {\n  const {\n    key,\n    computed\n  } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(ref, key, computed || _core.types.isLiteral(key)), value));\n}\n\nfunction buildPublicFieldInitSpec(ref, prop, state) {\n  const {\n    key,\n    computed\n  } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.types.expressionStatement(_core.types.callExpression(state.addHelper(\"defineProperty\"), [ref, computed || _core.types.isLiteral(key) ? key : _core.types.stringLiteral(key.name), value]));\n}\n\nfunction buildPrivateStaticMethodInitLoose(ref, prop, state, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    methodId,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n  const isAccessor = getId || setId;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      Object.defineProperty(${ref}, ${id}, {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      })\n    `;\n  }\n\n  return _core.template.statement.ast`\n    Object.defineProperty(${ref}, ${id}, {\n      // configurable is false by default\n      // enumerable is false by default\n      // writable is false by default\n      value: ${methodId.name}\n    });\n  `;\n}\n\nfunction buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties = false) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    methodId,\n    getId,\n    setId,\n    getterDeclared,\n    setterDeclared,\n    static: isStatic\n  } = privateName;\n  const {\n    params,\n    body,\n    generator,\n    async\n  } = prop.node;\n  const isGetter = getId && !getterDeclared && params.length === 0;\n  const isSetter = setId && !setterDeclared && params.length > 0;\n  let declId = methodId;\n\n  if (isGetter) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      getterDeclared: true\n    }));\n    declId = getId;\n  } else if (isSetter) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      setterDeclared: true\n    }));\n    declId = setId;\n  } else if (isStatic && !privateFieldsAsProperties) {\n    declId = id;\n  }\n\n  return _core.types.functionDeclaration(_core.types.cloneNode(declId), params, body, generator, async);\n}\n\nconst thisContextVisitor = _core.traverse.visitors.merge([{\n  ThisExpression(path, state) {\n    state.needsClassRef = true;\n    path.replaceWith(_core.types.cloneNode(state.classRef));\n  }\n\n}, _helperReplaceSupers.environmentVisitor]);\n\nconst innerReferencesVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.scope.bindingIdentifierEquals(path.node.name, state.innerBinding)) {\n      state.needsClassRef = true;\n      path.node.name = state.classRef.name;\n    }\n  }\n\n};\n\nfunction replaceThisContext(path, ref, getSuperRef, file, isStaticBlock, constantSuper, innerBindingRef) {\n  var _state$classRef;\n\n  const state = {\n    classRef: ref,\n    needsClassRef: false,\n    innerBinding: innerBindingRef\n  };\n  const replacer = new _helperReplaceSupers.default({\n    methodPath: path,\n    constantSuper,\n    file,\n    refToPreserve: ref,\n    getSuperRef,\n\n    getObjectRef() {\n      state.needsClassRef = true;\n      return isStaticBlock || path.node.static ? ref : _core.types.memberExpression(ref, _core.types.identifier(\"prototype\"));\n    }\n\n  });\n  replacer.replace();\n\n  if (isStaticBlock || path.isProperty()) {\n    path.traverse(thisContextVisitor, state);\n  }\n\n  if ((_state$classRef = state.classRef) != null && _state$classRef.name && state.classRef.name !== (innerBindingRef == null ? void 0 : innerBindingRef.name)) {\n    path.traverse(innerReferencesVisitor, state);\n  }\n\n  return state.needsClassRef;\n}\n\nfunction buildFieldsInitNodes(ref, superRef, props, privateNamesMap, state, setPublicClassFields, privateFieldsAsProperties, constantSuper, innerBindingRef) {\n  let needsClassRef = false;\n  let injectSuperRef;\n  const staticNodes = [];\n  const instanceNodes = [];\n  const pureStaticNodes = [];\n  const getSuperRef = _core.types.isIdentifier(superRef) ? () => superRef : () => {\n    var _injectSuperRef;\n\n    (_injectSuperRef = injectSuperRef) != null ? _injectSuperRef : injectSuperRef = props[0].scope.generateUidIdentifierBasedOnNode(superRef);\n    return injectSuperRef;\n  };\n\n  for (const prop of props) {\n    ts.assertFieldTransformed(prop);\n    const isStatic = prop.node.static;\n    const isInstance = !isStatic;\n    const isPrivate = prop.isPrivate();\n    const isPublic = !isPrivate;\n    const isField = prop.isProperty();\n    const isMethod = !isField;\n    const isStaticBlock = prop.isStaticBlock == null ? void 0 : prop.isStaticBlock();\n\n    if (isStatic || isMethod && isPrivate || isStaticBlock) {\n      const replaced = replaceThisContext(prop, ref, getSuperRef, state, isStaticBlock, constantSuper, innerBindingRef);\n      needsClassRef = needsClassRef || replaced;\n    }\n\n    switch (true) {\n      case isStaticBlock:\n        staticNodes.push(_core.template.statement.ast`(() => ${_core.types.blockStatement(prop.node.body)})()`);\n        break;\n\n      case isStatic && isPrivate && isField && privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateFieldInitLoose(_core.types.cloneNode(ref), prop, privateNamesMap));\n        break;\n\n      case isStatic && isPrivate && isField && !privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));\n        break;\n\n      case isStatic && isPublic && isField && setPublicClassFields:\n        needsClassRef = true;\n        staticNodes.push(buildPublicFieldInitLoose(_core.types.cloneNode(ref), prop));\n        break;\n\n      case isStatic && isPublic && isField && !setPublicClassFields:\n        needsClassRef = true;\n        staticNodes.push(buildPublicFieldInitSpec(_core.types.cloneNode(ref), prop, state));\n        break;\n\n      case isInstance && isPrivate && isField && privateFieldsAsProperties:\n        instanceNodes.push(buildPrivateFieldInitLoose(_core.types.thisExpression(), prop, privateNamesMap));\n        break;\n\n      case isInstance && isPrivate && isField && !privateFieldsAsProperties:\n        instanceNodes.push(buildPrivateInstanceFieldInitSpec(_core.types.thisExpression(), prop, privateNamesMap));\n        break;\n\n      case isInstance && isPrivate && isMethod && privateFieldsAsProperties:\n        instanceNodes.unshift(buildPrivateMethodInitLoose(_core.types.thisExpression(), prop, privateNamesMap));\n        pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));\n        break;\n\n      case isInstance && isPrivate && isMethod && !privateFieldsAsProperties:\n        instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(_core.types.thisExpression(), prop, privateNamesMap));\n        pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));\n        break;\n\n      case isStatic && isPrivate && isMethod && !privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.unshift(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));\n        pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));\n        break;\n\n      case isStatic && isPrivate && isMethod && privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.unshift(buildPrivateStaticMethodInitLoose(_core.types.cloneNode(ref), prop, state, privateNamesMap));\n        pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));\n        break;\n\n      case isInstance && isPublic && isField && setPublicClassFields:\n        instanceNodes.push(buildPublicFieldInitLoose(_core.types.thisExpression(), prop));\n        break;\n\n      case isInstance && isPublic && isField && !setPublicClassFields:\n        instanceNodes.push(buildPublicFieldInitSpec(_core.types.thisExpression(), prop, state));\n        break;\n\n      default:\n        throw new Error(\"Unreachable.\");\n    }\n  }\n\n  return {\n    staticNodes: staticNodes.filter(Boolean),\n    instanceNodes: instanceNodes.filter(Boolean),\n    pureStaticNodes: pureStaticNodes.filter(Boolean),\n\n    wrapClass(path) {\n      for (const prop of props) {\n        prop.remove();\n      }\n\n      if (injectSuperRef) {\n        path.scope.push({\n          id: _core.types.cloneNode(injectSuperRef)\n        });\n        path.set(\"superClass\", _core.types.assignmentExpression(\"=\", injectSuperRef, path.node.superClass));\n      }\n\n      if (!needsClassRef) return path;\n\n      if (path.isClassExpression()) {\n        path.scope.push({\n          id: ref\n        });\n        path.replaceWith(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(ref), path.node));\n      } else if (!path.node.id) {\n        path.node.id = ref;\n      }\n\n      return path;\n    }\n\n  };\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertFieldTransformed = assertFieldTransformed;\n\nfunction assertFieldTransformed(path) {\n  if (path.node.declare) {\n    throw path.buildCodeFrameError(`TypeScript 'declare' fields must first be transformed by ` + `@babel/plugin-transform-typescript.\\n` + `If you have already enabled that plugin (or '@babel/preset-typescript'), make sure ` + `that it runs before any plugin related to additional class features:\\n` + ` - @babel/plugin-proposal-class-properties\\n` + ` - @babel/plugin-proposal-private-methods\\n` + ` - @babel/plugin-proposal-decorators`);\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasOwnDecorators = hasOwnDecorators;\nexports.hasDecorators = hasDecorators;\nexports.buildDecoratedClass = buildDecoratedClass;\n\nvar _core = require(\"@babel/core\");\n\nvar _helperReplaceSupers = require(\"@babel/helper-replace-supers\");\n\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\n\nfunction hasOwnDecorators(node) {\n  return !!(node.decorators && node.decorators.length);\n}\n\nfunction hasDecorators(node) {\n  return hasOwnDecorators(node) || node.body.body.some(hasOwnDecorators);\n}\n\nfunction prop(key, value) {\n  if (!value) return null;\n  return _core.types.objectProperty(_core.types.identifier(key), value);\n}\n\nfunction method(key, body) {\n  return _core.types.objectMethod(\"method\", _core.types.identifier(key), [], _core.types.blockStatement(body));\n}\n\nfunction takeDecorators(node) {\n  let result;\n\n  if (node.decorators && node.decorators.length > 0) {\n    result = _core.types.arrayExpression(node.decorators.map(decorator => decorator.expression));\n  }\n\n  node.decorators = undefined;\n  return result;\n}\n\nfunction getKey(node) {\n  if (node.computed) {\n    return node.key;\n  } else if (_core.types.isIdentifier(node.key)) {\n    return _core.types.stringLiteral(node.key.name);\n  } else {\n    return _core.types.stringLiteral(String(node.key.value));\n  }\n}\n\nfunction extractElementDescriptor(classRef, superRef, path) {\n  const {\n    node,\n    scope\n  } = path;\n  const isMethod = path.isClassMethod();\n\n  if (path.isPrivate()) {\n    throw path.buildCodeFrameError(`Private ${isMethod ? \"methods\" : \"fields\"} in decorated classes are not supported yet.`);\n  }\n\n  new _helperReplaceSupers.default({\n    methodPath: path,\n    objectRef: classRef,\n    superRef,\n    file: this,\n    refToPreserve: classRef\n  }).replace();\n  const properties = [prop(\"kind\", _core.types.stringLiteral(isMethod ? node.kind : \"field\")), prop(\"decorators\", takeDecorators(node)), prop(\"static\", node.static && _core.types.booleanLiteral(true)), prop(\"key\", getKey(node))].filter(Boolean);\n\n  if (isMethod) {\n    const id = node.computed ? null : node.key;\n\n    _core.types.toExpression(node);\n\n    properties.push(prop(\"value\", (0, _helperFunctionName.default)({\n      node,\n      id,\n      scope\n    }) || node));\n  } else if (node.value) {\n    properties.push(method(\"value\", _core.template.statements.ast`return ${node.value}`));\n  } else {\n    properties.push(prop(\"value\", scope.buildUndefinedNode()));\n  }\n\n  path.remove();\n  return _core.types.objectExpression(properties);\n}\n\nfunction addDecorateHelper(file) {\n  try {\n    return file.addHelper(\"decorate\");\n  } catch (err) {\n    if (err.code === \"BABEL_HELPER_UNKNOWN\") {\n      err.message += \"\\n  '@babel/plugin-transform-decorators' in non-legacy mode\" + \" requires '@babel/core' version ^7.0.2 and you appear to be using\" + \" an older version.\";\n    }\n\n    throw err;\n  }\n}\n\nfunction buildDecoratedClass(ref, path, elements, file) {\n  const {\n    node,\n    scope\n  } = path;\n  const initializeId = scope.generateUidIdentifier(\"initialize\");\n  const isDeclaration = node.id && path.isDeclaration();\n  const isStrict = path.isInStrictMode();\n  const {\n    superClass\n  } = node;\n  node.type = \"ClassDeclaration\";\n  if (!node.id) node.id = _core.types.cloneNode(ref);\n  let superId;\n\n  if (superClass) {\n    superId = scope.generateUidIdentifierBasedOnNode(node.superClass, \"super\");\n    node.superClass = superId;\n  }\n\n  const classDecorators = takeDecorators(node);\n\n  const definitions = _core.types.arrayExpression(elements.filter(element => !element.node.abstract).map(extractElementDescriptor.bind(file, node.id, superId)));\n\n  const wrapperCall = _core.template.expression.ast`\n    ${addDecorateHelper(file)}(\n      ${classDecorators || _core.types.nullLiteral()},\n      function (${initializeId}, ${superClass ? _core.types.cloneNode(superId) : null}) {\n        ${node}\n        return { F: ${_core.types.cloneNode(node.id)}, d: ${definitions} };\n      },\n      ${superClass}\n    )\n  `;\n\n  if (!isStrict) {\n    wrapperCall.arguments[1].body.directives.push(_core.types.directive(_core.types.directiveLiteral(\"use strict\")));\n  }\n\n  let replacement = wrapperCall;\n  let classPathDesc = \"arguments.1.body.body.0\";\n\n  if (isDeclaration) {\n    replacement = _core.template.statement.ast`let ${ref} = ${wrapperCall}`;\n    classPathDesc = \"declarations.0.init.\" + classPathDesc;\n  }\n\n  return {\n    instanceNodes: [_core.template.statement.ast`${_core.types.cloneNode(initializeId)}(this)`],\n\n    wrapClass(path) {\n      path.replaceWith(replacement);\n      return path.get(classPathDesc);\n    }\n\n  };\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.injectInitialization = injectInitialization;\nexports.extractComputedKeys = extractComputedKeys;\n\nvar _core = require(\"@babel/core\");\n\nvar _helperReplaceSupers = require(\"@babel/helper-replace-supers\");\n\nconst findBareSupers = _core.traverse.visitors.merge([{\n  Super(path) {\n    const {\n      node,\n      parentPath\n    } = path;\n\n    if (parentPath.isCallExpression({\n      callee: node\n    })) {\n      this.push(parentPath);\n    }\n  }\n\n}, _helperReplaceSupers.environmentVisitor]);\n\nconst referenceVisitor = {\n  \"TSTypeAnnotation|TypeAnnotation\"(path) {\n    path.skip();\n  },\n\n  ReferencedIdentifier(path) {\n    if (this.scope.hasOwnBinding(path.node.name)) {\n      this.scope.rename(path.node.name);\n      path.skip();\n    }\n  }\n\n};\n\nfunction handleClassTDZ(path, state) {\n  if (state.classBinding && state.classBinding === path.scope.getBinding(path.node.name)) {\n    const classNameTDZError = state.file.addHelper(\"classNameTDZError\");\n\n    const throwNode = _core.types.callExpression(classNameTDZError, [_core.types.stringLiteral(path.node.name)]);\n\n    path.replaceWith(_core.types.sequenceExpression([throwNode, path.node]));\n    path.skip();\n  }\n}\n\nconst classFieldDefinitionEvaluationTDZVisitor = {\n  ReferencedIdentifier: handleClassTDZ\n};\n\nfunction injectInitialization(path, constructor, nodes, renamer) {\n  if (!nodes.length) return;\n  const isDerived = !!path.node.superClass;\n\n  if (!constructor) {\n    const newConstructor = _core.types.classMethod(\"constructor\", _core.types.identifier(\"constructor\"), [], _core.types.blockStatement([]));\n\n    if (isDerived) {\n      newConstructor.params = [_core.types.restElement(_core.types.identifier(\"args\"))];\n      newConstructor.body.body.push(_core.template.statement.ast`super(...args)`);\n    }\n\n    [constructor] = path.get(\"body\").unshiftContainer(\"body\", newConstructor);\n  }\n\n  if (renamer) {\n    renamer(referenceVisitor, {\n      scope: constructor.scope\n    });\n  }\n\n  if (isDerived) {\n    const bareSupers = [];\n    constructor.traverse(findBareSupers, bareSupers);\n    let isFirst = true;\n\n    for (const bareSuper of bareSupers) {\n      if (isFirst) {\n        bareSuper.insertAfter(nodes);\n        isFirst = false;\n      } else {\n        bareSuper.insertAfter(nodes.map(n => _core.types.cloneNode(n)));\n      }\n    }\n  } else {\n    constructor.get(\"body\").unshiftContainer(\"body\", nodes);\n  }\n}\n\nfunction extractComputedKeys(ref, path, computedPaths, file) {\n  const declarations = [];\n  const state = {\n    classBinding: path.node.id && path.scope.getBinding(path.node.id.name),\n    file\n  };\n\n  for (const computedPath of computedPaths) {\n    const computedKey = computedPath.get(\"key\");\n\n    if (computedKey.isReferencedIdentifier()) {\n      handleClassTDZ(computedKey, state);\n    } else {\n      computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);\n    }\n\n    const computedNode = computedPath.node;\n\n    if (!computedKey.isConstantExpression()) {\n      const ident = path.scope.generateUidIdentifierBasedOnNode(computedNode.key);\n      path.scope.push({\n        id: ident,\n        kind: \"let\"\n      });\n      declarations.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(ident), computedNode.key)));\n      computedNode.key = _core.types.cloneNode(ident);\n    }\n  }\n\n  return declarations;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.enableFeature = enableFeature;\nexports.isLoose = isLoose;\nexports.verifyUsedFeatures = verifyUsedFeatures;\nexports.FEATURES = void 0;\n\nvar _decorators = require(\"./decorators\");\n\nconst FEATURES = Object.freeze({\n  fields: 1 << 1,\n  privateMethods: 1 << 2,\n  decorators: 1 << 3,\n  privateIn: 1 << 4,\n  staticBlocks: 1 << 5\n});\nexports.FEATURES = FEATURES;\nconst featuresSameLoose = new Map([[FEATURES.fields, \"@babel/plugin-proposal-class-properties\"], [FEATURES.privateMethods, \"@babel/plugin-proposal-private-methods\"], [FEATURES.privateIn, \"@babel/plugin-proposal-private-property-in-object\"]]);\nconst featuresKey = \"@babel/plugin-class-features/featuresKey\";\nconst looseKey = \"@babel/plugin-class-features/looseKey\";\nconst looseLowPriorityKey = \"@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing\";\n\nfunction enableFeature(file, feature, loose) {\n  if (!hasFeature(file, feature) || canIgnoreLoose(file, feature)) {\n    file.set(featuresKey, file.get(featuresKey) | feature);\n\n    if (loose === \"#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error\") {\n      setLoose(file, feature, true);\n      file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature);\n    } else if (loose === \"#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error\") {\n      setLoose(file, feature, false);\n      file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature);\n    } else {\n      setLoose(file, feature, loose);\n    }\n  }\n\n  let resolvedLoose;\n  let higherPriorityPluginName;\n\n  for (const [mask, name] of featuresSameLoose) {\n    if (!hasFeature(file, mask)) continue;\n    const loose = isLoose(file, mask);\n\n    if (canIgnoreLoose(file, mask)) {\n      continue;\n    } else if (resolvedLoose === !loose) {\n      throw new Error(\"'loose' mode configuration must be the same for @babel/plugin-proposal-class-properties, \" + \"@babel/plugin-proposal-private-methods and \" + \"@babel/plugin-proposal-private-property-in-object (when they are enabled).\");\n    } else {\n      resolvedLoose = loose;\n      higherPriorityPluginName = name;\n    }\n  }\n\n  if (resolvedLoose !== undefined) {\n    for (const [mask, name] of featuresSameLoose) {\n      if (hasFeature(file, mask) && isLoose(file, mask) !== resolvedLoose) {\n        setLoose(file, mask, resolvedLoose);\n        console.warn(`Though the \"loose\" option was set to \"${!resolvedLoose}\" in your @babel/preset-env ` + `config, it will not be used for ${name} since the \"loose\" mode option was set to ` + `\"${resolvedLoose}\" for ${higherPriorityPluginName}.\\nThe \"loose\" option must be the ` + `same for @babel/plugin-proposal-class-properties, @babel/plugin-proposal-private-methods ` + `and @babel/plugin-proposal-private-property-in-object (when they are enabled): you can ` + `silence this warning by explicitly adding\\n` + `\\t[\"${name}\", { \"loose\": ${resolvedLoose} }]\\n` + `to the \"plugins\" section of your Babel config.`);\n      }\n    }\n  }\n}\n\nfunction hasFeature(file, feature) {\n  return !!(file.get(featuresKey) & feature);\n}\n\nfunction isLoose(file, feature) {\n  return !!(file.get(looseKey) & feature);\n}\n\nfunction setLoose(file, feature, loose) {\n  if (loose) file.set(looseKey, file.get(looseKey) | feature);else file.set(looseKey, file.get(looseKey) & ~feature);\n  file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) & ~feature);\n}\n\nfunction canIgnoreLoose(file, feature) {\n  return !!(file.get(looseLowPriorityKey) & feature);\n}\n\nfunction verifyUsedFeatures(path, file) {\n  if ((0, _decorators.hasOwnDecorators)(path.node)) {\n    if (!hasFeature(file, FEATURES.decorators)) {\n      throw path.buildCodeFrameError(\"Decorators are not enabled.\" + \"\\nIf you are using \" + '[\"@babel/plugin-proposal-decorators\", { \"legacy\": true }], ' + 'make sure it comes *before* \"@babel/plugin-proposal-class-properties\" ' + \"and enable loose mode, like so:\\n\" + '\\t[\"@babel/plugin-proposal-decorators\", { \"legacy\": true }]\\n' + '\\t[\"@babel/plugin-proposal-class-properties\", { \"loose\": true }]');\n    }\n\n    if (path.isPrivate()) {\n      throw path.buildCodeFrameError(`Private ${path.isClassMethod() ? \"methods\" : \"fields\"} in decorated classes are not supported yet.`);\n    }\n  }\n\n  if (path.isPrivateMethod != null && path.isPrivateMethod()) {\n    if (!hasFeature(file, FEATURES.privateMethods)) {\n      throw path.buildCodeFrameError(\"Class private methods are not enabled.\");\n    }\n  }\n\n  if (path.isPrivateName() && path.parentPath.isBinaryExpression({\n    operator: \"in\",\n    left: path.node\n  })) {\n    if (!hasFeature(file, FEATURES.privateIn)) {\n      throw path.buildCodeFrameError(\"Private property in checks are not enabled.\");\n    }\n  }\n\n  if (path.isProperty()) {\n    if (!hasFeature(file, FEATURES.fields)) {\n      throw path.buildCodeFrameError(\"Class fields are not enabled.\");\n    }\n  }\n\n  if (path.isStaticBlock != null && path.isStaticBlock()) {\n    if (!hasFeature(file, FEATURES.staticBlocks)) {\n      throw path.buildCodeFrameError(\"Static class blocks are not enabled. \" + \"Please add `@babel/plugin-proposal-class-static-block` to your configuration.\");\n    }\n  }\n}"]}