{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _helperPluginUtils() {\n  const data = require(\"@babel/helper-plugin-utils\");\n\n  _helperPluginUtils = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _pluginSyntaxOptionalChaining() {\n  const data = _interopRequireDefault(require(\"@babel/plugin-syntax-optional-chaining\"));\n\n  _pluginSyntaxOptionalChaining = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _core() {\n  const data = require(\"@babel/core\");\n\n  _core = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _default = (0, _helperPluginUtils().declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    loose = false\n  } = options;\n  return {\n    name: \"proposal-optional-chaining\",\n    inherits: _pluginSyntaxOptionalChaining().default,\n    visitor: {\n      \"OptionalCallExpression|OptionalMemberExpression\"(path) {\n        const {\n          parentPath,\n          scope\n        } = path;\n        const optionals = [];\n        let optionalPath = path;\n\n        while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {\n          const {\n            node\n          } = optionalPath;\n\n          if (node.optional) {\n            optionals.push(node);\n          }\n\n          if (optionalPath.isOptionalMemberExpression()) {\n            optionalPath.node.type = \"MemberExpression\";\n            optionalPath = optionalPath.get(\"object\");\n          } else if (optionalPath.isOptionalCallExpression()) {\n            optionalPath.node.type = \"CallExpression\";\n            optionalPath = optionalPath.get(\"callee\");\n          }\n        }\n\n        let replacementPath = path;\n\n        if (parentPath.isUnaryExpression({\n          operator: \"delete\"\n        })) {\n          replacementPath = parentPath;\n        }\n\n        for (let i = optionals.length - 1; i >= 0; i--) {\n          const node = optionals[i];\n\n          const isCall = _core().types.isCallExpression(node);\n\n          const replaceKey = isCall ? \"callee\" : \"object\";\n          const chain = node[replaceKey];\n          let ref;\n          let check;\n\n          if (loose && isCall) {\n            check = ref = chain;\n          } else {\n            ref = scope.maybeGenerateMemoised(chain);\n\n            if (ref) {\n              check = _core().types.assignmentExpression(\"=\", _core().types.cloneNode(ref), chain);\n              node[replaceKey] = ref;\n            } else {\n              check = ref = chain;\n            }\n          }\n\n          if (isCall && _core().types.isMemberExpression(chain)) {\n            if (loose) {\n              node.callee = chain;\n            } else {\n              const {\n                object\n              } = chain;\n              let context = scope.maybeGenerateMemoised(object);\n\n              if (context) {\n                chain.object = _core().types.assignmentExpression(\"=\", context, object);\n              } else {\n                context = object;\n              }\n\n              node.arguments.unshift(_core().types.cloneNode(context));\n              node.callee = _core().types.memberExpression(node.callee, _core().types.identifier(\"call\"));\n            }\n          }\n\n          replacementPath.replaceWith(_core().types.conditionalExpression(loose ? _core().types.binaryExpression(\"==\", _core().types.cloneNode(check), _core().types.nullLiteral()) : _core().types.logicalExpression(\"||\", _core().types.binaryExpression(\"===\", _core().types.cloneNode(check), _core().types.nullLiteral()), _core().types.binaryExpression(\"===\", _core().types.cloneNode(ref), scope.buildUndefinedNode())), scope.buildUndefinedNode(), replacementPath.node));\n          replacementPath = replacementPath.get(\"alternate\");\n        }\n      }\n\n    }\n  };\n});\n\nexports.default = _default;"]}