{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  var _api$assumption, _api$assumption2;\n\n  api.assertVersion(7);\n  const ignoreToPrimitiveHint = (_api$assumption = api.assumption(\"ignoreToPrimitiveHint\")) != null ? _api$assumption : options.loose;\n  const mutableTemplateObject = (_api$assumption2 = api.assumption(\"mutableTemplateObject\")) != null ? _api$assumption2 : options.loose;\n  let helperName = \"taggedTemplateLiteral\";\n  if (mutableTemplateObject) helperName += \"Loose\";\n\n  function buildConcatCallExpressions(items) {\n    let avail = true;\n    return items.reduce(function (left, right) {\n      let canBeInserted = _core.types.isLiteral(right);\n\n      if (!canBeInserted && avail) {\n        canBeInserted = true;\n        avail = false;\n      }\n\n      if (canBeInserted && _core.types.isCallExpression(left)) {\n        left.arguments.push(right);\n        return left;\n      }\n\n      return _core.types.callExpression(_core.types.memberExpression(left, _core.types.identifier(\"concat\")), [right]);\n    });\n  }\n\n  return {\n    name: \"transform-template-literals\",\n    visitor: {\n      TaggedTemplateExpression(path) {\n        const {\n          node\n        } = path;\n        const {\n          quasi\n        } = node;\n        const strings = [];\n        const raws = [];\n        let isStringsRawEqual = true;\n\n        for (const elem of quasi.quasis) {\n          const {\n            raw,\n            cooked\n          } = elem.value;\n          const value = cooked == null ? path.scope.buildUndefinedNode() : _core.types.stringLiteral(cooked);\n          strings.push(value);\n          raws.push(_core.types.stringLiteral(raw));\n\n          if (raw !== cooked) {\n            isStringsRawEqual = false;\n          }\n        }\n\n        const helperArgs = [_core.types.arrayExpression(strings)];\n\n        if (!isStringsRawEqual) {\n          helperArgs.push(_core.types.arrayExpression(raws));\n        }\n\n        const tmp = path.scope.generateUidIdentifier(\"templateObject\");\n        path.scope.getProgramParent().push({\n          id: _core.types.cloneNode(tmp)\n        });\n        path.replaceWith(_core.types.callExpression(node.tag, [_core.template.expression.ast`\n              ${_core.types.cloneNode(tmp)} || (\n                ${tmp} = ${this.addHelper(helperName)}(${helperArgs})\n              )\n            `, ...quasi.expressions]));\n      },\n\n      TemplateLiteral(path) {\n        const nodes = [];\n        const expressions = path.get(\"expressions\");\n        let index = 0;\n\n        for (const elem of path.node.quasis) {\n          if (elem.value.cooked) {\n            nodes.push(_core.types.stringLiteral(elem.value.cooked));\n          }\n\n          if (index < expressions.length) {\n            const expr = expressions[index++];\n            const node = expr.node;\n\n            if (!_core.types.isStringLiteral(node, {\n              value: \"\"\n            })) {\n              nodes.push(node);\n            }\n          }\n        }\n\n        if (!_core.types.isStringLiteral(nodes[0]) && !(ignoreToPrimitiveHint && _core.types.isStringLiteral(nodes[1]))) {\n          nodes.unshift(_core.types.stringLiteral(\"\"));\n        }\n\n        let root = nodes[0];\n\n        if (ignoreToPrimitiveHint) {\n          for (let i = 1; i < nodes.length; i++) {\n            root = _core.types.binaryExpression(\"+\", root, nodes[i]);\n          }\n        } else if (nodes.length > 1) {\n          root = buildConcatCallExpressions(nodes);\n        }\n\n        path.replaceWith(root);\n      }\n\n    }\n  };\n});\n\nexports.default = _default;"]}