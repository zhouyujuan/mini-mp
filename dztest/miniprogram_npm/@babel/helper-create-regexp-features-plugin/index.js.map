{"version":3,"sources":["index.js","features.js","util.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createRegExpFeaturePlugin = createRegExpFeaturePlugin;\n\nvar _regexpuCore = require(\"regexpu-core\");\n\nvar _features = require(\"./features\");\n\nvar _util = require(\"./util\");\n\nvar _core = require(\"@babel/core\");\n\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\n\nfunction pullFlag(node, flag) {\n  node.flags = node.flags.replace(flag, \"\");\n}\n\nconst version = \"7.14.5\".split(\".\").reduce((v, x) => v * 1e5 + +x, 0);\nconst versionKey = \"@babel/plugin-regexp-features/version\";\n\nfunction createRegExpFeaturePlugin({\n  name,\n  feature,\n  options = {}\n}) {\n  return {\n    name,\n\n    pre() {\n      var _file$get;\n\n      const {\n        file\n      } = this;\n      const features = (_file$get = file.get(_features.featuresKey)) != null ? _file$get : 0;\n      let newFeatures = (0, _features.enableFeature)(features, _features.FEATURES[feature]);\n      const {\n        useUnicodeFlag,\n        runtime = true\n      } = options;\n\n      if (useUnicodeFlag === false) {\n        newFeatures = (0, _features.enableFeature)(newFeatures, _features.FEATURES.unicodeFlag);\n      }\n\n      if (newFeatures !== features) {\n        file.set(_features.featuresKey, newFeatures);\n      }\n\n      if (!runtime) {\n        file.set(_features.runtimeKey, false);\n      }\n\n      if (!file.has(versionKey) || file.get(versionKey) < version) {\n        file.set(versionKey, version);\n      }\n    },\n\n    visitor: {\n      RegExpLiteral(path) {\n        var _file$get2;\n\n        const {\n          node\n        } = path;\n        const {\n          file\n        } = this;\n        const features = file.get(_features.featuresKey);\n        const runtime = (_file$get2 = file.get(_features.runtimeKey)) != null ? _file$get2 : true;\n        const regexpuOptions = (0, _util.generateRegexpuOptions)(node, features);\n\n        if (regexpuOptions === null) {\n          return;\n        }\n\n        const namedCaptureGroups = {};\n\n        if (regexpuOptions.namedGroup) {\n          regexpuOptions.onNamedGroup = (name, index) => {\n            namedCaptureGroups[name] = index;\n          };\n        }\n\n        node.pattern = _regexpuCore(node.pattern, node.flags, regexpuOptions);\n\n        if (regexpuOptions.namedGroup && Object.keys(namedCaptureGroups).length > 0 && runtime && !isRegExpTest(path)) {\n          const call = _core.types.callExpression(this.addHelper(\"wrapRegExp\"), [node, _core.types.valueToNode(namedCaptureGroups)]);\n\n          (0, _helperAnnotateAsPure.default)(call);\n          path.replaceWith(call);\n        }\n\n        if ((0, _features.hasFeature)(features, _features.FEATURES.unicodeFlag)) {\n          pullFlag(node, \"u\");\n        }\n\n        if ((0, _features.hasFeature)(features, _features.FEATURES.dotAllFlag)) {\n          pullFlag(node, \"s\");\n        }\n      }\n\n    }\n  };\n}\n\nfunction isRegExpTest(path) {\n  return path.parentPath.isMemberExpression({\n    object: path.node,\n    computed: false\n  }) && path.parentPath.get(\"property\").isIdentifier({\n    name: \"test\"\n  });\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.enableFeature = enableFeature;\nexports.hasFeature = hasFeature;\nexports.runtimeKey = exports.featuresKey = exports.FEATURES = void 0;\nconst FEATURES = Object.freeze({\n  unicodeFlag: 1 << 0,\n  dotAllFlag: 1 << 1,\n  unicodePropertyEscape: 1 << 2,\n  namedCaptureGroups: 1 << 3\n});\nexports.FEATURES = FEATURES;\nconst featuresKey = \"@babel/plugin-regexp-features/featuresKey\";\nexports.featuresKey = featuresKey;\nconst runtimeKey = \"@babel/plugin-regexp-features/runtimeKey\";\nexports.runtimeKey = runtimeKey;\n\nfunction enableFeature(features, feature) {\n  return features | feature;\n}\n\nfunction hasFeature(features, feature) {\n  return !!(features & feature);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateRegexpuOptions = generateRegexpuOptions;\n\nvar _features = require(\"./features\");\n\nfunction generateRegexpuOptions(node, features) {\n  let useUnicodeFlag = false,\n      dotAllFlag = false,\n      unicodePropertyEscape = false,\n      namedGroup = false;\n  const {\n    flags,\n    pattern\n  } = node;\n  const flagsIncludesU = flags.includes(\"u\");\n\n  if (flagsIncludesU) {\n    if (!(0, _features.hasFeature)(features, _features.FEATURES.unicodeFlag)) {\n      useUnicodeFlag = true;\n    }\n\n    if ((0, _features.hasFeature)(features, _features.FEATURES.unicodePropertyEscape) && /\\\\[pP]{/.test(pattern)) {\n      unicodePropertyEscape = true;\n    }\n  }\n\n  if ((0, _features.hasFeature)(features, _features.FEATURES.dotAllFlag) && flags.indexOf(\"s\") >= 0) {\n    dotAllFlag = true;\n  }\n\n  if ((0, _features.hasFeature)(features, _features.FEATURES.namedCaptureGroups) && /\\(\\?<(?![=!])/.test(pattern)) {\n    namedGroup = true;\n  }\n\n  if (!namedGroup && !unicodePropertyEscape && !dotAllFlag && (!flagsIncludesU || useUnicodeFlag)) {\n    return null;\n  }\n\n  if (flagsIncludesU && flags.indexOf(\"s\") >= 0) {\n    dotAllFlag = true;\n  }\n\n  return {\n    useUnicodeFlag,\n    onNamedGroup: () => {},\n    namedGroup,\n    unicodePropertyEscape,\n    dotAllFlag,\n    lookbehind: true\n  };\n}"]}