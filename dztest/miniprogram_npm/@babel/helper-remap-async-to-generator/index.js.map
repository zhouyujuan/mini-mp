{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _helperWrapFunction = require(\"@babel/helper-wrap-function\");\n\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\n\nvar t = require(\"@babel/types\");\n\nconst awaitVisitor = {\n  Function(path) {\n    path.skip();\n  },\n\n  AwaitExpression(path, {\n    wrapAwait\n  }) {\n    const argument = path.get(\"argument\");\n\n    if (path.parentPath.isYieldExpression()) {\n      path.replaceWith(argument.node);\n      return;\n    }\n\n    path.replaceWith(t.yieldExpression(wrapAwait ? t.callExpression(t.cloneNode(wrapAwait), [argument.node]) : argument.node));\n  }\n\n};\n\nfunction _default(path, helpers, noNewArrows) {\n  path.traverse(awaitVisitor, {\n    wrapAwait: helpers.wrapAwait\n  });\n  const isIIFE = checkIsIIFE(path);\n  path.node.async = false;\n  path.node.generator = true;\n  (0, _helperWrapFunction.default)(path, t.cloneNode(helpers.wrapAsync), noNewArrows);\n  const isProperty = path.isObjectMethod() || path.isClassMethod() || path.parentPath.isObjectProperty() || path.parentPath.isClassProperty();\n\n  if (!isProperty && !isIIFE && path.isExpression()) {\n    (0, _helperAnnotateAsPure.default)(path);\n  }\n\n  function checkIsIIFE(path) {\n    if (path.parentPath.isCallExpression({\n      callee: path.node\n    })) {\n      return true;\n    }\n\n    const {\n      parentPath\n    } = path;\n\n    if (parentPath.isMemberExpression() && t.isIdentifier(parentPath.node.property, {\n      name: \"bind\"\n    })) {\n      const {\n        parentPath: bindCall\n      } = parentPath;\n      return bindCall.isCallExpression() && bindCall.node.arguments.length === 1 && t.isThisExpression(bindCall.node.arguments[0]) && bindCall.parentPath.isCallExpression({\n        callee: bindCall.node\n      });\n    }\n\n    return false;\n  }\n}"]}