{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getExportSpecifierName = getExportSpecifierName;\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _helperHoistVariables = require(\"@babel/helper-hoist-variables\");\n\nvar _core = require(\"@babel/core\");\n\nvar _utils = require(\"babel-plugin-dynamic-import-node/utils\");\n\nvar _helperModuleTransforms = require(\"@babel/helper-module-transforms\");\n\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\n\nconst buildTemplate = (0, _core.template)(`\n  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {\n    \"use strict\";\n    BEFORE_BODY;\n    return {\n      setters: SETTERS,\n      execute: EXECUTE,\n    };\n  });\n`);\nconst buildExportAll = (0, _core.template)(`\n  for (var KEY in TARGET) {\n    if (KEY !== \"default\" && KEY !== \"__esModule\") EXPORT_OBJ[KEY] = TARGET[KEY];\n  }\n`);\nconst MISSING_PLUGIN_WARNING = `\\\nWARNING: Dynamic import() transformation must be enabled using the\n         @babel/plugin-proposal-dynamic-import plugin. Babel 8 will\n         no longer transform import() without using that plugin.\n`;\nconst MISSING_PLUGIN_ERROR = `\\\nERROR: Dynamic import() transformation must be enabled using the\n       @babel/plugin-proposal-dynamic-import plugin. Babel 8\n       no longer transforms import() without using that plugin.\n`;\n\nfunction getExportSpecifierName(node, stringSpecifiers) {\n  if (node.type === \"Identifier\") {\n    return node.name;\n  } else if (node.type === \"StringLiteral\") {\n    const stringValue = node.value;\n\n    if (!(0, _helperValidatorIdentifier.isIdentifierName)(stringValue)) {\n      stringSpecifiers.add(stringValue);\n    }\n\n    return stringValue;\n  } else {\n    throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${node.type}`);\n  }\n}\n\nfunction constructExportCall(path, exportIdent, exportNames, exportValues, exportStarTarget, stringSpecifiers) {\n  const statements = [];\n\n  if (!exportStarTarget) {\n    if (exportNames.length === 1) {\n      statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.stringLiteral(exportNames[0]), exportValues[0]])));\n    } else {\n      const objectProperties = [];\n\n      for (let i = 0; i < exportNames.length; i++) {\n        const exportName = exportNames[i];\n        const exportValue = exportValues[i];\n        objectProperties.push(_core.types.objectProperty(stringSpecifiers.has(exportName) ? _core.types.stringLiteral(exportName) : _core.types.identifier(exportName), exportValue));\n      }\n\n      statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.objectExpression(objectProperties)])));\n    }\n  } else {\n    const exportObj = path.scope.generateUid(\"exportObj\");\n    statements.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.identifier(exportObj), _core.types.objectExpression([]))]));\n    statements.push(buildExportAll({\n      KEY: path.scope.generateUidIdentifier(\"key\"),\n      EXPORT_OBJ: _core.types.identifier(exportObj),\n      TARGET: exportStarTarget\n    }));\n\n    for (let i = 0; i < exportNames.length; i++) {\n      const exportName = exportNames[i];\n      const exportValue = exportValues[i];\n      statements.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(_core.types.identifier(exportObj), _core.types.identifier(exportName)), exportValue)));\n    }\n\n    statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.identifier(exportObj)])));\n  }\n\n  return statements;\n}\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    systemGlobal = \"System\",\n    allowTopLevelThis = false\n  } = options;\n  const IGNORE_REASSIGNMENT_SYMBOL = Symbol();\n  const reassignmentVisitor = {\n    \"AssignmentExpression|UpdateExpression\"(path) {\n      if (path.node[IGNORE_REASSIGNMENT_SYMBOL]) return;\n      path.node[IGNORE_REASSIGNMENT_SYMBOL] = true;\n      const arg = path.get(path.isAssignmentExpression() ? \"left\" : \"argument\");\n\n      if (arg.isObjectPattern() || arg.isArrayPattern()) {\n        const exprs = [path.node];\n\n        for (const name of Object.keys(arg.getBindingIdentifiers())) {\n          if (this.scope.getBinding(name) !== path.scope.getBinding(name)) {\n            return;\n          }\n\n          const exportedNames = this.exports[name];\n          if (!exportedNames) return;\n\n          for (const exportedName of exportedNames) {\n            exprs.push(this.buildCall(exportedName, _core.types.identifier(name)).expression);\n          }\n        }\n\n        path.replaceWith(_core.types.sequenceExpression(exprs));\n        return;\n      }\n\n      if (!arg.isIdentifier()) return;\n      const name = arg.node.name;\n      if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;\n      const exportedNames = this.exports[name];\n      if (!exportedNames) return;\n      let node = path.node;\n      const isPostUpdateExpression = path.isUpdateExpression({\n        prefix: false\n      });\n\n      if (isPostUpdateExpression) {\n        node = _core.types.binaryExpression(node.operator[0], _core.types.unaryExpression(\"+\", _core.types.cloneNode(node.argument)), _core.types.numericLiteral(1));\n      }\n\n      for (const exportedName of exportedNames) {\n        node = this.buildCall(exportedName, node).expression;\n      }\n\n      if (isPostUpdateExpression) {\n        node = _core.types.sequenceExpression([node, path.node]);\n      }\n\n      path.replaceWith(node);\n    }\n\n  };\n  return {\n    name: \"transform-modules-systemjs\",\n\n    pre() {\n      this.file.set(\"@babel/plugin-transform-modules-*\", \"systemjs\");\n    },\n\n    visitor: {\n      CallExpression(path, state) {\n        if (_core.types.isImport(path.node.callee)) {\n          if (!this.file.has(\"@babel/plugin-proposal-dynamic-import\")) {\n            {\n              console.warn(MISSING_PLUGIN_WARNING);\n            }\n          }\n\n          path.replaceWith(_core.types.callExpression(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier(\"import\")), [(0, _utils.getImportSource)(_core.types, path.node)]));\n        }\n      },\n\n      MetaProperty(path, state) {\n        if (path.node.meta.name === \"import\" && path.node.property.name === \"meta\") {\n          path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier(\"meta\")));\n        }\n      },\n\n      ReferencedIdentifier(path, state) {\n        if (path.node.name === \"__moduleName\" && !path.scope.hasBinding(\"__moduleName\")) {\n          path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier(\"id\")));\n        }\n      },\n\n      Program: {\n        enter(path, state) {\n          state.contextIdent = path.scope.generateUid(\"context\");\n          state.stringSpecifiers = new Set();\n\n          if (!allowTopLevelThis) {\n            (0, _helperModuleTransforms.rewriteThis)(path);\n          }\n        },\n\n        exit(path, state) {\n          const scope = path.scope;\n          const exportIdent = scope.generateUid(\"export\");\n          const {\n            contextIdent,\n            stringSpecifiers\n          } = state;\n          const exportMap = Object.create(null);\n          const modules = [];\n          let beforeBody = [];\n          const setters = [];\n          const sources = [];\n          const variableIds = [];\n          const removedPaths = [];\n\n          function addExportName(key, val) {\n            exportMap[key] = exportMap[key] || [];\n            exportMap[key].push(val);\n          }\n\n          function pushModule(source, key, specifiers) {\n            let module;\n            modules.forEach(function (m) {\n              if (m.key === source) {\n                module = m;\n              }\n            });\n\n            if (!module) {\n              modules.push(module = {\n                key: source,\n                imports: [],\n                exports: []\n              });\n            }\n\n            module[key] = module[key].concat(specifiers);\n          }\n\n          function buildExportCall(name, val) {\n            return _core.types.expressionStatement(_core.types.callExpression(_core.types.identifier(exportIdent), [_core.types.stringLiteral(name), val]));\n          }\n\n          const exportNames = [];\n          const exportValues = [];\n          const body = path.get(\"body\");\n\n          for (const path of body) {\n            if (path.isFunctionDeclaration()) {\n              beforeBody.push(path.node);\n              removedPaths.push(path);\n            } else if (path.isClassDeclaration()) {\n              variableIds.push(_core.types.cloneNode(path.node.id));\n              path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(path.node.id), _core.types.toExpression(path.node))));\n            } else if (path.isImportDeclaration()) {\n              const source = path.node.source.value;\n              pushModule(source, \"imports\", path.node.specifiers);\n\n              for (const name of Object.keys(path.getBindingIdentifiers())) {\n                scope.removeBinding(name);\n                variableIds.push(_core.types.identifier(name));\n              }\n\n              path.remove();\n            } else if (path.isExportAllDeclaration()) {\n              pushModule(path.node.source.value, \"exports\", path.node);\n              path.remove();\n            } else if (path.isExportDefaultDeclaration()) {\n              const declar = path.get(\"declaration\");\n              const id = declar.node.id;\n\n              if (declar.isClassDeclaration()) {\n                if (id) {\n                  exportNames.push(\"default\");\n                  exportValues.push(scope.buildUndefinedNode());\n                  variableIds.push(_core.types.cloneNode(id));\n                  addExportName(id.name, \"default\");\n                  path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(id), _core.types.toExpression(declar.node))));\n                } else {\n                  exportNames.push(\"default\");\n                  exportValues.push(_core.types.toExpression(declar.node));\n                  removedPaths.push(path);\n                }\n              } else if (declar.isFunctionDeclaration()) {\n                if (id) {\n                  beforeBody.push(declar.node);\n                  exportNames.push(\"default\");\n                  exportValues.push(_core.types.cloneNode(id));\n                  addExportName(id.name, \"default\");\n                } else {\n                  exportNames.push(\"default\");\n                  exportValues.push(_core.types.toExpression(declar.node));\n                }\n\n                removedPaths.push(path);\n              } else {\n                path.replaceWith(buildExportCall(\"default\", declar.node));\n              }\n            } else if (path.isExportNamedDeclaration()) {\n              const declar = path.get(\"declaration\");\n\n              if (declar.node) {\n                path.replaceWith(declar);\n\n                if (path.isFunction()) {\n                  const node = declar.node;\n                  const name = node.id.name;\n                  addExportName(name, name);\n                  beforeBody.push(node);\n                  exportNames.push(name);\n                  exportValues.push(_core.types.cloneNode(node.id));\n                  removedPaths.push(path);\n                } else if (path.isClass()) {\n                  const name = declar.node.id.name;\n                  exportNames.push(name);\n                  exportValues.push(scope.buildUndefinedNode());\n                  variableIds.push(_core.types.cloneNode(declar.node.id));\n                  path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(declar.node.id), _core.types.toExpression(declar.node))));\n                  addExportName(name, name);\n                } else {\n                  for (const name of Object.keys(declar.getBindingIdentifiers())) {\n                    addExportName(name, name);\n                  }\n                }\n              } else {\n                const specifiers = path.node.specifiers;\n\n                if (specifiers != null && specifiers.length) {\n                  if (path.node.source) {\n                    pushModule(path.node.source.value, \"exports\", specifiers);\n                    path.remove();\n                  } else {\n                    const nodes = [];\n\n                    for (const specifier of specifiers) {\n                      const {\n                        local,\n                        exported\n                      } = specifier;\n                      const binding = scope.getBinding(local.name);\n                      const exportedName = getExportSpecifierName(exported, stringSpecifiers);\n\n                      if (binding && _core.types.isFunctionDeclaration(binding.path.node)) {\n                        exportNames.push(exportedName);\n                        exportValues.push(_core.types.cloneNode(local));\n                      } else if (!binding) {\n                          nodes.push(buildExportCall(exportedName, local));\n                        }\n\n                      addExportName(local.name, exportedName);\n                    }\n\n                    path.replaceWithMultiple(nodes);\n                  }\n                } else {\n                  path.remove();\n                }\n              }\n            }\n          }\n\n          modules.forEach(function (specifiers) {\n            let setterBody = [];\n            const target = scope.generateUid(specifiers.key);\n\n            for (let specifier of specifiers.imports) {\n              if (_core.types.isImportNamespaceSpecifier(specifier)) {\n                setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", specifier.local, _core.types.identifier(target))));\n              } else if (_core.types.isImportDefaultSpecifier(specifier)) {\n                specifier = _core.types.importSpecifier(specifier.local, _core.types.identifier(\"default\"));\n              }\n\n              if (_core.types.isImportSpecifier(specifier)) {\n                const {\n                  imported\n                } = specifier;\n                setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", specifier.local, _core.types.memberExpression(_core.types.identifier(target), specifier.imported, imported.type === \"StringLiteral\"))));\n              }\n            }\n\n            if (specifiers.exports.length) {\n              const exportNames = [];\n              const exportValues = [];\n              let hasExportStar = false;\n\n              for (const node of specifiers.exports) {\n                if (_core.types.isExportAllDeclaration(node)) {\n                  hasExportStar = true;\n                } else if (_core.types.isExportSpecifier(node)) {\n                  const exportedName = getExportSpecifierName(node.exported, stringSpecifiers);\n                  exportNames.push(exportedName);\n                  exportValues.push(_core.types.memberExpression(_core.types.identifier(target), node.local, _core.types.isStringLiteral(node.local)));\n                } else {}\n              }\n\n              setterBody = setterBody.concat(constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, hasExportStar ? _core.types.identifier(target) : null, stringSpecifiers));\n            }\n\n            sources.push(_core.types.stringLiteral(specifiers.key));\n            setters.push(_core.types.functionExpression(null, [_core.types.identifier(target)], _core.types.blockStatement(setterBody)));\n          });\n          let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);\n          if (moduleName) moduleName = _core.types.stringLiteral(moduleName);\n          (0, _helperHoistVariables.default)(path, (id, name, hasInit) => {\n            variableIds.push(id);\n\n            if (!hasInit && name in exportMap) {\n              for (const exported of exportMap[name]) {\n                exportNames.push(exported);\n                exportValues.push(scope.buildUndefinedNode());\n              }\n            }\n          }, null);\n\n          if (variableIds.length) {\n            beforeBody.unshift(_core.types.variableDeclaration(\"var\", variableIds.map(id => _core.types.variableDeclarator(id))));\n          }\n\n          if (exportNames.length) {\n            beforeBody = beforeBody.concat(constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, null, stringSpecifiers));\n          }\n\n          path.traverse(reassignmentVisitor, {\n            exports: exportMap,\n            buildCall: buildExportCall,\n            scope\n          });\n\n          for (const path of removedPaths) {\n            path.remove();\n          }\n\n          let hasTLA = false;\n          path.traverse({\n            AwaitExpression(path) {\n              hasTLA = true;\n              path.stop();\n            },\n\n            Function(path) {\n              path.skip();\n            },\n\n            noScope: true\n          });\n          path.node.body = [buildTemplate({\n            SYSTEM_REGISTER: _core.types.memberExpression(_core.types.identifier(systemGlobal), _core.types.identifier(\"register\")),\n            BEFORE_BODY: beforeBody,\n            MODULE_NAME: moduleName,\n            SETTERS: _core.types.arrayExpression(setters),\n            EXECUTE: _core.types.functionExpression(null, [], _core.types.blockStatement(path.node.body), false, hasTLA),\n            SOURCES: _core.types.arrayExpression(sources),\n            EXPORT_IDENTIFIER: _core.types.identifier(exportIdent),\n            CONTEXT_IDENTIFIER: _core.types.identifier(contextIdent)\n          })];\n        }\n\n      }\n    }\n  };\n});\n\nexports.default = _default;"]}