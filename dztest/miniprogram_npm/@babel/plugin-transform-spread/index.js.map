{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _helperSkipTransparentExpressionWrappers = require(\"@babel/helper-skip-transparent-expression-wrappers\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  var _api$assumption, _options$allowArrayLi;\n\n  api.assertVersion(7);\n  const iterableIsArray = (_api$assumption = api.assumption(\"iterableIsArray\")) != null ? _api$assumption : options.loose;\n  const arrayLikeIsIterable = (_options$allowArrayLi = options.allowArrayLike) != null ? _options$allowArrayLi : api.assumption(\"arrayLikeIsIterable\");\n\n  function getSpreadLiteral(spread, scope) {\n    if (iterableIsArray && !_core.types.isIdentifier(spread.argument, {\n      name: \"arguments\"\n    })) {\n      return spread.argument;\n    } else {\n      return scope.toArray(spread.argument, true, arrayLikeIsIterable);\n    }\n  }\n\n  function hasHole(spread) {\n    return spread.elements.some(el => el === null);\n  }\n\n  function hasSpread(nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      if (_core.types.isSpreadElement(nodes[i])) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function push(_props, nodes) {\n    if (!_props.length) return _props;\n    nodes.push(_core.types.arrayExpression(_props));\n    return [];\n  }\n\n  function build(props, scope, file) {\n    const nodes = [];\n    let _props = [];\n\n    for (const prop of props) {\n      if (_core.types.isSpreadElement(prop)) {\n        _props = push(_props, nodes);\n        let spreadLiteral = getSpreadLiteral(prop, scope);\n\n        if (_core.types.isArrayExpression(spreadLiteral) && hasHole(spreadLiteral)) {\n          spreadLiteral = _core.types.callExpression(file.addHelper(\"arrayWithoutHoles\"), [spreadLiteral]);\n        }\n\n        nodes.push(spreadLiteral);\n      } else {\n        _props.push(prop);\n      }\n    }\n\n    push(_props, nodes);\n    return nodes;\n  }\n\n  return {\n    name: \"transform-spread\",\n    visitor: {\n      ArrayExpression(path) {\n        const {\n          node,\n          scope\n        } = path;\n        const elements = node.elements;\n        if (!hasSpread(elements)) return;\n        const nodes = build(elements, scope, this);\n        let first = nodes[0];\n\n        if (nodes.length === 1 && first !== elements[0].argument) {\n          path.replaceWith(first);\n          return;\n        }\n\n        if (!_core.types.isArrayExpression(first)) {\n          first = _core.types.arrayExpression([]);\n        } else {\n          nodes.shift();\n        }\n\n        path.replaceWith(_core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier(\"concat\")), nodes));\n      },\n\n      CallExpression(path) {\n        const {\n          node,\n          scope\n        } = path;\n        const args = node.arguments;\n        if (!hasSpread(args)) return;\n        const calleePath = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get(\"callee\"));\n\n        if (calleePath.isSuper()) {\n          throw path.buildCodeFrameError(\"It's not possible to compile spread arguments in `super()` without compiling classes.\\n\" + \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\");\n        }\n\n        let contextLiteral = scope.buildUndefinedNode();\n        node.arguments = [];\n        let nodes;\n\n        if (args.length === 1 && args[0].argument.name === \"arguments\") {\n          nodes = [args[0].argument];\n        } else {\n          nodes = build(args, scope, this);\n        }\n\n        const first = nodes.shift();\n\n        if (nodes.length) {\n          node.arguments.push(_core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier(\"concat\")), nodes));\n        } else {\n          node.arguments.push(first);\n        }\n\n        const callee = calleePath.node;\n\n        if (calleePath.isMemberExpression()) {\n          const temp = scope.maybeGenerateMemoised(callee.object);\n\n          if (temp) {\n            callee.object = _core.types.assignmentExpression(\"=\", temp, callee.object);\n            contextLiteral = temp;\n          } else {\n            contextLiteral = _core.types.cloneNode(callee.object);\n          }\n        }\n\n        node.callee = _core.types.memberExpression(node.callee, _core.types.identifier(\"apply\"));\n\n        if (_core.types.isSuper(contextLiteral)) {\n          contextLiteral = _core.types.thisExpression();\n        }\n\n        node.arguments.unshift(_core.types.cloneNode(contextLiteral));\n      },\n\n      NewExpression(path) {\n        const {\n          node,\n          scope\n        } = path;\n        let args = node.arguments;\n        if (!hasSpread(args)) return;\n        const nodes = build(args, scope, this);\n        const first = nodes.shift();\n\n        if (nodes.length) {\n          args = _core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier(\"concat\")), nodes);\n        } else {\n          args = first;\n        }\n\n        path.replaceWith(_core.types.callExpression(path.hub.addHelper(\"construct\"), [node.callee, args]));\n      }\n\n    }\n  };\n});\n\nexports.default = _default;"]}