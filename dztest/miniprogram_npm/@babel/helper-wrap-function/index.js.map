{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = wrapFunction;\n\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\n\nvar _template = require(\"@babel/template\");\n\nvar t = require(\"@babel/types\");\n\nconst buildAnonymousExpressionWrapper = _template.default.expression(`\n  (function () {\n    var REF = FUNCTION;\n    return function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    };\n  })()\n`);\n\nconst buildNamedExpressionWrapper = _template.default.expression(`\n  (function () {\n    var REF = FUNCTION;\n    function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    }\n    return NAME;\n  })()\n`);\n\nconst buildDeclarationWrapper = (0, _template.default)(`\n  function NAME(PARAMS) { return REF.apply(this, arguments); }\n  function REF() {\n    REF = FUNCTION;\n    return REF.apply(this, arguments);\n  }\n`);\n\nfunction classOrObjectMethod(path, callId) {\n  const node = path.node;\n  const body = node.body;\n  const container = t.functionExpression(null, [], t.blockStatement(body.body), true);\n  body.body = [t.returnStatement(t.callExpression(t.callExpression(callId, [container]), []))];\n  node.async = false;\n  node.generator = false;\n  path.get(\"body.body.0.argument.callee.arguments.0\").unwrapFunctionEnvironment();\n}\n\nfunction plainFunction(path, callId, noNewArrows) {\n  const node = path.node;\n  const isDeclaration = path.isFunctionDeclaration();\n  const functionId = node.id;\n  const wrapper = isDeclaration ? buildDeclarationWrapper : functionId ? buildNamedExpressionWrapper : buildAnonymousExpressionWrapper;\n\n  if (path.isArrowFunctionExpression()) {\n    path.arrowFunctionToExpression({\n      noNewArrows\n    });\n  }\n\n  node.id = null;\n\n  if (isDeclaration) {\n    node.type = \"FunctionExpression\";\n  }\n\n  const built = t.callExpression(callId, [node]);\n  const container = wrapper({\n    NAME: functionId || null,\n    REF: path.scope.generateUidIdentifier(functionId ? functionId.name : \"ref\"),\n    FUNCTION: built,\n    PARAMS: node.params.reduce((acc, param) => {\n      acc.done = acc.done || t.isAssignmentPattern(param) || t.isRestElement(param);\n\n      if (!acc.done) {\n        acc.params.push(path.scope.generateUidIdentifier(\"x\"));\n      }\n\n      return acc;\n    }, {\n      params: [],\n      done: false\n    }).params\n  });\n\n  if (isDeclaration) {\n    path.replaceWith(container[0]);\n    path.insertAfter(container[1]);\n  } else {\n    const retFunction = container.callee.body.body[1].argument;\n\n    if (!functionId) {\n      (0, _helperFunctionName.default)({\n        node: retFunction,\n        parent: path.parent,\n        scope: path.scope\n      });\n    }\n\n    if (!retFunction || retFunction.id || node.params.length) {\n      path.replaceWith(container);\n    } else {\n      path.replaceWith(built);\n    }\n  }\n}\n\nfunction wrapFunction(path, callId, noNewArrows = true) {\n  if (path.isMethod()) {\n    classOrObjectMethod(path, callId);\n  } else {\n    plainFunction(path, callId, noNewArrows);\n  }\n}"]}