{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _helperPluginUtils() {\n  const data = require(\"@babel/helper-plugin-utils\");\n\n  _helperPluginUtils = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _pluginSyntaxFunctionBind() {\n  const data = _interopRequireDefault(require(\"@babel/plugin-syntax-function-bind\"));\n\n  _pluginSyntaxFunctionBind = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _core() {\n  const data = require(\"@babel/core\");\n\n  _core = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _default = (0, _helperPluginUtils().declare)(api => {\n  api.assertVersion(7);\n\n  function getTempId(scope) {\n    let id = scope.path.getData(\"functionBind\");\n    if (id) return id;\n    id = scope.generateDeclaredUidIdentifier(\"context\");\n    return scope.path.setData(\"functionBind\", id);\n  }\n\n  function getStaticContext(bind, scope) {\n    const object = bind.object || bind.callee.object;\n    return scope.isStatic(object) && object;\n  }\n\n  function inferBindContext(bind, scope) {\n    const staticContext = getStaticContext(bind, scope);\n    if (staticContext) return _core().types.cloneNode(staticContext);\n    const tempId = getTempId(scope);\n\n    if (bind.object) {\n      bind.callee = _core().types.sequenceExpression([_core().types.assignmentExpression(\"=\", tempId, bind.object), bind.callee]);\n    } else {\n      bind.callee.object = _core().types.assignmentExpression(\"=\", tempId, bind.callee.object);\n    }\n\n    return tempId;\n  }\n\n  return {\n    name: \"proposal-function-bind\",\n    inherits: _pluginSyntaxFunctionBind().default,\n    visitor: {\n      CallExpression({\n        node,\n        scope\n      }) {\n        const bind = node.callee;\n        if (!_core().types.isBindExpression(bind)) return;\n        const context = inferBindContext(bind, scope);\n        node.callee = _core().types.memberExpression(bind.callee, _core().types.identifier(\"call\"));\n        node.arguments.unshift(context);\n      },\n\n      BindExpression(path) {\n        const {\n          node,\n          scope\n        } = path;\n        const context = inferBindContext(node, scope);\n        path.replaceWith(_core().types.callExpression(_core().types.memberExpression(node.callee, _core().types.identifier(\"bind\")), [context]));\n      }\n\n    }\n  };\n});\n\nexports.default = _default;"]}