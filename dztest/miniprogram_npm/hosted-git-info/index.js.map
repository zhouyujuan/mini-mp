{"version":3,"sources":["index.js","git-host-info.js","git-host.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nvar url = require('url')\nvar gitHosts = require('./git-host-info.js')\nvar GitHost = module.exports = require('./git-host.js')\n\nvar protocolToRepresentationMap = {\n  'git+ssh:': 'sshurl',\n  'git+https:': 'https',\n  'ssh:': 'sshurl',\n  'git:': 'git'\n}\n\nfunction protocolToRepresentation (protocol) {\n  return protocolToRepresentationMap[protocol] || protocol.slice(0, -1)\n}\n\nvar authProtocols = {\n  'git:': true,\n  'https:': true,\n  'git+https:': true,\n  'http:': true,\n  'git+http:': true\n}\n\nvar cache = {}\n\nmodule.exports.fromUrl = function (giturl, opts) {\n  if (typeof giturl !== 'string') return\n  var key = giturl + JSON.stringify(opts || {})\n\n  if (!(key in cache)) {\n    cache[key] = fromUrl(giturl, opts)\n  }\n\n  return cache[key]\n}\n\nfunction fromUrl (giturl, opts) {\n  if (giturl == null || giturl === '') return\n  var url = fixupUnqualifiedGist(\n    isGitHubShorthand(giturl) ? 'github:' + giturl : giturl\n  )\n  var parsed = parseGitUrl(url)\n  var shortcutMatch = url.match(/^([^:]+):(?:[^@]+@)?(?:([^/]*)\\/)?([^#]+)/)\n  var matches = Object.keys(gitHosts).map(function (gitHostName) {\n    try {\n      var gitHostInfo = gitHosts[gitHostName]\n      var auth = null\n      if (parsed.auth && authProtocols[parsed.protocol]) {\n        auth = parsed.auth\n      }\n      var committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null\n      var user = null\n      var project = null\n      var defaultRepresentation = null\n      if (shortcutMatch && shortcutMatch[1] === gitHostName) {\n        user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2])\n        project = decodeURIComponent(shortcutMatch[3].replace(/\\.git$/, ''))\n        defaultRepresentation = 'shortcut'\n      } else {\n        if (parsed.host && parsed.host !== gitHostInfo.domain && parsed.host.replace(/^www[.]/, '') !== gitHostInfo.domain) return\n        if (!gitHostInfo.protocols_re.test(parsed.protocol)) return\n        if (!parsed.path) return\n        var pathmatch = gitHostInfo.pathmatch\n        var matched = parsed.path.match(pathmatch)\n        if (!matched) return\n        /* istanbul ignore else */\n        if (matched[1] !== null && matched[1] !== undefined) {\n          user = decodeURIComponent(matched[1].replace(/^:/, ''))\n        }\n        project = decodeURIComponent(matched[2])\n        defaultRepresentation = protocolToRepresentation(parsed.protocol)\n      }\n      return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts)\n    } catch (ex) {\n      /* istanbul ignore else */\n      if (ex instanceof URIError) {\n      } else throw ex\n    }\n  }).filter(function (gitHostInfo) { return gitHostInfo })\n  if (matches.length !== 1) return\n  return matches[0]\n}\n\nfunction isGitHubShorthand (arg) {\n  // Note: This does not fully test the git ref format.\n  // See https://www.kernel.org/pub/software/scm/git/docs/git-check-ref-format.html\n  //\n  // The only way to do this properly would be to shell out to\n  // git-check-ref-format, and as this is a fast sync function,\n  // we don't want to do that.  Just let git fail if it turns\n  // out that the commit-ish is invalid.\n  // GH usernames cannot start with . or -\n  return /^[^:@%/\\s.-][^:@%/\\s]*[/][^:@\\s/%]+(?:#.*)?$/.test(arg)\n}\n\nfunction fixupUnqualifiedGist (giturl) {\n  // necessary for round-tripping gists\n  var parsed = url.parse(giturl)\n  if (parsed.protocol === 'gist:' && parsed.host && !parsed.path) {\n    return parsed.protocol + '/' + parsed.host\n  } else {\n    return giturl\n  }\n}\n\nfunction parseGitUrl (giturl) {\n  var matched = giturl.match(/^([^@]+)@([^:/]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/)\n  if (!matched) {\n    var legacy = url.parse(giturl)\n    // If we don't have url.URL, then sorry, this is just not fixable.\n    // This affects Node <= 6.12.\n    if (legacy.auth && typeof url.URL === 'function') {\n      // git urls can be in the form of scp-style/ssh-connect strings, like\n      // git+ssh://user@host.com:some/path, which the legacy url parser\n      // supports, but WhatWG url.URL class does not.  However, the legacy\n      // parser de-urlencodes the username and password, so something like\n      // https://user%3An%40me:p%40ss%3Aword@x.com/ becomes\n      // https://user:n@me:p@ss:word@x.com/ which is all kinds of wrong.\n      // Pull off just the auth and host, so we dont' get the confusing\n      // scp-style URL, then pass that to the WhatWG parser to get the\n      // auth properly escaped.\n      var authmatch = giturl.match(/[^@]+@[^:/]+/)\n      /* istanbul ignore else - this should be impossible */\n      if (authmatch) {\n        var whatwg = new url.URL(authmatch[0])\n        legacy.auth = whatwg.username || ''\n        if (whatwg.password) legacy.auth += ':' + whatwg.password\n      }\n    }\n    return legacy\n  }\n  return {\n    protocol: 'git+ssh:',\n    slashes: true,\n    auth: matched[1],\n    host: matched[2],\n    port: null,\n    hostname: matched[2],\n    hash: matched[4],\n    search: null,\n    query: null,\n    pathname: '/' + matched[3],\n    path: '/' + matched[3],\n    href: 'git+ssh://' + matched[1] + '@' + matched[2] +\n          '/' + matched[3] + (matched[4] || '')\n  }\n}\n","\n\nvar gitHosts = module.exports = {\n  github: {\n    // First two are insecure and generally shouldn't be used any more, but\n    // they are still supported.\n    'protocols': [ 'git', 'http', 'git+ssh', 'git+https', 'ssh', 'https' ],\n    'domain': 'github.com',\n    'treepath': 'tree',\n    'filetemplate': 'https://{auth@}raw.githubusercontent.com/{user}/{project}/{committish}/{path}',\n    'bugstemplate': 'https://{domain}/{user}/{project}/issues',\n    'gittemplate': 'git://{auth@}{domain}/{user}/{project}.git{#committish}',\n    'tarballtemplate': 'https://codeload.{domain}/{user}/{project}/tar.gz/{committish}'\n  },\n  bitbucket: {\n    'protocols': [ 'git+ssh', 'git+https', 'ssh', 'https' ],\n    'domain': 'bitbucket.org',\n    'treepath': 'src',\n    'tarballtemplate': 'https://{domain}/{user}/{project}/get/{committish}.tar.gz'\n  },\n  gitlab: {\n    'protocols': [ 'git+ssh', 'git+https', 'ssh', 'https' ],\n    'domain': 'gitlab.com',\n    'treepath': 'tree',\n    'bugstemplate': 'https://{domain}/{user}/{project}/issues',\n    'httpstemplate': 'git+https://{auth@}{domain}/{user}/{projectPath}.git{#committish}',\n    'tarballtemplate': 'https://{domain}/{user}/{project}/repository/archive.tar.gz?ref={committish}',\n    'pathmatch': /^[/]([^/]+)[/]((?!.*(\\/-\\/|\\/repository\\/archive\\.tar\\.gz\\?=.*|\\/repository\\/[^/]+\\/archive.tar.gz$)).*?)(?:[.]git|[/])?$/\n  },\n  gist: {\n    'protocols': [ 'git', 'git+ssh', 'git+https', 'ssh', 'https' ],\n    'domain': 'gist.github.com',\n    'pathmatch': /^[/](?:([^/]+)[/])?([a-z0-9]{32,})(?:[.]git)?$/,\n    'filetemplate': 'https://gist.githubusercontent.com/{user}/{project}/raw{/committish}/{path}',\n    'bugstemplate': 'https://{domain}/{project}',\n    'gittemplate': 'git://{domain}/{project}.git{#committish}',\n    'sshtemplate': 'git@{domain}:/{project}.git{#committish}',\n    'sshurltemplate': 'git+ssh://git@{domain}/{project}.git{#committish}',\n    'browsetemplate': 'https://{domain}/{project}{/committish}',\n    'browsefiletemplate': 'https://{domain}/{project}{/committish}{#path}',\n    'docstemplate': 'https://{domain}/{project}{/committish}',\n    'httpstemplate': 'git+https://{domain}/{project}.git{#committish}',\n    'shortcuttemplate': '{type}:{project}{#committish}',\n    'pathtemplate': '{project}{#committish}',\n    'tarballtemplate': 'https://codeload.github.com/gist/{project}/tar.gz/{committish}',\n    'hashformat': function (fragment) {\n      return 'file-' + formatHashFragment(fragment)\n    }\n  }\n}\n\nvar gitHostDefaults = {\n  'sshtemplate': 'git@{domain}:{user}/{project}.git{#committish}',\n  'sshurltemplate': 'git+ssh://git@{domain}/{user}/{project}.git{#committish}',\n  'browsetemplate': 'https://{domain}/{user}/{project}{/tree/committish}',\n  'browsefiletemplate': 'https://{domain}/{user}/{project}/{treepath}/{committish}/{path}{#fragment}',\n  'docstemplate': 'https://{domain}/{user}/{project}{/tree/committish}#readme',\n  'httpstemplate': 'git+https://{auth@}{domain}/{user}/{project}.git{#committish}',\n  'filetemplate': 'https://{domain}/{user}/{project}/raw/{committish}/{path}',\n  'shortcuttemplate': '{type}:{user}/{project}{#committish}',\n  'pathtemplate': '{user}/{project}{#committish}',\n  'pathmatch': /^[/]([^/]+)[/]([^/]+?)(?:[.]git|[/])?$/,\n  'hashformat': formatHashFragment\n}\n\nObject.keys(gitHosts).forEach(function (name) {\n  Object.keys(gitHostDefaults).forEach(function (key) {\n    if (gitHosts[name][key]) return\n    gitHosts[name][key] = gitHostDefaults[key]\n  })\n  gitHosts[name].protocols_re = RegExp('^(' +\n    gitHosts[name].protocols.map(function (protocol) {\n      return protocol.replace(/([\\\\+*{}()[\\]$^|])/g, '\\\\$1')\n    }).join('|') + '):$')\n})\n\nfunction formatHashFragment (fragment) {\n  return fragment.toLowerCase().replace(/^\\W+|\\/|\\W+$/g, '').replace(/\\W+/g, '-')\n}\n","\nvar gitHosts = require('./git-host-info.js')\n/* eslint-disable node/no-deprecated-api */\n\n// copy-pasta util._extend from node's source, to avoid pulling\n// the whole util module into peoples' webpack bundles.\n/* istanbul ignore next */\nvar extend = Object.assign || function _extend (target, source) {\n  // Don't do anything if source isn't an object\n  if (source === null || typeof source !== 'object') return target\n\n  var keys = Object.keys(source)\n  var i = keys.length\n  while (i--) {\n    target[keys[i]] = source[keys[i]]\n  }\n  return target\n}\n\nmodule.exports = GitHost\nfunction GitHost (type, user, auth, project, committish, defaultRepresentation, opts) {\n  var gitHostInfo = this\n  gitHostInfo.type = type\n  Object.keys(gitHosts[type]).forEach(function (key) {\n    gitHostInfo[key] = gitHosts[type][key]\n  })\n  gitHostInfo.user = user\n  gitHostInfo.auth = auth\n  gitHostInfo.project = project\n  gitHostInfo.committish = committish\n  gitHostInfo.default = defaultRepresentation\n  gitHostInfo.opts = opts || {}\n}\n\nGitHost.prototype.hash = function () {\n  return this.committish ? '#' + this.committish : ''\n}\n\nGitHost.prototype._fill = function (template, opts) {\n  if (!template) return\n  var vars = extend({}, opts)\n  vars.path = vars.path ? vars.path.replace(/^[/]+/g, '') : ''\n  opts = extend(extend({}, this.opts), opts)\n  var self = this\n  Object.keys(this).forEach(function (key) {\n    if (self[key] != null && vars[key] == null) vars[key] = self[key]\n  })\n  var rawAuth = vars.auth\n  var rawcommittish = vars.committish\n  var rawFragment = vars.fragment\n  var rawPath = vars.path\n  var rawProject = vars.project\n  Object.keys(vars).forEach(function (key) {\n    var value = vars[key]\n    if ((key === 'path' || key === 'project') && typeof value === 'string') {\n      vars[key] = value.split('/').map(function (pathComponent) {\n        return encodeURIComponent(pathComponent)\n      }).join('/')\n    } else {\n      vars[key] = encodeURIComponent(value)\n    }\n  })\n  vars['auth@'] = rawAuth ? rawAuth + '@' : ''\n  vars['#fragment'] = rawFragment ? '#' + this.hashformat(rawFragment) : ''\n  vars.fragment = vars.fragment ? vars.fragment : ''\n  vars['#path'] = rawPath ? '#' + this.hashformat(rawPath) : ''\n  vars['/path'] = vars.path ? '/' + vars.path : ''\n  vars.projectPath = rawProject.split('/').map(encodeURIComponent).join('/')\n  if (opts.noCommittish) {\n    vars['#committish'] = ''\n    vars['/tree/committish'] = ''\n    vars['/committish'] = ''\n    vars.committish = ''\n  } else {\n    vars['#committish'] = rawcommittish ? '#' + rawcommittish : ''\n    vars['/tree/committish'] = vars.committish\n      ? '/' + vars.treepath + '/' + vars.committish\n      : ''\n    vars['/committish'] = vars.committish ? '/' + vars.committish : ''\n    vars.committish = vars.committish || 'master'\n  }\n  var res = template\n  Object.keys(vars).forEach(function (key) {\n    res = res.replace(new RegExp('[{]' + key + '[}]', 'g'), vars[key])\n  })\n  if (opts.noGitPlus) {\n    return res.replace(/^git[+]/, '')\n  } else {\n    return res\n  }\n}\n\nGitHost.prototype.ssh = function (opts) {\n  return this._fill(this.sshtemplate, opts)\n}\n\nGitHost.prototype.sshurl = function (opts) {\n  return this._fill(this.sshurltemplate, opts)\n}\n\nGitHost.prototype.browse = function (P, F, opts) {\n  if (typeof P === 'string') {\n    if (typeof F !== 'string') {\n      opts = F\n      F = null\n    }\n    return this._fill(this.browsefiletemplate, extend({\n      fragment: F,\n      path: P\n    }, opts))\n  } else {\n    return this._fill(this.browsetemplate, P)\n  }\n}\n\nGitHost.prototype.docs = function (opts) {\n  return this._fill(this.docstemplate, opts)\n}\n\nGitHost.prototype.bugs = function (opts) {\n  return this._fill(this.bugstemplate, opts)\n}\n\nGitHost.prototype.https = function (opts) {\n  return this._fill(this.httpstemplate, opts)\n}\n\nGitHost.prototype.git = function (opts) {\n  return this._fill(this.gittemplate, opts)\n}\n\nGitHost.prototype.shortcut = function (opts) {\n  return this._fill(this.shortcuttemplate, opts)\n}\n\nGitHost.prototype.path = function (opts) {\n  return this._fill(this.pathtemplate, opts)\n}\n\nGitHost.prototype.tarball = function (opts_) {\n  var opts = extend({}, opts_, { noCommittish: false })\n  return this._fill(this.tarballtemplate, opts)\n}\n\nGitHost.prototype.file = function (P, opts) {\n  return this._fill(this.filetemplate, extend({ path: P }, opts))\n}\n\nGitHost.prototype.getDefaultRepresentation = function () {\n  return this.default\n}\n\nGitHost.prototype.toString = function (opts) {\n  if (this.default && typeof this[this.default] === 'function') return this[this.default](opts)\n  return this.sshurl(opts)\n}\n"]}