{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _postcss = require('postcss');\n\nvar _postcss2 = _interopRequireDefault(_postcss);\n\nvar _postcssValueParser = require('postcss-value-parser');\n\nvar _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);\n\nvar _has = require('has');\n\nvar _has2 = _interopRequireDefault(_has);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * Constants (parser usage)\n */\n\nconst SINGLE_QUOTE = '\\''.charCodeAt(0);\nconst DOUBLE_QUOTE = '\"'.charCodeAt(0);\nconst BACKSLASH = '\\\\'.charCodeAt(0);\nconst NEWLINE = '\\n'.charCodeAt(0);\nconst SPACE = ' '.charCodeAt(0);\nconst FEED = '\\f'.charCodeAt(0);\nconst TAB = '\\t'.charCodeAt(0);\nconst CR = '\\r'.charCodeAt(0);\n\nconst WORD_END = /[ \\n\\t\\r\\f'\"\\\\]/g;\n\n/*\n * Constants (node type strings)\n */\n\nconst C_STRING = 'string';\nconst C_ESCAPED_SINGLE_QUOTE = 'escapedSingleQuote';\nconst C_ESCAPED_DOUBLE_QUOTE = 'escapedDoubleQuote';\nconst C_SINGLE_QUOTE = 'singleQuote';\nconst C_DOUBLE_QUOTE = 'doubleQuote';\nconst C_NEWLINE = 'newline';\nconst C_SINGLE = 'single';\n\n/*\n * Literals\n */\n\nconst L_SINGLE_QUOTE = `'`;\nconst L_DOUBLE_QUOTE = `\"`;\nconst L_NEWLINE = `\\\\\\n`;\n\n/*\n * Parser nodes\n */\n\nconst T_ESCAPED_SINGLE_QUOTE = { type: C_ESCAPED_SINGLE_QUOTE, value: `\\\\'` };\nconst T_ESCAPED_DOUBLE_QUOTE = { type: C_ESCAPED_DOUBLE_QUOTE, value: `\\\\\"` };\nconst T_SINGLE_QUOTE = { type: C_SINGLE_QUOTE, value: L_SINGLE_QUOTE };\nconst T_DOUBLE_QUOTE = { type: C_DOUBLE_QUOTE, value: L_DOUBLE_QUOTE };\nconst T_NEWLINE = { type: C_NEWLINE, value: L_NEWLINE };\n\nfunction stringify(ast) {\n    return ast.nodes.reduce((str, { value }) => {\n        // Collapse multiple line strings automatically\n        if (value === L_NEWLINE) {\n            return str;\n        }\n\n        return str + value;\n    }, '');\n}\n\nfunction parse(str) {\n    let code, next, value;\n    let pos = 0;\n    let len = str.length;\n\n    const ast = {\n        nodes: [],\n        types: {\n            escapedSingleQuote: 0,\n            escapedDoubleQuote: 0,\n            singleQuote: 0,\n            doubleQuote: 0\n        },\n        quotes: false\n    };\n\n    while (pos < len) {\n        code = str.charCodeAt(pos);\n\n        switch (code) {\n            case SPACE:\n            case TAB:\n            case CR:\n            case FEED:\n                next = pos;\n\n                do {\n                    next += 1;\n                    code = str.charCodeAt(next);\n                } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);\n\n                ast.nodes.push({\n                    type: 'space',\n                    value: str.slice(pos, next)\n                });\n                pos = next - 1;\n                break;\n            case SINGLE_QUOTE:\n                ast.nodes.push(T_SINGLE_QUOTE);\n                ast.types[C_SINGLE_QUOTE]++;\n                ast.quotes = true;\n                break;\n            case DOUBLE_QUOTE:\n                ast.nodes.push(T_DOUBLE_QUOTE);\n                ast.types[C_DOUBLE_QUOTE]++;\n                ast.quotes = true;\n                break;\n            case BACKSLASH:\n                next = pos + 1;\n\n                if (str.charCodeAt(next) === SINGLE_QUOTE) {\n                    ast.nodes.push(T_ESCAPED_SINGLE_QUOTE);\n                    ast.types[C_ESCAPED_SINGLE_QUOTE]++;\n                    ast.quotes = true;\n                    pos = next;\n                    break;\n                } else if (str.charCodeAt(next) === DOUBLE_QUOTE) {\n                    ast.nodes.push(T_ESCAPED_DOUBLE_QUOTE);\n                    ast.types[C_ESCAPED_DOUBLE_QUOTE]++;\n                    ast.quotes = true;\n                    pos = next;\n                    break;\n                } else if (str.charCodeAt(next) === NEWLINE) {\n                    ast.nodes.push(T_NEWLINE);\n                    pos = next;\n                    break;\n                }\n            /*\n             * We need to fall through here to handle the token as\n             * a whole word. The missing 'break' is intentional.\n             */\n            default:\n                WORD_END.lastIndex = pos + 1;\n                WORD_END.test(str);\n\n                if (WORD_END.lastIndex === 0) {\n                    next = len - 1;\n                } else {\n                    next = WORD_END.lastIndex - 2;\n                }\n\n                value = str.slice(pos, next + 1);\n\n                ast.nodes.push({\n                    type: C_STRING,\n                    value\n                });\n\n                pos = next;\n        }\n        pos++;\n    }\n\n    return ast;\n}\n\nfunction changeWrappingQuotes(node, ast) {\n    const { types } = ast;\n\n    if (types[C_SINGLE_QUOTE] || types[C_DOUBLE_QUOTE]) {\n        return;\n    }\n\n    if (node.quote === L_SINGLE_QUOTE && types[C_ESCAPED_SINGLE_QUOTE] > 0 && !types[C_ESCAPED_DOUBLE_QUOTE]) {\n        node.quote = L_DOUBLE_QUOTE;\n    }\n\n    if (node.quote === L_DOUBLE_QUOTE && types[C_ESCAPED_DOUBLE_QUOTE] > 0 && !types[C_ESCAPED_SINGLE_QUOTE]) {\n        node.quote = L_SINGLE_QUOTE;\n    }\n\n    ast.nodes = ast.nodes.reduce((newAst, child) => {\n        if (child.type === C_ESCAPED_DOUBLE_QUOTE && node.quote === L_SINGLE_QUOTE) {\n            return [...newAst, T_DOUBLE_QUOTE];\n        }\n\n        if (child.type === C_ESCAPED_SINGLE_QUOTE && node.quote === L_DOUBLE_QUOTE) {\n            return [...newAst, T_SINGLE_QUOTE];\n        }\n\n        return [...newAst, child];\n    }, []);\n}\n\nfunction normalize(value, preferredQuote) {\n    if (!value || !value.length) {\n        return value;\n    }\n\n    return (0, _postcssValueParser2.default)(value).walk(child => {\n        if (child.type !== C_STRING) {\n            return;\n        }\n\n        const ast = parse(child.value);\n\n        if (ast.quotes) {\n            changeWrappingQuotes(child, ast);\n        } else if (preferredQuote === C_SINGLE) {\n            child.quote = L_SINGLE_QUOTE;\n        } else {\n            child.quote = L_DOUBLE_QUOTE;\n        }\n\n        child.value = stringify(ast);\n    }).toString();\n}\n\nconst params = {\n    rule: 'selector',\n    decl: 'value',\n    atrule: 'params'\n};\n\nexports.default = _postcss2.default.plugin('postcss-normalize-string', opts => {\n    const { preferredQuote } = Object.assign({}, {\n        preferredQuote: 'double'\n    }, opts);\n\n    return css => {\n        const cache = {};\n\n        css.walk(node => {\n            const { type } = node;\n\n            if ((0, _has2.default)(params, type)) {\n                const param = params[type];\n                const key = node[param] + '|' + preferredQuote;\n\n                if (cache[key]) {\n                    node[param] = cache[key];\n\n                    return;\n                }\n\n                const result = normalize(node[param], preferredQuote);\n\n                node[param] = result;\n                cache[key] = result;\n            }\n        });\n    };\n});\nmodule.exports = exports['default'];"]}