{"version":3,"sources":["index.js","compat.js","helpers.js","get-modules-list-for-target-version.js","targets-parser.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,AENA,ADGA,AFMA;ACFA,AENA,ADGA,AFMA;ACFA,AENA,ADGA,AFMA;ACFA,AENA,ADGA,AFMA,AIZA;AHUA,AENA,ADGA,AFMA,AIZA;AHUA,AENA,ADGA,AFMA,AIZA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nconst compat = require('./compat');\nconst data = require('./data');\nconst entries = require('./entries');\nconst getModulesListForTargetVersion = require('./get-modules-list-for-target-version');\nconst modules = require('./modules');\n\nmodule.exports = Object.assign(compat, {\n  compat,\n  data,\n  entries,\n  getModulesListForTargetVersion,\n  modules,\n});\n","\nconst { compare, has, intersection } = require('./helpers');\nconst data = require('./data');\nconst getModulesListForTargetVersion = require('./get-modules-list-for-target-version');\nconst modules = require('./modules');\nconst targetsParser = require('./targets-parser');\n\nfunction checkModule(name, targets) {\n  if (!has(data, name)) throw new TypeError(`Incorrect module: ${ name }`);\n\n  const requirements = data[name];\n  const result = {\n    required: false,\n    targets: {},\n  };\n\n  for (const [engine, version] of targets) {\n    if (!has(requirements, engine) || compare(version, '<', requirements[engine])) {\n      result.required = true;\n      result.targets[engine] = version;\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = function ({ targets, filter, version }) {\n  const parsedTargets = targetsParser(targets);\n\n  const result = {\n    list: [],\n    targets: {},\n  };\n\n  let $modules = Array.isArray(filter) ? filter : modules;\n\n  if (filter instanceof RegExp) {\n    $modules = $modules.filter(it => filter.test(it));\n  } else if (typeof filter == 'string') {\n    $modules = $modules.filter(it => it.startsWith(filter));\n  }\n\n  if (version) {\n    $modules = intersection($modules, getModulesListForTargetVersion(version));\n  }\n\n  for (const key of $modules) {\n    const check = checkModule(key, parsedTargets);\n    if (check.required) {\n      result.list.push(key);\n      result.targets[key] = check.targets;\n    }\n  }\n\n  return result;\n};\n","\nconst cmp = require('semver/functions/cmp');\nconst semver = require('semver/functions/coerce');\n\nconst has = Function.call.bind({}.hasOwnProperty);\n\nfunction compare(a, operator, b) {\n  return cmp(semver(a), operator, semver(b));\n}\n\nfunction intersection(list, order) {\n  const set = list instanceof Set ? list : new Set(list);\n  return order.filter(name => set.has(name));\n}\n\nfunction sortObjectByKey(object, fn) {\n  return Object.keys(object).sort(fn).reduce((memo, key) => {\n    memo[key] = object[key];\n    return memo;\n  }, {});\n}\n\nmodule.exports = {\n  compare,\n  has,\n  intersection,\n  semver,\n  sortObjectByKey,\n};\n","\nconst { compare, intersection, semver } = require('./helpers');\nconst modulesByVersions = require('./modules-by-versions');\nconst modules = require('./modules');\n\nmodule.exports = function (raw) {\n  const corejs = semver(raw);\n  if (corejs.major !== 3) {\n    throw RangeError('This version of `core-js-compat` works only with `core-js@3`.');\n  }\n  const result = [];\n  for (const version of Object.keys(modulesByVersions)) {\n    if (compare(version, '<=', corejs)) {\n      result.push(...modulesByVersions[version]);\n    }\n  }\n  return intersection(result, modules);\n};\n","\nconst browserslist = require('browserslist');\nconst { compare, has } = require('./helpers');\nconst external = require('./external');\n\nconst aliases = new Map([\n  ['and_chr', 'chrome'],\n  ['and_ff', 'firefox'],\n  ['ie_mob', 'ie'],\n  ['ios_saf', 'ios'],\n  ['op_mob', 'opera_mobile'],\n]);\n\nconst validTargets = new Set([\n  'android',\n  'chrome',\n  'edge',\n  'electron',\n  'firefox',\n  'ie',\n  'ios',\n  'node',\n  'opera',\n  'opera_mobile',\n  'phantom',\n  'rhino',\n  'safari',\n  'samsung',\n]);\n\nmodule.exports = function (targets) {\n  if (typeof targets !== 'object' || Array.isArray(targets)) {\n    targets = { browsers: targets };\n  }\n\n  const { browsers, esmodules, node, ...rest } = targets;\n  const list = Object.entries(rest);\n\n  if (browsers) {\n    list.push(...browserslist(browsers).map(it => it.split(' ')));\n  }\n  if (esmodules) {\n    list.push(...Object.entries(external.modules));\n  }\n  if (node) {\n    list.push(['node', node === 'current' ? process.versions.node : node]);\n  }\n\n  const normalized = list.map(([engine, version]) => {\n    if (has(browserslist.aliases, engine)) {\n      engine = browserslist.aliases[engine];\n    }\n    if (aliases.has(engine)) {\n      engine = aliases.get(engine);\n    }\n    return [engine, String(version)];\n  }).filter(([engine]) => {\n    return validTargets.has(engine);\n  }).sort(([a], [b]) => {\n    return a < b ? -1 : a > b ? 1 : 0;\n  });\n\n  const reducedByMinVersion = new Map();\n  for (const [engine, version] of normalized) {\n    if (!reducedByMinVersion.has(engine) || compare(version, '<=', reducedByMinVersion.get(engine))) {\n      reducedByMinVersion.set(engine, version);\n    }\n  }\n\n  return reducedByMinVersion;\n};\n"]}