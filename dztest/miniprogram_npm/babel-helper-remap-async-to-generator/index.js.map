{"version":3,"sources":["index.js","for-await.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nexports.__esModule = true;\n\nexports.default = function (path, file, helpers) {\n  if (!helpers) {\n    helpers = { wrapAsync: file };\n    file = null;\n  }\n  path.traverse(awaitVisitor, {\n    file: file,\n    wrapAwait: helpers.wrapAwait\n  });\n\n  if (path.isClassMethod() || path.isObjectMethod()) {\n    classOrObjectMethod(path, helpers.wrapAsync);\n  } else {\n    plainFunction(path, helpers.wrapAsync);\n  }\n};\n\nvar _babelHelperFunctionName = require(\"babel-helper-function-name\");\n\nvar _babelHelperFunctionName2 = _interopRequireDefault(_babelHelperFunctionName);\n\nvar _babelTemplate = require(\"babel-template\");\n\nvar _babelTemplate2 = _interopRequireDefault(_babelTemplate);\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nvar _forAwait = require(\"./for-await\");\n\nvar _forAwait2 = _interopRequireDefault(_forAwait);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar buildWrapper = (0, _babelTemplate2.default)(\"\\n  (() => {\\n    var REF = FUNCTION;\\n    return function NAME(PARAMS) {\\n      return REF.apply(this, arguments);\\n    };\\n  })\\n\");\n\nvar namedBuildWrapper = (0, _babelTemplate2.default)(\"\\n  (() => {\\n    var REF = FUNCTION;\\n    function NAME(PARAMS) {\\n      return REF.apply(this, arguments);\\n    }\\n    return NAME;\\n  })\\n\");\n\nvar awaitVisitor = {\n  Function: function Function(path) {\n    if (path.isArrowFunctionExpression() && !path.node.async) {\n      path.arrowFunctionToShadowed();\n      return;\n    }\n    path.skip();\n  },\n  AwaitExpression: function AwaitExpression(_ref, _ref2) {\n    var node = _ref.node;\n    var wrapAwait = _ref2.wrapAwait;\n\n    node.type = \"YieldExpression\";\n    if (wrapAwait) {\n      node.argument = t.callExpression(wrapAwait, [node.argument]);\n    }\n  },\n  ForAwaitStatement: function ForAwaitStatement(path, _ref3) {\n    var file = _ref3.file,\n        wrapAwait = _ref3.wrapAwait;\n    var node = path.node;\n\n\n    var build = (0, _forAwait2.default)(path, {\n      getAsyncIterator: file.addHelper(\"asyncIterator\"),\n      wrapAwait: wrapAwait\n    });\n\n    var declar = build.declar,\n        loop = build.loop;\n\n    var block = loop.body;\n\n    path.ensureBlock();\n\n    if (declar) {\n      block.body.push(declar);\n    }\n\n    block.body = block.body.concat(node.body.body);\n\n    t.inherits(loop, node);\n    t.inherits(loop.body, node.body);\n\n    if (build.replaceParent) {\n      path.parentPath.replaceWithMultiple(build.node);\n      path.remove();\n    } else {\n      path.replaceWithMultiple(build.node);\n    }\n  }\n};\n\nfunction classOrObjectMethod(path, callId) {\n  var node = path.node;\n  var body = node.body;\n\n  node.async = false;\n\n  var container = t.functionExpression(null, [], t.blockStatement(body.body), true);\n  container.shadow = true;\n  body.body = [t.returnStatement(t.callExpression(t.callExpression(callId, [container]), []))];\n\n  node.generator = false;\n}\n\nfunction plainFunction(path, callId) {\n  var node = path.node;\n  var isDeclaration = path.isFunctionDeclaration();\n  var asyncFnId = node.id;\n  var wrapper = buildWrapper;\n\n  if (path.isArrowFunctionExpression()) {\n    path.arrowFunctionToShadowed();\n  } else if (!isDeclaration && asyncFnId) {\n    wrapper = namedBuildWrapper;\n  }\n\n  node.async = false;\n  node.generator = true;\n\n  node.id = null;\n\n  if (isDeclaration) {\n    node.type = \"FunctionExpression\";\n  }\n\n  var built = t.callExpression(callId, [node]);\n  var container = wrapper({\n    NAME: asyncFnId,\n    REF: path.scope.generateUidIdentifier(\"ref\"),\n    FUNCTION: built,\n    PARAMS: node.params.reduce(function (acc, param) {\n      acc.done = acc.done || t.isAssignmentPattern(param) || t.isRestElement(param);\n\n      if (!acc.done) {\n        acc.params.push(path.scope.generateUidIdentifier(\"x\"));\n      }\n\n      return acc;\n    }, {\n      params: [],\n      done: false\n    }).params\n  }).expression;\n\n  if (isDeclaration) {\n    var declar = t.variableDeclaration(\"let\", [t.variableDeclarator(t.identifier(asyncFnId.name), t.callExpression(container, []))]);\n    declar._blockHoist = true;\n\n    path.replaceWith(declar);\n  } else {\n    var retFunction = container.body.body[1].argument;\n    if (!asyncFnId) {\n      (0, _babelHelperFunctionName2.default)({\n        node: retFunction,\n        parent: path.parent,\n        scope: path.scope\n      });\n    }\n\n    if (!retFunction || retFunction.id || node.params.length) {\n      path.replaceWith(t.callExpression(container, []));\n    } else {\n      path.replaceWith(built);\n    }\n  }\n}\n\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n\nexports.default = function (path, helpers) {\n  var node = path.node,\n      scope = path.scope,\n      parent = path.parent;\n\n\n  var stepKey = scope.generateUidIdentifier(\"step\");\n  var stepValue = scope.generateUidIdentifier(\"value\");\n  var left = node.left;\n  var declar = void 0;\n\n  if (t.isIdentifier(left) || t.isPattern(left) || t.isMemberExpression(left)) {\n    declar = t.expressionStatement(t.assignmentExpression(\"=\", left, stepValue));\n  } else if (t.isVariableDeclaration(left)) {\n    declar = t.variableDeclaration(left.kind, [t.variableDeclarator(left.declarations[0].id, stepValue)]);\n  }\n\n  var template = buildForAwait();\n\n  (0, _babelTraverse2.default)(template, forAwaitVisitor, null, {\n    ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier(\"didIteratorError\"),\n    ITERATOR_COMPLETION: scope.generateUidIdentifier(\"iteratorNormalCompletion\"),\n    ITERATOR_ERROR_KEY: scope.generateUidIdentifier(\"iteratorError\"),\n    ITERATOR_KEY: scope.generateUidIdentifier(\"iterator\"),\n    GET_ITERATOR: helpers.getAsyncIterator,\n    OBJECT: node.right,\n    STEP_VALUE: stepValue,\n    STEP_KEY: stepKey,\n    AWAIT: helpers.wrapAwait\n  });\n\n  template = template.body.body;\n\n  var isLabeledParent = t.isLabeledStatement(parent);\n  var tryBody = template[3].block.body;\n  var loop = tryBody[0];\n\n  if (isLabeledParent) {\n    tryBody[0] = t.labeledStatement(parent.label, loop);\n  }\n\n  return {\n    replaceParent: isLabeledParent,\n    node: template,\n    declar: declar,\n    loop: loop\n  };\n};\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nvar _babelTemplate = require(\"babel-template\");\n\nvar _babelTemplate2 = _interopRequireDefault(_babelTemplate);\n\nvar _babelTraverse = require(\"babel-traverse\");\n\nvar _babelTraverse2 = _interopRequireDefault(_babelTraverse);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar buildForAwait = (0, _babelTemplate2.default)(\"\\n  function* wrapper() {\\n    var ITERATOR_COMPLETION = true;\\n    var ITERATOR_HAD_ERROR_KEY = false;\\n    var ITERATOR_ERROR_KEY = undefined;\\n    try {\\n      for (\\n        var ITERATOR_KEY = GET_ITERATOR(OBJECT), STEP_KEY, STEP_VALUE;\\n        (\\n          STEP_KEY = yield AWAIT(ITERATOR_KEY.next()),\\n          ITERATOR_COMPLETION = STEP_KEY.done,\\n          STEP_VALUE = yield AWAIT(STEP_KEY.value),\\n          !ITERATOR_COMPLETION\\n        );\\n        ITERATOR_COMPLETION = true) {\\n      }\\n    } catch (err) {\\n      ITERATOR_HAD_ERROR_KEY = true;\\n      ITERATOR_ERROR_KEY = err;\\n    } finally {\\n      try {\\n        if (!ITERATOR_COMPLETION && ITERATOR_KEY.return) {\\n          yield AWAIT(ITERATOR_KEY.return());\\n        }\\n      } finally {\\n        if (ITERATOR_HAD_ERROR_KEY) {\\n          throw ITERATOR_ERROR_KEY;\\n        }\\n      }\\n    }\\n  }\\n\");\n\nvar forAwaitVisitor = {\n  noScope: true,\n\n  Identifier: function Identifier(path, replacements) {\n    if (path.node.name in replacements) {\n      path.replaceInline(replacements[path.node.name]);\n    }\n  },\n  CallExpression: function CallExpression(path, replacements) {\n    var callee = path.node.callee;\n\n    if (t.isIdentifier(callee) && callee.name === \"AWAIT\" && !replacements.AWAIT) {\n      path.replaceWith(path.node.arguments[0]);\n    }\n  }\n};\n\nmodule.exports = exports[\"default\"];"]}