{"version":3,"sources":["index.js","tdz.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nexports.__esModule = true;\n\nvar _symbol = require(\"babel-runtime/core-js/symbol\");\n\nvar _symbol2 = _interopRequireDefault(_symbol);\n\nvar _create = require(\"babel-runtime/core-js/object/create\");\n\nvar _create2 = _interopRequireDefault(_create);\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nexports.default = function () {\n  return {\n    visitor: {\n      VariableDeclaration: function VariableDeclaration(path, file) {\n        var node = path.node,\n            parent = path.parent,\n            scope = path.scope;\n\n        if (!isBlockScoped(node)) return;\n        convertBlockScopedToVar(path, null, parent, scope, true);\n\n        if (node._tdzThis) {\n          var nodes = [node];\n\n          for (var i = 0; i < node.declarations.length; i++) {\n            var decl = node.declarations[i];\n            if (decl.init) {\n              var assign = t.assignmentExpression(\"=\", decl.id, decl.init);\n              assign._ignoreBlockScopingTDZ = true;\n              nodes.push(t.expressionStatement(assign));\n            }\n            decl.init = file.addHelper(\"temporalUndefined\");\n          }\n\n          node._blockHoist = 2;\n\n          if (path.isCompletionRecord()) {\n            nodes.push(t.expressionStatement(scope.buildUndefinedNode()));\n          }\n\n          path.replaceWithMultiple(nodes);\n        }\n      },\n      Loop: function Loop(path, file) {\n        var node = path.node,\n            parent = path.parent,\n            scope = path.scope;\n\n        t.ensureBlock(node);\n        var blockScoping = new BlockScoping(path, path.get(\"body\"), parent, scope, file);\n        var replace = blockScoping.run();\n        if (replace) path.replaceWith(replace);\n      },\n      CatchClause: function CatchClause(path, file) {\n        var parent = path.parent,\n            scope = path.scope;\n\n        var blockScoping = new BlockScoping(null, path.get(\"body\"), parent, scope, file);\n        blockScoping.run();\n      },\n      \"BlockStatement|SwitchStatement|Program\": function BlockStatementSwitchStatementProgram(path, file) {\n        if (!ignoreBlock(path)) {\n          var blockScoping = new BlockScoping(null, path, path.parent, path.scope, file);\n          blockScoping.run();\n        }\n      }\n    }\n  };\n};\n\nvar _babelTraverse = require(\"babel-traverse\");\n\nvar _babelTraverse2 = _interopRequireDefault(_babelTraverse);\n\nvar _tdz = require(\"./tdz\");\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nvar _values = require(\"lodash/values\");\n\nvar _values2 = _interopRequireDefault(_values);\n\nvar _extend = require(\"lodash/extend\");\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nvar _babelTemplate = require(\"babel-template\");\n\nvar _babelTemplate2 = _interopRequireDefault(_babelTemplate);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ignoreBlock(path) {\n  return t.isLoop(path.parent) || t.isCatchClause(path.parent);\n}\n\nvar buildRetCheck = (0, _babelTemplate2.default)(\"\\n  if (typeof RETURN === \\\"object\\\") return RETURN.v;\\n\");\n\nfunction isBlockScoped(node) {\n  if (!t.isVariableDeclaration(node)) return false;\n  if (node[t.BLOCK_SCOPED_SYMBOL]) return true;\n  if (node.kind !== \"let\" && node.kind !== \"const\") return false;\n  return true;\n}\n\nfunction convertBlockScopedToVar(path, node, parent, scope) {\n  var moveBindingsToParent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  if (!node) {\n    node = path.node;\n  }\n\n  if (!t.isFor(parent)) {\n    for (var i = 0; i < node.declarations.length; i++) {\n      var declar = node.declarations[i];\n      declar.init = declar.init || scope.buildUndefinedNode();\n    }\n  }\n\n  node[t.BLOCK_SCOPED_SYMBOL] = true;\n  node.kind = \"var\";\n\n  if (moveBindingsToParent) {\n    var parentScope = scope.getFunctionParent();\n    var ids = path.getBindingIdentifiers();\n    for (var name in ids) {\n      var binding = scope.getOwnBinding(name);\n      if (binding) binding.kind = \"var\";\n      scope.moveBindingTo(name, parentScope);\n    }\n  }\n}\n\nfunction isVar(node) {\n  return t.isVariableDeclaration(node, { kind: \"var\" }) && !isBlockScoped(node);\n}\n\nvar letReferenceBlockVisitor = _babelTraverse2.default.visitors.merge([{\n  Loop: {\n    enter: function enter(path, state) {\n      state.loopDepth++;\n    },\n    exit: function exit(path, state) {\n      state.loopDepth--;\n    }\n  },\n  Function: function Function(path, state) {\n    if (state.loopDepth > 0) {\n      path.traverse(letReferenceFunctionVisitor, state);\n    }\n    return path.skip();\n  }\n}, _tdz.visitor]);\n\nvar letReferenceFunctionVisitor = _babelTraverse2.default.visitors.merge([{\n  ReferencedIdentifier: function ReferencedIdentifier(path, state) {\n    var ref = state.letReferences[path.node.name];\n\n    if (!ref) return;\n\n    var localBinding = path.scope.getBindingIdentifier(path.node.name);\n    if (localBinding && localBinding !== ref) return;\n\n    state.closurify = true;\n  }\n}, _tdz.visitor]);\n\nvar hoistVarDeclarationsVisitor = {\n  enter: function enter(path, self) {\n    var node = path.node,\n        parent = path.parent;\n\n\n    if (path.isForStatement()) {\n      if (isVar(node.init, node)) {\n        var nodes = self.pushDeclar(node.init);\n        if (nodes.length === 1) {\n          node.init = nodes[0];\n        } else {\n          node.init = t.sequenceExpression(nodes);\n        }\n      }\n    } else if (path.isFor()) {\n      if (isVar(node.left, node)) {\n        self.pushDeclar(node.left);\n        node.left = node.left.declarations[0].id;\n      }\n    } else if (isVar(node, parent)) {\n      path.replaceWithMultiple(self.pushDeclar(node).map(function (expr) {\n        return t.expressionStatement(expr);\n      }));\n    } else if (path.isFunction()) {\n      return path.skip();\n    }\n  }\n};\n\nvar loopLabelVisitor = {\n  LabeledStatement: function LabeledStatement(_ref, state) {\n    var node = _ref.node;\n\n    state.innerLabels.push(node.label.name);\n  }\n};\n\nvar continuationVisitor = {\n  enter: function enter(path, state) {\n    if (path.isAssignmentExpression() || path.isUpdateExpression()) {\n      var bindings = path.getBindingIdentifiers();\n      for (var name in bindings) {\n        if (state.outsideReferences[name] !== path.scope.getBindingIdentifier(name)) continue;\n        state.reassignments[name] = true;\n      }\n    }\n  }\n};\n\nfunction loopNodeTo(node) {\n  if (t.isBreakStatement(node)) {\n    return \"break\";\n  } else if (t.isContinueStatement(node)) {\n    return \"continue\";\n  }\n}\n\nvar loopVisitor = {\n  Loop: function Loop(path, state) {\n    var oldIgnoreLabeless = state.ignoreLabeless;\n    state.ignoreLabeless = true;\n    path.traverse(loopVisitor, state);\n    state.ignoreLabeless = oldIgnoreLabeless;\n    path.skip();\n  },\n  Function: function Function(path) {\n    path.skip();\n  },\n  SwitchCase: function SwitchCase(path, state) {\n    var oldInSwitchCase = state.inSwitchCase;\n    state.inSwitchCase = true;\n    path.traverse(loopVisitor, state);\n    state.inSwitchCase = oldInSwitchCase;\n    path.skip();\n  },\n  \"BreakStatement|ContinueStatement|ReturnStatement\": function BreakStatementContinueStatementReturnStatement(path, state) {\n    var node = path.node,\n        parent = path.parent,\n        scope = path.scope;\n\n    if (node[this.LOOP_IGNORE]) return;\n\n    var replace = void 0;\n    var loopText = loopNodeTo(node);\n\n    if (loopText) {\n      if (node.label) {\n        if (state.innerLabels.indexOf(node.label.name) >= 0) {\n          return;\n        }\n\n        loopText = loopText + \"|\" + node.label.name;\n      } else {\n        if (state.ignoreLabeless) return;\n\n        if (state.inSwitchCase) return;\n\n        if (t.isBreakStatement(node) && t.isSwitchCase(parent)) return;\n      }\n\n      state.hasBreakContinue = true;\n      state.map[loopText] = node;\n      replace = t.stringLiteral(loopText);\n    }\n\n    if (path.isReturnStatement()) {\n      state.hasReturn = true;\n      replace = t.objectExpression([t.objectProperty(t.identifier(\"v\"), node.argument || scope.buildUndefinedNode())]);\n    }\n\n    if (replace) {\n      replace = t.returnStatement(replace);\n      replace[this.LOOP_IGNORE] = true;\n      path.skip();\n      path.replaceWith(t.inherits(replace, node));\n    }\n  }\n};\n\nvar BlockScoping = function () {\n  function BlockScoping(loopPath, blockPath, parent, scope, file) {\n    (0, _classCallCheck3.default)(this, BlockScoping);\n\n    this.parent = parent;\n    this.scope = scope;\n    this.file = file;\n\n    this.blockPath = blockPath;\n    this.block = blockPath.node;\n\n    this.outsideLetReferences = (0, _create2.default)(null);\n    this.hasLetReferences = false;\n    this.letReferences = (0, _create2.default)(null);\n    this.body = [];\n\n    if (loopPath) {\n      this.loopParent = loopPath.parent;\n      this.loopLabel = t.isLabeledStatement(this.loopParent) && this.loopParent.label;\n      this.loopPath = loopPath;\n      this.loop = loopPath.node;\n    }\n  }\n\n  BlockScoping.prototype.run = function run() {\n    var block = this.block;\n    if (block._letDone) return;\n    block._letDone = true;\n\n    var needsClosure = this.getLetReferences();\n\n    if (t.isFunction(this.parent) || t.isProgram(this.block)) {\n      this.updateScopeInfo();\n      return;\n    }\n\n    if (!this.hasLetReferences) return;\n\n    if (needsClosure) {\n      this.wrapClosure();\n    } else {\n      this.remap();\n    }\n\n    this.updateScopeInfo(needsClosure);\n\n    if (this.loopLabel && !t.isLabeledStatement(this.loopParent)) {\n      return t.labeledStatement(this.loopLabel, this.loop);\n    }\n  };\n\n  BlockScoping.prototype.updateScopeInfo = function updateScopeInfo(wrappedInClosure) {\n    var scope = this.scope;\n    var parentScope = scope.getFunctionParent();\n    var letRefs = this.letReferences;\n\n    for (var key in letRefs) {\n      var ref = letRefs[key];\n      var binding = scope.getBinding(ref.name);\n      if (!binding) continue;\n      if (binding.kind === \"let\" || binding.kind === \"const\") {\n        binding.kind = \"var\";\n\n        if (wrappedInClosure) {\n          scope.removeBinding(ref.name);\n        } else {\n          scope.moveBindingTo(ref.name, parentScope);\n        }\n      }\n    }\n  };\n\n  BlockScoping.prototype.remap = function remap() {\n    var letRefs = this.letReferences;\n    var scope = this.scope;\n\n    for (var key in letRefs) {\n      var ref = letRefs[key];\n\n      if (scope.parentHasBinding(key) || scope.hasGlobal(key)) {\n        if (scope.hasOwnBinding(key)) scope.rename(ref.name);\n\n        if (this.blockPath.scope.hasOwnBinding(key)) this.blockPath.scope.rename(ref.name);\n      }\n    }\n  };\n\n  BlockScoping.prototype.wrapClosure = function wrapClosure() {\n    if (this.file.opts.throwIfClosureRequired) {\n      throw this.blockPath.buildCodeFrameError(\"Compiling let/const in this block would add a closure \" + \"(throwIfClosureRequired).\");\n    }\n    var block = this.block;\n\n    var outsideRefs = this.outsideLetReferences;\n\n    if (this.loop) {\n      for (var name in outsideRefs) {\n        var id = outsideRefs[name];\n\n        if (this.scope.hasGlobal(id.name) || this.scope.parentHasBinding(id.name)) {\n          delete outsideRefs[id.name];\n          delete this.letReferences[id.name];\n\n          this.scope.rename(id.name);\n\n          this.letReferences[id.name] = id;\n          outsideRefs[id.name] = id;\n        }\n      }\n    }\n\n    this.has = this.checkLoop();\n\n    this.hoistVarDeclarations();\n\n    var params = (0, _values2.default)(outsideRefs);\n    var args = (0, _values2.default)(outsideRefs);\n\n    var isSwitch = this.blockPath.isSwitchStatement();\n\n    var fn = t.functionExpression(null, params, t.blockStatement(isSwitch ? [block] : block.body));\n    fn.shadow = true;\n\n    this.addContinuations(fn);\n\n    var ref = fn;\n\n    if (this.loop) {\n      ref = this.scope.generateUidIdentifier(\"loop\");\n      this.loopPath.insertBefore(t.variableDeclaration(\"var\", [t.variableDeclarator(ref, fn)]));\n    }\n\n    var call = t.callExpression(ref, args);\n    var ret = this.scope.generateUidIdentifier(\"ret\");\n\n    var hasYield = _babelTraverse2.default.hasType(fn.body, this.scope, \"YieldExpression\", t.FUNCTION_TYPES);\n    if (hasYield) {\n      fn.generator = true;\n      call = t.yieldExpression(call, true);\n    }\n\n    var hasAsync = _babelTraverse2.default.hasType(fn.body, this.scope, \"AwaitExpression\", t.FUNCTION_TYPES);\n    if (hasAsync) {\n      fn.async = true;\n      call = t.awaitExpression(call);\n    }\n\n    this.buildClosure(ret, call);\n\n    if (isSwitch) this.blockPath.replaceWithMultiple(this.body);else block.body = this.body;\n  };\n\n  BlockScoping.prototype.buildClosure = function buildClosure(ret, call) {\n    var has = this.has;\n    if (has.hasReturn || has.hasBreakContinue) {\n      this.buildHas(ret, call);\n    } else {\n      this.body.push(t.expressionStatement(call));\n    }\n  };\n\n  BlockScoping.prototype.addContinuations = function addContinuations(fn) {\n    var state = {\n      reassignments: {},\n      outsideReferences: this.outsideLetReferences\n    };\n\n    this.scope.traverse(fn, continuationVisitor, state);\n\n    for (var i = 0; i < fn.params.length; i++) {\n      var param = fn.params[i];\n      if (!state.reassignments[param.name]) continue;\n\n      var newParam = this.scope.generateUidIdentifier(param.name);\n      fn.params[i] = newParam;\n\n      this.scope.rename(param.name, newParam.name, fn);\n\n      fn.body.body.push(t.expressionStatement(t.assignmentExpression(\"=\", param, newParam)));\n    }\n  };\n\n  BlockScoping.prototype.getLetReferences = function getLetReferences() {\n    var _this = this;\n\n    var block = this.block;\n\n    var declarators = [];\n\n    if (this.loop) {\n      var init = this.loop.left || this.loop.init;\n      if (isBlockScoped(init)) {\n        declarators.push(init);\n        (0, _extend2.default)(this.outsideLetReferences, t.getBindingIdentifiers(init));\n      }\n    }\n\n    var addDeclarationsFromChild = function addDeclarationsFromChild(path, node) {\n      node = node || path.node;\n      if (t.isClassDeclaration(node) || t.isFunctionDeclaration(node) || isBlockScoped(node)) {\n        if (isBlockScoped(node)) {\n          convertBlockScopedToVar(path, node, block, _this.scope);\n        }\n        declarators = declarators.concat(node.declarations || node);\n      }\n      if (t.isLabeledStatement(node)) {\n        addDeclarationsFromChild(path.get(\"body\"), node.body);\n      }\n    };\n\n    if (block.body) {\n      for (var i = 0; i < block.body.length; i++) {\n        var declarPath = this.blockPath.get(\"body\")[i];\n        addDeclarationsFromChild(declarPath);\n      }\n    }\n\n    if (block.cases) {\n      for (var _i = 0; _i < block.cases.length; _i++) {\n        var consequents = block.cases[_i].consequent;\n\n        for (var j = 0; j < consequents.length; j++) {\n          var _declarPath = this.blockPath.get(\"cases\")[_i];\n          var declar = consequents[j];\n          addDeclarationsFromChild(_declarPath, declar);\n        }\n      }\n    }\n\n    for (var _i2 = 0; _i2 < declarators.length; _i2++) {\n      var _declar = declarators[_i2];\n\n      var keys = t.getBindingIdentifiers(_declar, false, true);\n      (0, _extend2.default)(this.letReferences, keys);\n      this.hasLetReferences = true;\n    }\n\n    if (!this.hasLetReferences) return;\n\n    var state = {\n      letReferences: this.letReferences,\n      closurify: false,\n      file: this.file,\n      loopDepth: 0\n    };\n\n    var loopOrFunctionParent = this.blockPath.find(function (path) {\n      return path.isLoop() || path.isFunction();\n    });\n    if (loopOrFunctionParent && loopOrFunctionParent.isLoop()) {\n      state.loopDepth++;\n    }\n\n    this.blockPath.traverse(letReferenceBlockVisitor, state);\n\n    return state.closurify;\n  };\n\n  BlockScoping.prototype.checkLoop = function checkLoop() {\n    var state = {\n      hasBreakContinue: false,\n      ignoreLabeless: false,\n      inSwitchCase: false,\n      innerLabels: [],\n      hasReturn: false,\n      isLoop: !!this.loop,\n      map: {},\n      LOOP_IGNORE: (0, _symbol2.default)()\n    };\n\n    this.blockPath.traverse(loopLabelVisitor, state);\n    this.blockPath.traverse(loopVisitor, state);\n\n    return state;\n  };\n\n  BlockScoping.prototype.hoistVarDeclarations = function hoistVarDeclarations() {\n    this.blockPath.traverse(hoistVarDeclarationsVisitor, this);\n  };\n\n  BlockScoping.prototype.pushDeclar = function pushDeclar(node) {\n    var declars = [];\n    var names = t.getBindingIdentifiers(node);\n    for (var name in names) {\n      declars.push(t.variableDeclarator(names[name]));\n    }\n\n    this.body.push(t.variableDeclaration(node.kind, declars));\n\n    var replace = [];\n\n    for (var i = 0; i < node.declarations.length; i++) {\n      var declar = node.declarations[i];\n      if (!declar.init) continue;\n\n      var expr = t.assignmentExpression(\"=\", declar.id, declar.init);\n      replace.push(t.inherits(expr, declar));\n    }\n\n    return replace;\n  };\n\n  BlockScoping.prototype.buildHas = function buildHas(ret, call) {\n    var body = this.body;\n\n    body.push(t.variableDeclaration(\"var\", [t.variableDeclarator(ret, call)]));\n\n    var retCheck = void 0;\n    var has = this.has;\n    var cases = [];\n\n    if (has.hasReturn) {\n      retCheck = buildRetCheck({\n        RETURN: ret\n      });\n    }\n\n    if (has.hasBreakContinue) {\n      for (var key in has.map) {\n        cases.push(t.switchCase(t.stringLiteral(key), [has.map[key]]));\n      }\n\n      if (has.hasReturn) {\n        cases.push(t.switchCase(null, [retCheck]));\n      }\n\n      if (cases.length === 1) {\n        var single = cases[0];\n        body.push(t.ifStatement(t.binaryExpression(\"===\", ret, single.test), single.consequent[0]));\n      } else {\n        if (this.loop) {\n          for (var i = 0; i < cases.length; i++) {\n            var caseConsequent = cases[i].consequent[0];\n            if (t.isBreakStatement(caseConsequent) && !caseConsequent.label) {\n              caseConsequent.label = this.loopLabel = this.loopLabel || this.scope.generateUidIdentifier(\"loop\");\n            }\n          }\n        }\n\n        body.push(t.switchStatement(ret, cases));\n      }\n    } else {\n      if (has.hasReturn) {\n        body.push(retCheck);\n      }\n    }\n  };\n\n  return BlockScoping;\n}();\n\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\nexports.visitor = undefined;\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction getTDZStatus(refPath, bindingPath) {\n  var executionStatus = bindingPath._guessExecutionStatusRelativeTo(refPath);\n\n  if (executionStatus === \"before\") {\n    return \"inside\";\n  } else if (executionStatus === \"after\") {\n    return \"outside\";\n  } else {\n    return \"maybe\";\n  }\n}\n\nfunction buildTDZAssert(node, file) {\n  return t.callExpression(file.addHelper(\"temporalRef\"), [node, t.stringLiteral(node.name), file.addHelper(\"temporalUndefined\")]);\n}\n\nfunction isReference(node, scope, state) {\n  var declared = state.letReferences[node.name];\n  if (!declared) return false;\n\n  return scope.getBindingIdentifier(node.name) === declared;\n}\n\nvar visitor = exports.visitor = {\n  ReferencedIdentifier: function ReferencedIdentifier(path, state) {\n    if (!this.file.opts.tdz) return;\n\n    var node = path.node,\n        parent = path.parent,\n        scope = path.scope;\n\n\n    if (path.parentPath.isFor({ left: node })) return;\n    if (!isReference(node, scope, state)) return;\n\n    var bindingPath = scope.getBinding(node.name).path;\n\n    var status = getTDZStatus(path, bindingPath);\n    if (status === \"inside\") return;\n\n    if (status === \"maybe\") {\n      var assert = buildTDZAssert(node, state.file);\n\n      bindingPath.parent._tdzThis = true;\n\n      path.skip();\n\n      if (path.parentPath.isUpdateExpression()) {\n        if (parent._ignoreBlockScopingTDZ) return;\n        path.parentPath.replaceWith(t.sequenceExpression([assert, parent]));\n      } else {\n        path.replaceWith(assert);\n      }\n    } else if (status === \"outside\") {\n      path.replaceWith(t.throwStatement(t.inherits(t.newExpression(t.identifier(\"ReferenceError\"), [t.stringLiteral(node.name + \" is not defined - temporal dead zone\")]), node)));\n    }\n  },\n\n\n  AssignmentExpression: {\n    exit: function exit(path, state) {\n      if (!this.file.opts.tdz) return;\n\n      var node = path.node;\n\n      if (node._ignoreBlockScopingTDZ) return;\n\n      var nodes = [];\n      var ids = path.getBindingIdentifiers();\n\n      for (var name in ids) {\n        var id = ids[name];\n\n        if (isReference(id, path.scope, state)) {\n          nodes.push(buildTDZAssert(id, state.file));\n        }\n      }\n\n      if (nodes.length) {\n        node._ignoreBlockScopingTDZ = true;\n        nodes.push(node);\n        path.replaceWithMultiple(nodes.map(t.expressionStatement));\n      }\n    }\n  }\n};"]}