{"version":3,"sources":["index.js","lib/minify-weight.js","lib/minify-family.js","lib/uniqs.js","lib/minify-font.js","lib/keywords.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,AENA,AHSA,AENA;AHUA,AENA,AENA,AHSA,AENA;AHUA,AENA,AENA,AHSA,AENA;AHUA,AKfA,AHSA,AENA,AHSA,AENA;AHUA,AKfA,AHSA,AENA,AHSA,AENA;AHUA,AKfA,AHSA,AENA,ADGA;AHUA,AKfA,AHSA,AENA,ADGA;AHUA,AKfA,AHSA,AENA,ADGA;AHUA,AKfA,AHSA,AENA,ADGA;AHUA,AKfA,AHSA,AENA,ADGA;AHUA,AKfA,AHSA,AENA,ADGA;AHUA,AKfA,AHSA,AENA,ADGA;AHUA,AKfA,AHSA,AENA,ADGA;AHUA,AKfA,AHSA,AENA,ADGA;AHUA,AKfA,AHSA,AENA,ADGA;AHUA,AKfA,AHSA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AJaA,AENA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _postcss = require('postcss');\n\nvar _postcss2 = _interopRequireDefault(_postcss);\n\nvar _postcssValueParser = require('postcss-value-parser');\n\nvar _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);\n\nvar _minifyWeight = require('./lib/minify-weight');\n\nvar _minifyWeight2 = _interopRequireDefault(_minifyWeight);\n\nvar _minifyFamily = require('./lib/minify-family');\n\nvar _minifyFamily2 = _interopRequireDefault(_minifyFamily);\n\nvar _minifyFont = require('./lib/minify-font');\n\nvar _minifyFont2 = _interopRequireDefault(_minifyFont);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction transform(opts, decl) {\n    let tree;\n    let prop = decl.prop.toLowerCase();\n\n    if (prop === 'font-weight') {\n        decl.value = (0, _minifyWeight2.default)(decl.value);\n    } else if (prop === 'font-family') {\n        tree = (0, _postcssValueParser2.default)(decl.value);\n        tree.nodes = (0, _minifyFamily2.default)(tree.nodes, opts);\n        decl.value = tree.toString();\n    } else if (prop === 'font') {\n        tree = (0, _postcssValueParser2.default)(decl.value);\n        tree.nodes = (0, _minifyFont2.default)(tree.nodes, opts);\n        decl.value = tree.toString();\n    }\n}\n\nexports.default = _postcss2.default.plugin('postcss-minify-font-values', opts => {\n    opts = Object.assign({}, {\n        removeAfterKeyword: false,\n        removeDuplicates: true,\n        removeQuotes: true\n    }, opts);\n\n    return css => css.walkDecls(/font/i, transform.bind(null, opts));\n});\nmodule.exports = exports['default'];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (value) {\n    const valueInLowerCase = value.toLowerCase();\n\n    return valueInLowerCase === 'normal' ? '400' : valueInLowerCase === 'bold' ? '700' : value;\n};\n\n;\nmodule.exports = exports['default'];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (nodes, opts) {\n    let family = [];\n    let last = null;\n    let i, max;\n\n    nodes.forEach((node, index, arr) => {\n        if (node.type === 'string' || node.type === 'function') {\n            family.push(node);\n        } else if (node.type === 'word') {\n            if (!last) {\n                last = { type: 'word', value: '' };\n                family.push(last);\n            }\n\n            last.value += node.value;\n        } else if (node.type === 'space') {\n            if (last && index !== arr.length - 1) {\n                last.value += ' ';\n            }\n        } else {\n            last = null;\n        }\n    });\n\n    family = family.map(node => {\n        if (node.type === 'string') {\n            const isKeyword = regexKeyword.test(node.value);\n\n            if (!opts.removeQuotes || isKeyword || /[0-9]/.test(node.value.slice(0, 1))) {\n                return (0, _postcssValueParser.stringify)(node);\n            }\n\n            let escaped = escapeIdentifierSequence(node.value);\n\n            if (escaped.length < node.value.length + 2) {\n                return escaped;\n            }\n        }\n\n        return (0, _postcssValueParser.stringify)(node);\n    });\n\n    if (opts.removeAfterKeyword) {\n        for (i = 0, max = family.length; i < max; i += 1) {\n            if (~genericFontFamilykeywords.indexOf(family[i].toLowerCase())) {\n                family = family.slice(0, i + 1);\n                break;\n            }\n        }\n    }\n\n    if (opts.removeDuplicates) {\n        family = uniqs(family);\n    }\n\n    return [{\n        type: 'word',\n        value: family.join()\n    }];\n};\n\nvar _postcssValueParser = require('postcss-value-parser');\n\nvar _uniqs = require('./uniqs');\n\nvar _uniqs2 = _interopRequireDefault(_uniqs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst uniqs = (0, _uniqs2.default)('monospace');\nconst globalKeywords = ['inherit', 'initial', 'unset'];\nconst genericFontFamilykeywords = ['sans-serif', 'serif', 'fantasy', 'cursive', 'monospace', 'system-ui'];\n\nfunction makeArray(value, length) {\n    let array = [];\n    while (length--) {\n        array[length] = value;\n    }\n    return array;\n}\n\nconst regexSimpleEscapeCharacters = /[ !\"#$%&'()*+,.\\/;<=>?@\\[\\\\\\]^`{|}~]/;\n\nfunction escape(string, escapeForString) {\n    let counter = 0;\n    let character = null;\n    let charCode = null;\n    let value = null;\n    let output = '';\n\n    while (counter < string.length) {\n        character = string.charAt(counter++);\n        charCode = character.charCodeAt();\n\n        // \\r is already tokenized away at this point\n        // `:` can be escaped as `\\:`, but that fails in IE < 8\n        if (!escapeForString && /[\\t\\n\\v\\f:]/.test(character)) {\n            value = '\\\\' + charCode.toString(16) + ' ';\n        } else if (!escapeForString && regexSimpleEscapeCharacters.test(character)) {\n            value = '\\\\' + character;\n        } else {\n            value = character;\n        }\n\n        output += value;\n    }\n\n    if (!escapeForString) {\n        if (/^-[-\\d]/.test(output)) {\n            output = '\\\\-' + output.slice(1);\n        }\n\n        const firstChar = string.charAt(0);\n\n        if (/\\d/.test(firstChar)) {\n            output = '\\\\3' + firstChar + ' ' + output.slice(1);\n        }\n    }\n\n    return output;\n}\n\nconst regexKeyword = new RegExp(genericFontFamilykeywords.concat(globalKeywords).join('|'), 'i');\nconst regexInvalidIdentifier = /^(-?\\d|--)/;\nconst regexSpaceAtStart = /^\\x20/;\nconst regexWhitespace = /[\\t\\n\\f\\r\\x20]/g;\nconst regexIdentifierCharacter = /^[a-zA-Z\\d\\xa0-\\uffff_-]+$/;\nconst regexConsecutiveSpaces = /(\\\\(?:[a-fA-F0-9]{1,6}\\x20|\\x20))?(\\x20{2,})/g;\nconst regexTrailingEscape = /\\\\[a-fA-F0-9]{0,6}\\x20$/;\nconst regexTrailingSpace = /\\x20$/;\n\nfunction escapeIdentifierSequence(string) {\n    let identifiers = string.split(regexWhitespace);\n    let index = 0;\n    let result = [];\n    let escapeResult;\n\n    while (index < identifiers.length) {\n        let subString = identifiers[index++];\n\n        if (subString === '') {\n            result.push(subString);\n            continue;\n        }\n\n        escapeResult = escape(subString, false);\n\n        if (regexIdentifierCharacter.test(subString)) {\n            // the font family name part consists of allowed characters exclusively\n            if (regexInvalidIdentifier.test(subString)) {\n                // the font family name part starts with two hyphens, a digit, or a\n                // hyphen followed by a digit\n                if (index === 1) {\n                    // if this is the first item\n                    result.push(escapeResult);\n                } else {\n                    // if it’s not the first item, we can simply escape the space\n                    // between the two identifiers to merge them into a single\n                    // identifier rather than escaping the start characters of the\n                    // second identifier\n                    result[index - 2] += '\\\\';\n                    result.push(escape(subString, true));\n                }\n            } else {\n                // the font family name part doesn’t start with two hyphens, a digit,\n                // or a hyphen followed by a digit\n                result.push(escapeResult);\n            }\n        } else {\n            // the font family name part contains invalid identifier characters\n            result.push(escapeResult);\n        }\n    }\n\n    result = result.join(' ').replace(regexConsecutiveSpaces, ($0, $1, $2) => {\n        const spaceCount = $2.length;\n        const escapesNeeded = Math.floor(spaceCount / 2);\n        const array = makeArray('\\\\ ', escapesNeeded);\n\n        if (spaceCount % 2) {\n            array[escapesNeeded - 1] += '\\\\ ';\n        }\n\n        return ($1 || '') + ' ' + array.join(' ');\n    });\n\n    // Escape trailing spaces unless they’re already part of an escape\n    if (regexTrailingSpace.test(result) && !regexTrailingEscape.test(result)) {\n        result = result.replace(regexTrailingSpace, '\\\\ ');\n    }\n\n    if (regexSpaceAtStart.test(result)) {\n        result = '\\\\ ' + result.slice(1);\n    }\n\n    return result;\n}\n\n;\nmodule.exports = exports['default'];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = uniqueExcept;\nfunction uniqueExcept(exclude) {\n    return function unique() {\n        const list = Array.prototype.concat.apply([], arguments);\n        return list.filter((item, i) => {\n            if (item.toLowerCase() === exclude) {\n                return true;\n            }\n            return i === list.indexOf(item);\n        });\n    };\n};\nmodule.exports = exports[\"default\"];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (nodes, opts) {\n    let i, max, node, familyStart, family;\n    let hasSize = false;\n\n    for (i = 0, max = nodes.length; i < max; i += 1) {\n        node = nodes[i];\n        if (node.type === 'word') {\n            if (hasSize) {\n                continue;\n            }\n            const value = node.value.toLowerCase();\n            if (value === 'normal' || ~_keywords2.default.style.indexOf(value) || ~_keywords2.default.variant.indexOf(value) || ~_keywords2.default.stretch.indexOf(value)) {\n                familyStart = i;\n            } else if (~_keywords2.default.weight.indexOf(value)) {\n                node.value = (0, _minifyWeight2.default)(value);\n                familyStart = i;\n            } else if (~_keywords2.default.size.indexOf(value) || (0, _postcssValueParser.unit)(value)) {\n                familyStart = i;\n                hasSize = true;\n            }\n        } else if (node.type === 'div' && node.value === '/') {\n            familyStart = i + 1;\n            break;\n        }\n    }\n\n    familyStart += 2;\n    family = (0, _minifyFamily2.default)(nodes.slice(familyStart), opts);\n    return nodes.slice(0, familyStart).concat(family);\n};\n\nvar _postcssValueParser = require('postcss-value-parser');\n\nvar _keywords = require('./keywords');\n\nvar _keywords2 = _interopRequireDefault(_keywords);\n\nvar _minifyFamily = require('./minify-family');\n\nvar _minifyFamily2 = _interopRequireDefault(_minifyFamily);\n\nvar _minifyWeight = require('./minify-weight');\n\nvar _minifyWeight2 = _interopRequireDefault(_minifyWeight);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n;\nmodule.exports = exports['default'];","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = {\n    style: ['italic', 'oblique'],\n    variant: ['small-caps'],\n    weight: ['100', '200', '300', '400', '500', '600', '700', '800', '900', 'bold', 'lighter', 'bolder'],\n    stretch: ['ultra-condensed', 'extra-condensed', 'condensed', 'semi-condensed', 'semi-expanded', 'expanded', 'extra-expanded', 'ultra-expanded'],\n    size: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large', 'larger', 'smaller']\n};\nmodule.exports = exports['default'];"]}