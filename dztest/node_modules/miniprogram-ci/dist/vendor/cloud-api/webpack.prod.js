const path = require('path')
const UglifyJsPlugin = require('uglifyjs-webpack-plugin')
const LimitChunkCountPlugin = require('webpack').optimize.LimitChunkCountPlugin
// This helper function is not strictly necessary.
// I just don't like repeating the path.join a dozen times.
function srcPath(subdir) {
  return subdir ? path.join(__dirname, 'src', subdir) : path.join(__dirname, 'src')
}

const config = {
  plugins: [
    new LimitChunkCountPlugin({
      maxChunks: 1,
    }),
  ],
  optimization: {
    // minimize: false,
    minimizer: [new UglifyJsPlugin({
      parallel: true,
      cache: true,
      uglifyOptions: {
        ecma: 7,
        /*
            inlining is broken sometimes where inlined function uses the same variable name as inlining function.
            See https://github.com/mishoo/UglifyJS2/issues/2842, https://github.com/mishoo/UglifyJS2/issues/2843
         */
        compress: {
          inline: false
        },
      },
      sourceMap: true,
    })]
  },
  mode: 'production',
  devtool: 'source-map',
  /* The entry point of the application. Webpack uses this information to create the dependency tree which is used to bundle the scripts.*/
  entry: ['./src/index.ts'],
  /* This information is used to give the name of the bundled file and the location of the bundled file. */
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'index.js',
    libraryTarget: 'commonjs2',
  },
  /* The extensions which will be imported or required in the application scripts. */
  resolve: {
    extensions: ['.ts', '.tsx', '.js', '.json'],
    alias: {
      '@': srcPath(),
    },
  },
  module: {
    /* Define the loaders to be used. Regex will test the type of files on which the loader is to be applied. The excluded files are also mentioned. Loaders are used mainly to preprocess/transpile the file when imported or required in the scripts before bundling. */
    rules: [{
      test: /\.tsx?$/,
      loader: 'ts-loader',
      exclude: /node_modules/
    }]
  },
}

module.exports = config
