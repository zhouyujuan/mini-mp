"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.uploadFunction=void 0;const cloudapi_1=require("./cloudapi"),cloudAPI=require("../vendor/cloud-api"),utils_1=require("./utils"),log=require("../utils/log"),CodeError=require("../utils/error"),config_1=require("../config"),locales=require("../utils/locales/locales"),HelloWordCode="UEsDBBQACAAIALB+WU4AAAAAAAAAAAAAAAAIABAAaW5kZXguanNVWAwAAZ9zXPuec1z1ARQAdY7BCsIwEETv+Yoll6ZQ+wOhnv0DD+IhxkWC664kWwmI/27V3IpzGuYNw3RzQSiaU9TOG6x3yVrGW0gMEzh8IOsAUVixfkwgOoV47WHawtPAooUVIRxJLs7ukEhgL5nOtl/h79qf+GBZeIM1FbXHdac9aKC9cDwTDfCb9eblzRtQSwcI6+pcr4AAAADOAAAAUEsBAhUDFAAIAAgAsH5ZTuvqXK+AAAAAzgAAAAgADAAAAAAAAAAAQKSBAAAAAGluZGV4LmpzVVgIAAGfc1z7nnNcUEsFBgAAAAABAAEAQgAAAMYAAAAAAA==",requiredParams=["project","name","path"];async function uploadFunction(e){requiredParams.forEach(t=>{if(!e[t])throw new CodeError(locales.config.PARAM_ERROR.format("cloud.uploadFunction",t),config_1.PARAM_ERROR)});const{project:t,remoteNpmInstall:o=!1,name:n,path:a,env:c}=e,i=await t.getExtAppid();cloudapi_1.initCloudAPI(i||t.appid),log.info(`will upload code under ${a} as cloudfunction '${n}' of env ${c}. remote-npm-install: ${o}`);const{envList:r}=await cloudAPI.tcbGetEnvironments({},{request:cloudapi_1.boundTransactRequest(t),transactType:cloudAPI.TransactType.IDE}),s=r.find(e=>e.envId===c);if(!s)throw new Error("env not found");const u=s.functions[0].region,{clsLogsetId:l,clsTopicId:d}=getLogServiceProperties(s),p=await cloudapi_1.get3rdCloudCodeSecret(t);log.info("checking cloudfunctio status, will only proceed on normal status"),await waitFuncDeploy({namespace:c,region:u,functionName:n,codeSecret:p,topts:{request:cloudapi_1.boundTransactRequest(e.project),transactType:cloudAPI.TransactType.IDE}});let A,f=!1;try{if(A=await cloudAPI.scfGetFunctionInfo({namespace:c,region:"",functionName:n,codeSecret:p},{request:cloudapi_1.boundTransactRequest(t),transactType:cloudAPI.TransactType.IDE}),"DeleteFailed"===A.status)throw new Error("delete failed")}catch(e){if("ResourceNotFound.FunctionName"!==e.code)throw e;f=!0}if(log.info("get cloudfunction info done"),log.info(`will ${f?"create":"update"} cloudfunction`),f)await cloudAPI.scfCreateFunction({functionName:n,code:{zipFile:HelloWordCode},handler:"index.main",description:"",memorySize:256,timeout:3,environment:{variables:[]},role:"TCB_QcsRole",runtime:"Nodejs8.9",namespace:c,region:u,stamp:"MINI_QCBASE",installDependency:o,codeSecret:p,clsLogsetId:l,clsTopicId:d},{request:cloudapi_1.boundTransactRequest(e.project),transactType:cloudAPI.TransactType.IDE}),log.info("create cloudfunction done, continue to update code");else{if("Updating"===A.status)throw new Error("there's another ongoing update, please wait for it to complete and try again later");const t=o?"TRUE":"FALSE";A.installDependency!==t&&(log.info("updating cloudfunction info"),await cloudAPI.scfUpdateFunctionInfo({namespace:c,region:u,functionName:n,installDependency:o,clsLogsetId:l,clsTopicId:d},{request:cloudapi_1.boundTransactRequest(e.project),transactType:cloudAPI.TransactType.IDE}),log.info("update cloudfunction info done, waiting for it to take into effect"),await waitFuncDeploy({namespace:c,region:u,functionName:n,codeSecret:p,topts:{request:cloudapi_1.boundTransactRequest(e.project),transactType:cloudAPI.TransactType.IDE}}),log.info("cloudfunction info updated"))}const g=utils_1.zipFile(a,{ignore:o?["node_modules"]:void 0}),I=await utils_1.zipToBuffer(g);log.info("zip file done, updating cloudfunction code"),await cloudAPI.scfUpdateFunction({functionName:n,namespace:c,region:u,handler:"index.main",installDependency:o,fileData:I.toString("base64"),codeSecret:p},{request:cloudapi_1.boundTransactRequest(e.project),transactType:cloudAPI.TransactType.IDE}),log.info("cloudfunction code updated, "+(o?"installing dependencies in the cloud and deploying":"deploying")),await waitFuncDeploy({namespace:c,region:u,functionName:n,codeSecret:p,topts:{request:cloudapi_1.boundTransactRequest(e.project),transactType:cloudAPI.TransactType.IDE}}),log.info("deployed");return{filesCount:Object.keys(g.files).length,packSize:I.byteLength}}exports.uploadFunction=uploadFunction;const waitFuncDeploy=async e=>new Promise(async(t,o)=>{let n=!1;const{namespace:a,region:c,functionName:i,onStatusUpdate:r=(t=>{log.info(`env ${e.namespace}'s cloudfunction '${e.functionName}' status: ${t}`)}),maxWaitTimeout:s=9e5,codeSecret:u}=e,l=setTimeout(()=>{n||(n=!0,o(new Error("timeout waiting for function to deploy")))},s);try{let o="";const l=+new Date;for(;!n&&+new Date-l<s;){const s=await cloudAPI.scfGetFunctionInfo({namespace:a,region:c,functionName:i,codeSecret:u},e.topts);switch(s.status!==o&&(r(s.status),o=s.status),s.status){case"Creating":case"Updating":case"Publishing":case"UpdatingAndPublishing":break;case"CreateFailed":throw new Error("create function failed: "+s.statusDesc);case"UpdateFailed":throw new Error("update function failed: "+s.statusDesc);case"Active":n=!0,t(void 0)}}}catch(e){try{log.error(`upload ${a} ${i} failed: `,"string"==typeof e?e:JSON.stringify(e))}catch(e){log.error(`upload ${a} ${i} failed: `,e.toString())}clearTimeout(l),o(e)}});function getLogServiceProperties(e){let t,o;try{const n=e.logServices[0];t=n.logsetId,o=n.topicId}catch(e){}return{clsLogsetId:t,clsTopicId:o}}