"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.upload=exports.SIGNATURE_FILE_NAME=void 0;const fs=require("fs"),request_1=require("../utils/request"),compile_1=require("../compile"),pack_1=require("../pack/pack"),zlib=require("zlib"),sign_1=require("../utils/sign"),tools_1=require("../utils/tools"),config_1=require("../config"),taskstatus_1=require("../utils/taskstatus"),log=require("../utils/log"),CodeError=require("../utils/error"),locales=require("../utils/locales/locales"),QueryString=require("querystring"),url_config_1=require("../utils/url_config"),terminalQrcode_1=require("../utils/terminalQrcode"),jsonParse_1=require("../utils/jsonParse"),cache_1=require("../utils/cache"),cos_upload_1=require("./cos-upload");async function upload(e){const{project:o,setting:r={},desc:t=`robot ${e.robot||"1"} use miniprogram-ci to upload at ${tools_1.formatTime(new Date)}`,version:i="",robot:s="1",onProgressUpdate:a=function(e){console.log(""+e)},test:n,pagePath:c,searchQuery:l,threads:u=0,useCOS:d=!1}=e;if(process.env.COMPILE_THREADS=u+"",!i)throw new CodeError(locales.config.PARAM_ERROR.format("upload","version"),config_1.PARAM_ERROR);if(!o)throw new CodeError(locales.config.PARAM_ERROR.format("upload","project"),config_1.PARAM_ERROR);cache_1.cacheManager.clean();let p=await compile_1.compile(o,{setting:r,onProgressUpdate:a}),g=config_1.CI_VERSION;const f={codeprotect:r.codeProtect?1:0,type:o.type,appid:o.appid,version:i,desc:t,robot:s},_={scene:e.scene||1011};let y;c&&(_.path=c,f.path=c),l&&(_.query=QueryString.parse(l)),f.debugLaunchInfo=JSON.stringify(_),c&&l&&(f.path+="?"+l);let b={};try{y=await o.getFile(o.miniprogramRoot,"ext.json"),b=JSON.parse(y.toString("utf-8"))}catch(e){}if(b&&(b.extEnable&&(f.extAppId=b.extAppid),b.directCommit)){let e="";e=b.extEnable?"The code will be uploaded into the waiting list of extAppid.":"The code will be uploaded into the draft box of the third-party platform.",log.warn(e)}try{const r=new taskstatus_1.TaskStatus(locales.config.UPLOAD);a(r);const t=`${n?url_config_1.TEST_SOURCE_URL:url_config_1.UPLOAD_URL}?${QueryString.stringify(f)}`;log.info("request url:",t);let i,c=!1,l=0;if(d){const e=await cos_upload_1.uploadByCos(p,t,o,s);e.fallback?c=e.fallback:(i={body:e.body},l=e.uploadCOSCostTime)}if(!d||c){const e=await sign_1.getSignature(o.privateKey,o.appid);p[exports.SIGNATURE_FILE_NAME]=JSON.stringify({signature:e,version:g});const r=pack_1.pack(p),s=zlib.gzipSync(r.buffer);let a=(await request_1.request({url:t,method:"post",body:s})).body.toString();if(i=jsonParse_1.jsonRespParse(a,t),0!==i.errCode)throw new Error(a)}r.done(),a(r);const u={};if(Array.isArray(i.body.subpackage_info)){const e=i.body.subpackage_info;u.subPackageInfo=e}if(Array.isArray(i.body.ext_plugin_info)){const e=i.body.ext_plugin_info;u.pluginInfo=e.map(e=>({pluginProviderAppid:e.provider,version:e.version,size:e.size}))}if(e.test){if(!i.body.qrcode_img)throw new Error("No `qrcode_img` in response.");if("terminal"===e.qrcodeFormat)try{const e=await terminalQrcode_1.generateTerminalQrcode(i.body.qrcode_img);log.log(e),log.log("terminal qrcode shown above")}catch(e){log.error("Termianl qrcode generate failed, but you can still visit the dev version on your cell phone.")}else if(e.qrcodeOutputDest)if("image"===e.qrcodeFormat)try{fs.writeFileSync(e.qrcodeOutputDest,Buffer.from(i.body.qrcode_img,"base64")),log.info(`Qrcode image saved, file path: '${e.qrcodeOutputDest}'`)}catch(e){throw new Error("write qrcode image error: "+JSON.stringify(e))}else if("base64"===e.qrcodeFormat)try{fs.writeFileSync(e.qrcodeOutputDest,"data:image/jpeg;base64,"+i.body.qrcode_img,"utf8"),log.info(`Qrcode base64 file saved, file path: '${e.qrcodeOutputDest}'`)}catch(e){throw new Error("write qrcode base64 error: "+JSON.stringify(e))}}if(!e.test&&i.body&&i.body.dev_plugin_id){const{dev_plugin_id:e}=i.body;log.log("Development Version Plugin ID: "+e),u.devPluginId=e}return u}catch(e){throw new CodeError(e.toString(),config_1.UPLOAD_CGI_ERR)}}exports.SIGNATURE_FILE_NAME="ci.signature",exports.upload=upload;