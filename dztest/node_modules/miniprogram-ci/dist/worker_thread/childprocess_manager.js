"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.childProcessManager=void 0;const path=require("path"),child_process_1=require("child_process"),config_1=require("./config"),EventEmitter=require("events"),log=require("../utils/log"),os=require("os"),cpus=os.cpus().length,FORK_PATH=path.posix.join(__dirname,"./childprocess.js"),MAX_TASK_TRY_TIME=2;class ChildProcessInstance extends EventEmitter{constructor(s){super(),this.status=config_1.EChildProcessStatus.free,this._lastActiveTime=0,this._taskMap={},this._fullload_task_count=4,this._suicideTime=config_1.SUICIDE_TIME["miniprogram-ci"],this._fullload_task_count=s;const t={stdio:["pipe","pipe","pipe","ipc"],env:Object.assign({},process.env)};if(t.env.isDevtools=process.__nwjs&&"wechatwebdevtools"===nw.App.manifest.appname,t.env.isDevtools){this._suicideTime=config_1.SUICIDE_TIME.devtools;let s=path.join(path.dirname(process.execPath),"node");"darwin"!==process.platform&&(s+=".exe"),t.execPath=s}const e=child_process_1.fork(FORK_PATH,["--expose-gc"],t);e.stdout.setEncoding("utf8"),e.stdout.on("data",s=>{log.log("child process stdout: "+s)}),e.stderr.on("data",s=>{log.error("child process stderr: "+s)}),e.on("message",this.onChildProcessMessage.bind(this,e)),e.on("exit",s=>{this.emit("exit",{code:s,status:this.status,tasks:Object.values(this._taskMap),pid:e.pid})}),e.unref(),this._instance=e}onChildProcessMessage(s,t){if("object"!=typeof t)return void log.error("unrecognized message from child process",t);const{command:e,data:i}=t;e===config_1.COMMAND.TASK_DONE&&this.onTaskDone(i)}onTaskDone(s){const{taskId:t,result:e}=s,i=this._taskMap[t];delete this._taskMap[t],i?(i.resolve&&(i.onStatusUpdate(config_1.ETaskStatus.done),i.resolve(e)),0===Object.keys(this._taskMap).length&&(this.status=config_1.EChildProcessStatus.free,this.setUpSuicideTimer()),this.emit("taskDone")):log.error(`child process task: ${t} not found`)}setUpSuicideTimer(){this._suicideTimer=setTimeout(()=>{clearTimeout(this._suicideTimer),this.status===config_1.EChildProcessStatus.free?(this.status=config_1.EChildProcessStatus.dying,this._instance.kill("SIGTERM")):this._suicideTimer||this.setUpSuicideTimer()},this._suicideTime)}runTask(s){clearTimeout(this._suicideTimer),this.status=config_1.EChildProcessStatus.busy,this._lastActiveTime=Date.now();const t=getId();this._taskMap[t]=s,Object.keys(this._taskMap).length>=this._fullload_task_count?this.status=config_1.EChildProcessStatus.fullload:this.status=config_1.EChildProcessStatus.busy,s.onStatusUpdate(config_1.ETaskStatus.progress),this._instance.send({command:config_1.COMMAND.RUN_TASK,data:{taskId:t,taskName:s.name,data:s.data}})}}const getId=(()=>{let s=0;return()=>s++})();class TaskManager{constructor(){this._taskQueue=[],this.onChildProcessExit=s=>{const{code:t,status:e,tasks:i,pid:o}=s;if(this._instance=void 0,e===config_1.EChildProcessStatus.busy||e===config_1.EChildProcessStatus.fullload)for(const s of i)s.retryTimes++,s.retryTimes<=2?(log.error(`child process: ${o} exit with code: ${t} when it is busy, retry ${s.retryTimes} times`),this._taskQueue.push(s)):s.reject(`child process exit with code: ${t} when it is busy`);this._run()},this.onTaskDone=()=>{this._run()}}runTask(s,t,e=(()=>{})){return new Promise((i,o)=>{const a={name:s,data:t,resolve:i,reject:o,retryTimes:0,onStatusUpdate:e};e(config_1.ETaskStatus.waiting),this._taskQueue.push(a),this._run()})}_run(){if(0===this._taskQueue.length)return;const s=this.allocChildProcess();s.status!==config_1.EChildProcessStatus.fullload&&s.status!==config_1.EChildProcessStatus.dying&&(s.runTask(this._taskQueue.shift()),this._run())}allocChildProcess(){return this._instance||(this._instance=new ChildProcessInstance(2*cpus),this._instance.on("exit",this.onChildProcessExit),this._instance.on("taskDone",this.onTaskDone)),this._instance}}exports.childProcessManager=new TaskManager;