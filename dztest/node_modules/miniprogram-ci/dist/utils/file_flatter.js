"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tryTranslateSingleFile=void 0;const babelCodeFrame=require("babel-code-frame"),OSPath=require("path"),parser=require("@babel/parser"),traverse_1=require("@babel/traverse"),sourcemap=require("source-map");class TranslateResult{constructor(){this.translated=!0,this.errMsg="",this.debugs=[],this.translatedContent="",this.fullPath="",this.translatedSourceMap=""}}function getErrorCodeFrame(e,n,r,t){let o;try{o=new sourcemap.SourceMapConsumer(n||""),e=o.sourceContentFor(r)||e}catch(e){}const i=[];for(const n of t){let r={line:n.line,column:n.column>0?n.column:0};try{o&&(r=o.originalPositionFor({line:n.line,column:n.column}))}catch(e){}const t=babelCodeFrame(e,r.line,r.column);i.push(`${n.reason}\n${t}`)}return i.join("\n\n")}function translateCode(e,n){const r=e.replace(/\r\n/g,"\n").split("\n");for(let e=0;e<r.length;e++){const t=r[e],o=n[e+1];if(o){const n=[];let i=0;for(const e in o){const r=o[e];n.push(t.substr(i,r.column-i+1)),n.push(r.toString),i=r.column+r.fromString.length+1}n.push(t.substr(i)),r[e]=n.join("")}}return r.join("\n")}function translateSourceMap(e,n,r){const t=new sourcemap.SourceMapConsumer(e),o=new sourcemap.SourceMapGenerator({file:n});let i;return t.eachMapping(e=>{if("number"!=typeof e.originalLine||"number"!=typeof e.originalColumn)return;const n={generated:{line:e.generatedLine,column:e.generatedColumn},source:e.source,name:e.name,original:{line:e.originalLine,column:e.originalColumn}};if(i&&i.line===e.generatedLine?n.generated.column+=i.offset:i=void 0,r[e.generatedLine]){const n=r[e.generatedLine][e.generatedColumn];n&&(i&&i.line===n.line?i.offset+=n.offset:i={line:n.line,offset:n.offset})}o.addMapping(n)}),o.toString()}function dirname(e){let n=e.split("/");return n.pop(),n.join("/")}function getNpmRequirePath(e,n,r){if(e.startsWith(".")||e.startsWith("/"))return!1;{let t,o=n;for(;o;)if(o=dirname(o),t=e.endsWith(".js")?OSPath.posix.join(o,"miniprogram_npm",e):OSPath.posix.join(o,"miniprogram_npm",e,"index.js"),r.includes(t))return t;return!1}}const tryTranslateSingleFile=e=>{const n=new TranslateResult,{filePath:r,nameMapping:t,code:o,rootPath:i,miniProgramJSFiles:a}=e;let l=OSPath.posix.dirname(OSPath.posix.relative(i,r));"."===l&&(l="");const s=[];let u;try{u=parser.parse(o)}catch(t){return s.push({line:t.loc&&t.loc.line||1,column:t.loc&&t.loc.column||1,reason:t.message}),n.translated=!1,n.errMsg=`in ${OSPath.posix.join(i,r)}\n${getErrorCodeFrame(o,e.sourceMap,e.sourceFileName,s)}`,n}const c={};if(traverse_1.default(u,{AssignmentExpression(e){const n=e.node.loc.start;"Identifier"===e.node.left.type&&"require"===e.node.left.name&&s.push({line:n.line,column:n.column,reason:"assigning other name with 'require'"}),"Identifier"===e.node.right.type&&"require"===e.node.right.name&&s.push({line:n.line,column:n.column,reason:"'require' should not be renamed"})},VariableDeclarator(e){const n=e.node.loc.start;e.node.id&&"Identifier"===e.node.id.type&&"require"===e.node.id.name&&s.push({line:n.line,column:n.column,reason:"(init) assigning other name with 'require'"}),e.node.init&&"Identifier"===e.node.init.type&&"require"===e.node.init.name&&s.push({line:n.line,column:n.column,reason:"(init) 'require' should not be renamed"})},CallExpression(e){const o=e.node.loc.start;for(const n of e.node.arguments)"Identifier"===n.type&&"require"===n.name&&s.push({line:o.line,column:o.column,reason:"passing 'require' as a parameter is not a good taste"});if("Identifier"===e.node.callee.type&&"require"===e.node.callee.name&&(1===e.node.arguments.length&&"StringLiteral"===e.node.arguments[0].type||s.push({line:o.line,column:o.column,reason:"'require' requires one and only one static string literal"})),"require"===e.node.callee.name&&1===e.node.arguments.length&&"StringLiteral"===e.node.arguments[0].type){const o=e.node.arguments[0].loc.start,i=e.node.arguments[0].value;let s=OSPath.posix.normalize(OSPath.posix.join(l,i));/\.js$/.test(s)||(s+=".js"),/^\//.test(s)&&(s=s.replace(/^\//,""));let u=t[s];if(u)u=t[r]?OSPath.posix.relative(OSPath.posix.dirname(t[r]),u):OSPath.posix.relative(l,u),c[o.line]||(c[o.line]={}),c[o.line][o.column]={line:o.line,column:o.column,fromString:i,toString:u,offset:u.length-i.length},n.debugs.push([r,i,"replace",[s,u]]);else{if(t[r]){let e=getNpmRequirePath(i,r,a);e&&(s=e),u=OSPath.posix.relative(OSPath.posix.dirname(t[r]),s),c[o.line]||(c[o.line]={}),c[o.line][o.column]={line:o.line,column:o.column,fromString:i,toString:u,offset:u.length-i.length},n.debugs.push([r,i,"replace",[s,u]])}n.debugs.push([r,i,"ignored"])}}},Identifier(e){const n=e.node.loc.start;if("require"===e.node.name){if("UnaryExpression"===e.parent.type&&"typeof"===e.parent.operator)return;"CallExpression"!==e.parent.type&&s.push({line:n.line,column:n.column,reason:`require is not being used properly in '${e.parent.type}'`})}}}),s.length>0)return n.translated=!1,n.errMsg=`in ${r}\n${getErrorCodeFrame(o,e.sourceMap,e.sourceFileName,s)}`,n;if(Object.keys(c).length>0){n.translatedContent=translateCode(o,c);try{n.translatedSourceMap=translateSourceMap(e.sourceMap||"",e.sourceFileName,c)}catch(e){}}else n.translatedContent=o,n.translatedSourceMap=e.sourceMap;return n};exports.tryTranslateSingleFile=tryTranslateSingleFile;